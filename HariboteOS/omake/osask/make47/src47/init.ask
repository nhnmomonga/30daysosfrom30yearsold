/* "init.ask" ver.4.0 copyright(C) 2004 H.Kawai(å·åˆç§€å®Ÿ), I.Tak., KIYOTO */

/* ãƒ—ãƒªãƒ—ãƒ­ã‚»ãƒƒã‚µã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã§ã€-DPCATã‹-DTOWNSã‚’æŒ‡å®šã™ã‚‹ã“ã¨ */

#define KROM  /* shellcall2ã«cmd0100ã‚’è¿½åŠ ã€‚æ¼¢å­—ROMâ†’GAPIãƒ‡ãƒ¼ã‚¿ãƒ‡ã‚³ãƒ¼ãƒ‰ */

#define	MAXWINDOW		80	/* 1024/32 */
#define	CALLFAR0(sel)	CALL(sel, 0)

/* 64ã‚¿ã‚¹ã‚¯ã¾ã§ã®æº–å‚™ã¯ã§ãã¦ã„ã‚‹ */

//	#define	CHECK_TSKPTR	1

#include "osaskinc.ask"

segment CODE(USE32, PARA);
default(code == CODE);

/* for debug */
void putstr();
void dumpreg();

#if (defined(TOWNS) && defined(CLGD543X))
	void clgd543XSetup();
	void clgd543XDetect();
#endif

#ifdef BOCHS
//	#define DEBUG031127		1
#endif

struct SS0_struct {
	void [32];
	char ring0_count, [3];
	/* void * */ int [4], ring0call[6], [2];
	char cli_count, [3];
	/* void * */ int [4], cli_call[6], [2];
};

void testmemory();
void init_areastr();
void ui32toa();
void ui8toa();
void output_string();
void initmalloc();
void set_modulesegment();
// void far KeyboardMdl::keyboardInit();
// void far KeyboardMdl::KeyboardIntDrv();
void get_area();
void free_area();
void create_task();
void get_memory();
void free_memory();
void alloc_memory();
void alloc_tagdir();
void add_tags();
void regist_module();
void search_tag_EAX();
void delete_directory();
void delete_binmodule();
void memcopy16();
void disable_diskcache();
void get_virtual();
void free_virtual();
void free_memory64();
void put_int_status_ec();
void put_int_status();

struct area_man_struct_sub {
	unsigned int size;
	unsigned int addr;
};

struct area_man_struct {
	char res0[8];
	unsigned int use, size0; // å˜ä½ã¯ãƒã‚¤ãƒˆ
	void [16];
	area_man_struct_sub data0, data[0];
	/* use < size0 ã¯å¸¸ã«æˆç«‹ã™ã‚‹ */
	/* data[use]ã¯-1,-1ã‚’æŒ‡ã™ */
	/* data0ã¯ç•ªå…µ0,0 */
};

struct resource_bitmap_struct {
	int len;
	int bitmap[0];
	/* bitmap[len - 4]ã¯0(terminator) */
	/* å…¨ã‚µã‚¤ã‚º(bytes) * 8 - 64 [å€‹]ã®ç®¡ç†ãŒã§ãã‚‹ */
};

struct GUIGUI_window_struct { // è¨ˆ32bytes
	int status, win_id_task, signal_base, msgbox;
	int x_size, y_size, x0, y0;
};

struct GUIGUI_work { /* SS:0xffffd000; */
	void [1024];
	area_man_struct linear_man[1024];
	area_man_struct dummy_man[1024];
	void [512];
	int infobuf[128];
	void [108];
	unsigned int v86irq_ofs, v86irq_sel;
	unsigned char v86flag, [3];
	unsigned int timer_sec4, root_Paddr;
	unsigned int dosload_phase, dosload_work[16];
	unsigned int diskcache_Laddr, diskbuf_Paddr, diskbuf_Laddr;
	unsigned int cacheflags[64 /* 2MBåˆ† */];
	unsigned int track[20 /* 160ãƒˆãƒ©ãƒƒã‚¯åˆ† */];
	unsigned int tapiwork_Laddr, tapiwork_Paddr;
	resource_bitmap_struct tapiwork_man[32];
	unsigned int root_size, root_addr;
	unsigned int setvideomode_mode, setvideomode_sig[12];
	unsigned int TAPI_sendmsgofs, TAPI_sendmsgsel;
	unsigned int cmd0100_buf[64];
	unsigned int timer_freq;
	/* 0xffffe000ï½0xfffff200 */
	area_man_struct virtual_man[2048];
	GUIGUI_window_struct winlist[1024], [1024], [512];
};

struct TAPI_TSS386 {  /* å…¨ã¦TL-0 */
	short BackLink, [2];
	int stack0_ESP; short stack0_SS, [2];
	int stack1_ESP; short stack1_SS, [2];
	int stack2_ESP; short stack2_SS, [2];
	int CR3;
	int EIP;
	int EFLAGS;
	int EAX, ECX, EDX, EBX;
	int ESP, EBP, ESI, EDI;
	short ES, [2], CS, [2], SS, [2];
	short DS, [2], FS, [2], GS, [2];
	short LDTR, [2], TaskFlags, IOBitMap;
	/* åˆè¨ˆ104bytes */
};

struct TAPI_GlvPrm { /* è¨ˆ64bytes */
	int run[12];
//	struct Tss near *Pointer;
	int pointer;
	int totalIlv; // +0x10
	int tasks;
	int MinIlv, MaxIlv;
	char flags; /* ãƒ•ãƒ©ã‚°ã«ã‚ˆã£ã¦ã¯ã€Ilvã‚’è€ƒæ…®ã—ãªã„ã€‚ */
	/* bit0:Ilvå¤‰æ›´ãƒ•ãƒ©ã‚°(0ã§å¤‰æ›´ã‚ã‚Š)ã€bit1:æ™‚åˆ†å‰²æŠ‘åˆ¶ãƒ•ãƒ©ã‚°(1ã§æŠ‘åˆ¶)ã€‚ */
	void [31];
};

struct TAPI_LlvPrm { // 32bytes
	int run[12];
	int Glv;
	int short_run[12]; /* 0x10ï½0x1b  0x1bãŒ-1ãªã‚‰ã€invalid */
	int Ilv;
};

struct TAPI_TSS {
	TAPI_TSS386 tss386;  /* TL-0ãƒ–ãƒ­ãƒƒã‚¯(104bytes) */

	/* system-signalå‡¦ç†ã®ãƒ–ãƒ­ãƒƒã‚¯(24bytes) */
	int sysbox_write_free, sysbox_write_ptr, sysbox_write_ptr0, sysbox_write_ptr1;
	int sysbox_read_ptr;
	unsigned char msgbox_status, softint_nest, [2];
		// bit0 : buffer write overrun
		// bit6 : sysbox empty(0:empty)
		// bit7 : msgbox empty(0:empty)

	int set[12], tr[4], run[12], ldt_img; /* TL-1ãƒ–ãƒ­ãƒƒã‚¯(48bytes) */
	int fpu_reg_img, sse_reg_img /* for SSE & SSE2 */;
//	TAPI_TSS near *back, near *next;
	int back, next;

	int softint_EIP /* +0x00b0 */; short softint_CS; /* signalå‡¦ç†ã®ãƒ–ãƒ­ãƒƒã‚¯(48bytes) */
	short softint_oldCS;
	int softint_oldEIP;
	unsigned char softint_Llv, sysint_Llv /* ã“ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯ä½¿ã‚ãªã„ã€‚softintã¨å…±é€š */, now_Llv, softint_oldLlv;
	int msgbox_write_free, msgbox_write_ptr, msgbox_write_ptr0, msgbox_write_ptr1;
	int msgbox_eom_code, msgbox_rewind_code, [8];

/*	softint_oldLlvã¯ã€ã‚¹ã‚¿ãƒƒã‚¯ã«ã¤ã‚€ã¨0xffã«å¤‰åŒ–ã™ã‚‹...ã§ã€0xffã®ã¨ãã«ã€ã‚¹ãƒˆã‚¢ã•ã‚Œã‚‹
	softint_CS == 0ã®ã¨ãã€CS:EIPã®å¤‰åŒ–ç„¡ã—
	softint_Llv == 0ã®ã¨ãã€Llvã®å¤‰åŒ–ç„¡ã— */

/* TL-2ãƒ–ãƒ­ãƒƒã‚¯ 32bytes */
//	GlvPrm near *Glv /* +0x00e0 */; /* TapiWorkSelã®ä¸­ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆ */
//	LlvPrm near *Llv; /* TapiWorkSelã®ä¸­ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆ */
	int Glv, Llv; // 0xe0ï½0xe7
	int Ilv, Llv_base; // Inner-level
	int short_run[12]; // +0x00f0
	char flags, [3];  /* Setã®å†è©•ä¾¡è¦æ±‚ãƒ•ãƒ©ã‚° */


/* ã“ã®ã‚¿ã‚¹ã‚¯ã®å…¨å®Ÿè¡Œæ™‚é–“ã¯ã€runã§ã¯ãªã„ã€‚runã¯ã€ç¾åœ¨ã®Llvã®runningã‚¿ã‚¤ãƒ ã‚’ç¤ºã—ã¦ã„ã‚‹ã«éããªã„ã€‚ */
/* ç¾åœ¨ã®Llvã®LlvPrm.runã¯ç„¡åŠ¹ã€‚ */

};

/* ã‚¿ã‚¹ã‚¯ã”ã¨ã®4KBã®ä½¿ã„é“ */
/*	(æœ€åˆã®1KB)
	TAPI_TSS			0.25KB
	LlvPrm				0.25KB(8lv)
	æœªä½¿ç”¨				 64bytes
	ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒœãƒƒã‚¯ã‚¹   64bytes
	FPUãƒ¬ã‚¸ã‚¹ã‚¿ã‚¤ãƒ¡ãƒ¼ã‚¸	108bytes
	ã‚·ã‚¹ãƒ†ãƒ ç®¡ç†ç”¨		 20bytes (+748)
	  tskdir, stack0_size, stack0_addr, stack3_size, stack3_addr
		â†‘ã“ã‚Œã‚‰ã¯ã€ãƒªãƒ‹ã‚¢ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’ã¯ãŒã™ãŸã‚ã«è¨˜æ†¶ã—ã¦ã„ã‚‹ã€‚ä»Šã¯ä¸€ç¶šããªã®ã§stack3ã¯ä½¿ã£ã¦ã„ãªã„ã€‚
	æœªä½¿ç”¨(SSEç”¨)		0.25KB
	(æ®‹ã‚Šã®3KB)
	msgbuf				0.50KB
	sysbuf				0.50KB
	ldt_img				1.00KB
	slot_img			1.00KB
*/

/* ãƒªãƒ‹ã‚¢ã‚¢ãƒ‰ãƒ¬ã‚¹ãƒãƒƒãƒ— */
/*	0MBï½1MB : 20bitãƒ¡ãƒ¢ãƒªç©ºé–“ã¨å¯¾å¿œ
	1MBï½3MB : ãƒ‡ã‚£ã‚¹ã‚¯ã‚­ãƒ£ãƒƒã‚·ãƒ¥ç®¡ç†ç”¨
	3MBï½4MB : ãƒ—ãƒ­ãƒ†ã‚¯ãƒˆãƒ¡ãƒ¢ãƒªãƒã‚§ãƒƒã‚¯
				20bitãƒ¡ãƒ¢ãƒªã‹ã‚‰ã®è»¢é€ç”¨ãƒãƒƒãƒ—é ˜åŸŸ

	4.5MBï½20MB : ç¬¬ä¸€ãƒªãƒ‹ã‚¢ã‚¢ãƒ‰ãƒ¬ã‚¹
	20MBï½64MB : ç¬¬äºŒãƒªãƒ‹ã‚¢ã‚¢ãƒ‰ãƒ¬ã‚¹
*/

/* ç‰©ç†ã‚¢ãƒ‰ãƒ¬ã‚¹ãƒãƒƒãƒ— */
/* 	0MBï½1MB : 20bitãƒ¡ãƒ¢ãƒª
	1MBï½0x267fff : ãƒ‡ã‚£ã‚¹ã‚¯ã‚­ãƒ£ãƒƒã‚·ãƒ¥
	2.41MBï½ : ãƒ•ãƒªãƒ¼
*/

struct GUIGUI_codeheader { /* 32bytes */
	void [8]; /* for jmp-vector */
	char signature[8]; /* 'GUIGUI00' */
	int stack3_size, stack3_reserve, [8];
	/* reverveã®bit0:
		0:reserveã€stackã®é †
		1:stackã€reserveã®é †(é€šå¸¸) */
};

void far Init()
/* é€²å…¥æ¡ä»¶ï¼š
   DS == syswork_seg, GS == IDT&GDT_seg (ã©ã¡ã‚‰ã‚‚ã‚»ãƒ¬ã‚¯ã‚¿ã§ã¯ãªã„ã“ã¨ã«æ³¨æ„ãŒå¿…è¦) */
{
	STR_SYSWORK *swork_DS == DS:0;
	STR_SYSWORK *swork_ES == ES:0;
	STR_SYSWORK *swork_GS == GS:0;

	SS0_struct *stack_ESP0 == /* SS:(- sizeof (SS0_struct)) */ SS:0xffffffc0;

	/* GDTã‚’ä½œã‚‹ãŸã‚ã®é–¢æ•°ã‚’ç”¨æ„ã—ãŸæ–¹ãŒã„ã„ã‹ã‚‚ã—ã‚Œãªã„
	   GS:EBXã«æ›¸ãè¾¼ã‚€ã€‚EDXã¯ãƒ™ãƒ¼ã‚¹ã€ECXã¯ã‚µã‚¤ã‚ºã€AXã¯ã‚¢ã‚¯ã‚»ã‚¹ãƒ©ã‚¤ãƒˆ
	   GS:EBXä»¥å¤–ã¯ç ´å£Š */

//	EAX = 0xc092 /* unit:page, use32, lv0, RW */;
//	ECX = 0; /* 0ã¯0x100000000ã‚’æ„å‘³ã™ã‚‹ */
//	EDX = 0x00000000;
//	EBX = 384 /* IDTã®åˆ† */ + SEL_ALL;
//	set_modulesegment();

	#if (defined(PCAT))
		EAX = 0x4092 /* unit:byte, use32, lv0, RW */;
		ECX = 0x00010000; /* 64KB */
		EDX = 0x000a0000;
		EBX = 384 /* IDTã®åˆ† */ + SEL_VRAM;
		set_modulesegment();
	#endif

	#if (defined(NEC98))
	//	AL = 0x06; // ch2ã®ãƒã‚¹ã‚¯ã‚’ã‚»ãƒƒãƒˆ
	//	OUT(0x0015, AL);
		EDX = 0x0439;
		IN(AL, DX);
		AL &= 0xfb;
		OUT(DX, AL); /* DMAã®A20-A23æœ‰åŠ¹ */
	//	AL = 0x06; /* 1MBå¢ƒç•Œ, ch2 */
	//	OUT(0x0029, AL);
	//	EDX = 0x0e09;
	//	AL = 0;
	//	OUT(DX, AL); /* ch2ã®A31-A24 = 0 */
		EAX = 0x4092 /* unit:byte, use32, lv0, RW */;
		ECX = 0x00040000; /* 256KB */
		EDX = 0x000a8000;
		EBX = 384 /* IDTã®åˆ† */ + SEL_VRAM;
		set_modulesegment();
	#endif

	/* tapiã‚³ãƒ¼ãƒ«ã®æ”¯éšœã«ãªã‚‰ãªã„ã‚ˆã†ã«ã€ãƒ€ãƒŸãƒ¼ã‚»ãƒ¬ã‚¯ã‚¿ã‚’ä½œã‚‹ */
	EAX = 0xc092 /* unit:page, use32, lv0, RW */;
	ECX = 0; /* 0ã¯0x100000000ã‚’æ„å‘³ã™ã‚‹ */
	EDX = 0x00000000;
	EBX = 384 /* IDTã®åˆ† */ + SEL_TAPIWORK;
	set_modulesegment();

	#if (defined(CHECK_TSKPTR))
		EAX = swork_DS->alloclist[ENT_TAPIWORK + 12];
		EAX += 0x000c;
		asmout("MOV DR0,EAX");
		EAX = 0;
		asmout("MOV DR6,EAX");
		asmout("MOV EAX,1000000010B+1101B*10000H");
			/* GE = G0 = 1; LEN0 = 3 (DW); RW0 = 01 (write only); */
		asmout("MOV DR7,EAX");
	#endif

	#if 0
		EAX = swork_DS->alloclist[ENT_TAPIWORK + 12];
		EAX += 28;
		asmout("MOV DR0,EAX");
		EAX = 0;
		asmout("MOV DR6,EAX");
		asmout("MOV EAX,1000000010B+1101B*10000H");
			/* GE = G0 = 1; LEN0 = 3 (DW); RW0 = 01 (write only); */
		asmout("MOV DR7,EAX");
	#endif

	#if 0
		EAX = 0x480000 + 0x2d20 + 28;
		asmout("MOV DR0,EAX");
		EAX = 0;
		asmout("MOV DR6,EAX");
		asmout("MOV EAX,1000000010B+1101B*10000H");
			/* GE = G0 = 1; LEN0 = 3 (DW); RW0 = 01 (write only); */
		asmout("MOV DR7,EAX");
	#endif

	/* ã‚¹ã‚¿ãƒƒã‚¯ã‚‚åˆ‡ã‚Šæ›¿ã‚ã£ã¦ã„ãªã„ã€‚ */
	/* ã‚·ã‚¹ãƒ†ãƒ ã‚¹ã‚¿ãƒƒã‚¯ã‚’æŠ¼ã—ä¸Šã’ã¦ã€ãƒ¡ãƒ¢ãƒªã€TAPIworkã€GDTã®ç®¡ç†ãƒ–ãƒ­ãƒƒã‚¯ã‚’ä½œã‚‹ã€‚ */

//	EAX = SEL_STACK;
	EDX = 0;
//	SS = EAX;
//	ESP = /* (offset) stack_ESP0 */ 0xffffd000; /* ã‚¹ã‚¿ãƒƒã‚¯ã®åˆæœŸåŒ– */
	EDX -= 0x80; /* EDX = 0xffffff80; */
	(int) stack_ESP0->ring0_count = EDX /* 0xffffff80 */;
	(int) stack_ESP0->cli_count   = EDX /* 0xffffff80 */;

	GUIGUI_work *work == SS:0xffffd000;
	area_man_struct *areastrEBP == SS:EBP;
//	EDX = 0;
	EAX = 0;
//	EDX--;
	EDX += 0x7f; /* EDX = 0xffffffff; */
	/* EBP = (offset) work->virtual_man; */ LEA(EBP, (int) work->virtual_man);
	ECX = 2048 - 40;
	init_areastr();
//	/* EBP = (offset) work->mem24_man; */ LEA(EBP, (int) work->mem24_man);
//	ECX = 512 - 40;
//	init_areastr();
//	/* EBP = (offset) work->mem20_man; */ LEA(EBP, (int) work->mem20_man);
///	ECX = 512 - 40;
//	init_areastr();
	/* EBP = (offset) work->linear_man; */ LEA(EBP, (int) work->linear_man);
	ECX = 1024 - 40;
	init_areastr();

	ECX = 0;
	PUSH(SEL_SYSWORK);
	POP(ES);
	DL = [ES:ECX + 0x001c + 2 /* eflags[2] */];

	PUSH(SS);
//	ECX = 0;
	ESI = 0x0108;
	POP(FS);

	/* PAPIåˆæœŸåŒ– */
	PUSH((int) ECX /* eoc */);
	PUSH(ECX);
	PUSH(ECX);
	PUSH(ECX);
	PUSH(0x0100 /* init cmd */);
	EBX = ESP;
	CALLFAR0(SEL_PAPI);
	ESP += 20 - 4; /* eocãŒæ®‹ã£ã¦ã„ã‚‹ */

	#if (defined(PCAT))
		EAX = 0x1007 /* present, R/W, user, override */;
		TEST(DL, 0x04);
		if (!= 0)
			AL = 0x1f /* VRAMã¯ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã—ãªã„(PCD=1) */;

	//	ECX = 0;
	//	PUSH((int) ECX /* eoc */);

		/* mapping PC-Card Window (0xac000000ï½0xac3fffff) */
		PUSH((int) ECX /* addr64(high) */);
		PUSH((int) 0xac000000 /* addr64(low) */);
		PUSH((int) ECX /* offset64(high) */);
		PUSH((int) ECX /* offset64(low) */);
		PUSH((int) ECX /* pageset */);
		PUSH((int) 0xac000000 /* linear */);
		PUSH((int) 4 * 1024 * 1024 /* size */);
		PUSH((int) EAX /* opt(PCD, present, R/W, user, override) */);
		PUSH((int) ESI /* cmd(mapping) */);

		/* mapping BIOS (for VESA call) (0x000c0000ï½0x000fffff) */
		/* mapping high memory (0x00100000ï½0x002fffff) */

	//	PUSH((int) ECX /* addr64(high) */);
	//	PUSH((int) 0x000c0000 /* addr64(low) */);
	//	PUSH((int) ECX /* offset64(high) */);
	//	PUSH((int) ECX /* offset64(low) */);
	//	PUSH((int) ECX /* pageset */);
	//	PUSH((int) 0x000c0000 /* linear */);
	//	PUSH((int) 2304 * 1024 /* size(128K + 2M) */);
	//	PUSH((int) 0x0007 /* opt(present, R/W, user) */);
	//	PUSH((int) ESI /* cmd(mapping) */);

		/* mapping VRAM (0x000a0000ï½0x000bffff) & PC-card window & BIOS */
		/* (0x000a0000ï½0x000fffff) */

		PUSH((int) ECX /* addr64(high) */);
		PUSH((int) 0x000a0000 /* addr64(low) */);
		PUSH((int) ECX /* offset64(high) */);
		PUSH((int) ECX /* offset64(low) */);
		PUSH((int) ECX /* pageset */);
		PUSH((int) 0x000a0000 /* linear */);
		PUSH((int) 384 * 1024 /* size */);
		PUSH((int) EAX /* opt(PCD, present, R/W, user, override) */);
		PUSH((int) ESI /* cmd(mapping) */);

		EBX = ESP;
		CALLFAR0(SEL_PAPI);
		ESP += 36 + 36; /* eocãŒæ®‹ã£ã¦ã„ã‚‹ */
	#elif (defined(TOWNS))
		EBX = 0x80100000;
		IN(AX, 0x0030); /* CPUè­˜åˆ¥ãƒ¬ã‚¸ã‚¹ã‚¿ */
		AL &= 0x07;
		CMP(AL, 0x03);
		if (==) /* i386SX */
			EBX = 0x00b00000;
		TEST(DL, 0x04);
		EAX = 0x07 /* present, R/W, user */;
		if (!= 0)
			AL = 0x1f /* VRAMã¯ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã—ãªã„(PCD=1) */;

	//	ECX = 0;
	//	PUSH((int) ECX /* eoc */);

		/* mapping VRAM (0x80100000ï½0x80180000) */

		PUSH((int) ECX /* addr64(high) */);
		PUSH((int) EBX /* addr64(low) */);
		PUSH((int) ECX /* offset64(high) */);
		PUSH((int) ECX /* offset64(low) */);
		PUSH((int) ECX /* pageset */);
		PUSH((int) 0xe0000000 /* linear */);
		PUSH((int) 512 * 1024 /* size */);
		PUSH((int) EAX /* opt(PCD, present, R/W, user) */);
		PUSH((int) ESI /* cmd(mapping) */);

		/* mapping high memory (0x00100000ï½0x002fffff) */

//		PUSH((int) ECX /* addr64(high) */);
//		PUSH((int) 0x00100000 /* addr64(low) */);
//		PUSH((int) ECX /* offset64(high) */);
//		PUSH((int) ECX /* offset64(low) */);
//		PUSH((int) ECX /* pageset */);
//		PUSH((int) 0x00100000 /* linear */);
//		PUSH((int) 2048 * 1024 /* size(2M) */);
//		PUSH((int) 0x0007 /* opt(present, R/W, user) */);
//		PUSH((int) ESI /* cmd(mapping) */);

		/* mapping RAM (0x000a0000ï½0x000bffff) */

//		PUSH((int) ECX /* addr64(high) */);
//		PUSH((int) 0x000a0000 /* addr64(low) */);
//		PUSH((int) ECX /* offset64(high) */);
//		PUSH((int) ECX /* offset64(low) */);
//		PUSH((int) ECX /* pageset */);
//		PUSH((int) 0x000a0000 /* linear */);
//		PUSH((int) 128 * 1024 /* size */);
//		PUSH((int) 0x0007 /* opt(present, R/W, user) */);
//		PUSH((int) ESI /* cmd(mapping) */);
		EBX = ESP;
		CALLFAR0(SEL_PAPI);
//		ESP += 112;
		ESP += 36; /* eocãŒæ®‹ã£ã¦ã„ã‚‹ */

		/* mapping PC-Card Window */
		/* CXä»¥é™ã®é386SXã§ã‚ã‚Œã°ã€EBXã‚’0xc1000000ã«ã™ã‚‹ã¹ãã  */

		PUSH(EAX);
		EBX = 0xc0000000;
		IN(AX, 0x0030); /* CPUè­˜åˆ¥ãƒ¬ã‚¸ã‚¹ã‚¿ */
		AL &= 0x07;
		CMP(AL, 0x03);
		if (==) /* i386SX */
			EBX = 0x00d00000;
		POP(EAX);
	//	PUSH(0);
		PUSH((int) ECX /* addr64(high) */);
		PUSH((int) EBX /* addr64(low) */);
		PUSH((int) ECX /* offset64(high) */);
		PUSH((int) ECX /* offset64(low) */);
		PUSH((int) ECX /* pageset */);
		PUSH((int) 0xe03ff000 /* linear */);
		PUSH((int) 4 * 1024 /* size */);
		PUSH((int) EAX /* opt(PCD, present, R/W, user) */);
		PUSH((int) ESI /* cmd(mapping) */);
		EBX = ESP;
		CALLFAR0(SEL_PAPI);
		ESP += 36; /* eocãŒæ®‹ã£ã¦ã„ã‚‹ */

	#endif

	#if (defined(NEC98))
		EAX = 0x1007 /* present, R/W, user, override */;
		TEST(DL, 0x04);
		if (!= 0)
			AL = 0x1f /* VRAMã¯ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã—ãªã„(PCD=1) */;

	//	ECX = 0;
	//	PUSH((int) ECX /* eoc */);

		/* mapping high memory (0x00100000ï½0x002fffff) */

	//	PUSH((int) ECX /* addr64(high) */);
	//	PUSH((int) 0x00100000 /* addr64(low) */);
	//	PUSH((int) ECX /* offset64(high) */);
	//	PUSH((int) ECX /* offset64(low) */);
	//	PUSH((int) ECX /* pageset */);
	//	PUSH((int) 0x00100000 /* linear */);
	//	PUSH((int) 2048 * 1024 /* size(2M) */);
	//	PUSH((int) 0x0007 /* opt(present, R/W, user) */);
	//	PUSH((int) ESI /* cmd(mapping) */);

		/* mapping VRAM (0x000a0000ï½0x000e7fff) */

		PUSH((int) ECX /* addr64(high) */);
		PUSH((int) 0x000a0000 /* addr64(low) */);
		PUSH((int) ECX /* offset64(high) */);
		PUSH((int) ECX /* offset64(low) */);
		PUSH((int) ECX /* pageset */);
		PUSH((int) 0x000a0000 /* linear */);
		PUSH((int) 288 * 1024 /* size */);
		PUSH((int) EAX /* opt(PCD, present, R/W, user) */);
		PUSH((int) ESI /* cmd(mapping) */);

		EBX = ESP;
		CALLFAR0(SEL_PAPI);
		ESP += 36; /* eocãŒæ®‹ã£ã¦ã„ã‚‹ */
	#endif

	ECX = swork_ES->bootmalloc_fre1;
	EAX = swork_ES->bootmalloc_adr1;
	free_memory(); /* ãƒ•ãƒªãƒ¼ãƒ¡ãƒ¢ãƒªã®ç™»éŒ² */
	ECX = swork_ES->bootmalloc_fre2;
	if ((unsigned) ECX > 0) {
		EAX = swork_ES->bootmalloc_adr2;
		free_memory();
	}
	ECX = swork_ES->bootmalloc_fre3;
	if ((unsigned) ECX > 0) {
		EAX = swork_ES->bootmalloc_adr3;
		free_memory();
	}

//	EAX = 0x1000; /* ä½™ã£ãŸ0x800ã¯ã€ãƒ¯ãƒ¼ã‚¯ã‚¨ãƒªã‚¢ã‹ã‚‚ã—ãã¯Glvã«ã€‚ */
//	ECX = swork_ES->alloclist[ENT_TAPIWORK +  8]; /* size */
//	ECX -= EAX;
//	/* ESI = (offset) work->tapiwork_man; */ LEA(ESI, (int) work->tapiwork_man);
//	free_area(); /* tapiworkã®ç©ºãé ˜åŸŸ */

//	EAX = freegdt_sel;
//	ECX = swork_ES->alloclist[ENT_IDTGDT +  8]; /* size */
//	ECX -= EAX;
//	ECX -= 0x30 * 8; /* IDTã®åˆ†ã‚’å¼•ã */
//	/* ESI = (offset) work->gdt_man; */ LEA(ESI, (int) work->gdt_man);
//	free_area(); /* æœªä½¿ç”¨ã®GDTã®ç™»éŒ² */

	EAX = 0;
	LEA(EBP, work->tapiwork_man.bitmap[0]);
//	EAX = 0xffffffff;
	EAX--;
	ECX = 32 - 4;
	(int) [SS:EBP - 4 /* len */] = ECX;
	do {
		[SS:EBP] = EAX;
		EBP += 4;
		ECX -= 4;
	} while (!= 0);

	PUSH(SS);
	POP(DS);
	EAX = 0x80000000;
	ECX = 0x7ffffffe; /* 8TBå¼± */
	/* ESI = (offset) work->virtual_man; */ LEA(ESI, (int) work->virtual_man);
	free_area();

	EAX = swork_ES->bootlinear;
	ECX = 256 * 1024 * 1024;
	ECX -= EAX; /* 4.5MBï½256MB */
	/* ESI = (offset) work->linear_man; */ LEA(ESI, (int) work->linear_man);
	free_area();

	/* work->winlistã‚’åˆæœŸåŒ–ã™ã‚‹ */
	/* EBP = (offset) work->winlist; */ LEA(EBP, (int) work->winlist);
	EAX = 0;
	ECX = MAXWINDOW * 32 / 4;
	do {
		[SS:EBP] = EAX;
		EBP += 4;
		ECX--;
	} while (!= 0);

	/* IDTè¨­å®š */

	EAX = SEL_IDTGDT;
	GS = EAX;
	DS = EAX;

	unsigned char *idt_table == CS:EDI;
	unsigned short *idt_table2 == CS:EDI;
	asmout("MOV EDI,OFFSET Init_idt_table");
	EBX = idt_table[1];
	EBX *= 8;
	EDX = 0;
	EBP = 0;
	do {
		AX = idt_table2[2];
		CX = idt_table2[4];
		DH = idt_table[0];
		(offset) idt_table += 6;
		(short) [DS:EBX + 0] = AX;
		(short) [DS:EBX + 4] = DX;
		(short) [DS:EBX + 2] = CX;
		(short) [DS:EBX + 6] = BP /* == 0 */;
		EBX = idt_table[1];
		EBX *= 8;
	} while (!= 0);

//	AX = SS; FS = AX;
//	PUSH((int) 0); /* eoc */
	PUSH(EAX);
	PUSH(EAX);
	PUSH((int) 0x0120 /* TAPI_INT07ã®ãƒ™ã‚¯ã‚¿ã‚’è¦æ±‚ */);
	EBX = ESP;
	CALLFAR0(SEL_TAPI);
	POP(EDX);
	EBX = 0x0038 /* int07 */;
	POP(EAX);
	POP(ECX); /* eocãŒæ®‹ã£ã¦ã„ã‚‹ */
//	POP(EDX);
	(short) [DS:EBX + 0] = AX;
	(unsigned int) EAX >>= 16;
	(short) [DS:EBX + 2] = CX;
	(short) [DS:EBX + 4] = 0x8f00;
	(short) [DS:EBX + 6] = AX;

//	PUSH((int) 0); /* eoc */
	#if (defined(PCAT))
		PUSH(EAX);
		PUSH(EAX);
		PUSH((int) 0x0128 /* MouseIntDrvã®ãƒ™ã‚¯ã‚¿ã‚’è¦æ±‚ */);
	#endif
	PUSH(EAX);
	PUSH(EAX);
	PUSH((int) 0x0124 /* KeyboardIntDrvã®ãƒ™ã‚¯ã‚¿ã‚’è¦æ±‚ */);
	EBX = ESP;
	CALLFAR0(SEL_KEYINT);
	POP(EDX);
	EBX = 0x0108 /* int21 */;
	POP(EAX);
	POP(ECX);
	(short) [DS:EBX + 0] = AX;
	(unsigned int) EAX >>= 16;
	(short) [DS:EBX + 2] = CX;
	(short) [DS:EBX + 4] = 0x8e00;
	(short) [DS:EBX + 6] = AX;
	#if (defined(PCAT))
		POP(EDX);
	//	EBX = 0x0160 /* int2c */;
		BL = 0x60;
		POP(EAX);
		POP(ECX);
		(short) [DS:EBX + 0] = AX;
		(unsigned int) EAX >>= 16;
		(short) [DS:EBX + 2] = CX;
		(short) [DS:EBX + 4] = 0x8e00;
		(short) [DS:EBX + 6] = AX;
	#endif
//	POP(EDX);

//	PUSH((int) 0); /* eoc */
	PUSH(EAX);
	PUSH(EAX);
	PUSH((int) 0x0104 /* FDC_intã®ãƒ™ã‚¯ã‚¿ã‚’è¦æ±‚ */);
	EBX = ESP;
	CALLFAR0(SEL_FDCDRIVE);
	POP(EDX);
	#if (defined(PCAT) || defined(TOWNS))
		EBX = 0x0130 /* int26 */;
	#elif (defined(NEC98))
		EBX = 0x0158 /* int2b */;
	#endif
	POP(EAX);
	POP(ECX);
//	POP(EDX);
	(short) [DS:EBX + 0] = AX;
	(unsigned int) EAX >>= 16;
	(short) [DS:EBX + 2] = CX;
	(short) [DS:EBX + 4] = 0x8e00;
	(short) [DS:EBX + 6] = AX;

//	PUSH((int) 0); /* eoc */
	PUSH((int) 0x0100 /* keyboardInit */);
	EBX = ESP;
	CALLFAR0(SEL_KEYINT);
//	ESP += 8 - 4;

//	PUSH((int) 0); /* eoc */
//	PUSH(EAX);
	PUSH(EAX);
	PUSH((int) 0x0108 /* Keydecode_Mainã¸ã®ãƒ™ã‚¯ã‚¿å–å¾— */);
	PUSH((int) 0x0100 /* Keydecode_Init */);
	EBX = ESP;
	CALLFAR0(SEL_DECODE);
	POP(EAX);
	EBX = ESP;
	(int) [SS:ESP] = 0x0110; /* connect Decoder */
	CALLFAR0(SEL_KEYINT);
//	ESP += 16 - 4;

	/* Page Fault Handler */

//	PUSH((int) 0); /* eoc */
//	PUSH(EAX);
//	PUSH(EAX);
//	PUSH((int) 0x0104 /* PageFaultHandlerã¸ã®ãƒ™ã‚¯ã‚¿å–å¾— */);
	(int) [SS:ESP] = 0x0104 /* PageFaultHandlerã¸ã®ãƒ™ã‚¯ã‚¿å–å¾— */;
	EBX = ESP;
	CALLFAR0(SEL_PAPI);
	POP(ECX);
	EBX = 0x0070 /* int0e */;
	POP(EAX /*  */);
	POP(ECX);
	(short) [DS:EBX + 0] = AX;
	(unsigned int) EAX >>= 16;
	(short) [DS:EBX + 2] = CX;
	(short) [DS:EBX + 4] = 0x8e00;
	(short) [DS:EBX + 6] = AX;
	/* eocãŒæ®‹ã£ã¦ã„ã‚‹ */

	/* PICåˆæœŸåŒ– */

	#if (defined(PCAT))
		AL = 0x11; /* ICW1 (edge trigger) */
		OUT(0x20, AL); /* master */
		NOP();
		OUT(0xa0, AL); /* slave */
		AL = 0x20; /* ICW2(int-no.) */
		OUT(0x21, AL); /* master */
		AL = 0x28; /* ICW2(int-no.) */
		OUT(0xa1, AL); /* slave */
		AL = 0x04; /* ICW3 slaveãŒã¤ãªãŒã£ã¦ã„ã‚‹IRQã®bitã‚’1ã«ã™ã‚‹(bit2 = 1) */
		OUT(0x21, AL); /* master */
		AL = 0x02; /* ICW3 slaveã¯masterã®ä½•ç•ªã«æ¥ç¶šã•ã‚Œã¦ã„ã‚‹ã‹(IRQ 02) */
		OUT(0xa1, AL); /* slave */
		AL = 0x01; /* ICW4(non-buf. mode) */
		OUT(0x21, AL); /* master */
		AL = 0x01; /* ICW4(non-buf. mode) */
		OUT(0xa1, AL); /* slave */
		AL = 0xb9; /* OCW1 keyboardã¨slaveã¨FDCã ã‘ã‚’è¨±å¯ 10111001 */
		OUT(0x21, AL); /* master */
		AL = 0xef; /* OCW1  mouseã ã‘è¨±å¯ 11101111b */
		OUT(0xa1, AL); /* slave */
		AL = 0x4a; /* OCW3 IRRèª­ã¿è¾¼ã¿ ç‰¹æ®Šãƒã‚¹ã‚¯ãƒ¢ãƒ¼ãƒ‰ãƒªã‚»ãƒƒãƒˆ 01001010 */
		OUT(0x20, AL); /* master */
		AL = 0x4b; /* OCW3 ISRèª­ã¿è¾¼ã¿ ç‰¹æ®Šãƒã‚¹ã‚¯ãƒ¢ãƒ¼ãƒ‰ãƒªã‚»ãƒƒãƒˆ 01001011 */
		OUT(0xa0, AL); /* slave */
	#endif
	#if (defined(TOWNS))
		AL = 0x19; /* ICW1 (level trigger) */
		OUT(0x00, AL); /* master */
		NOP();
		OUT(0x10, AL); /* slave */
		AL = 0x20; /* ICW2(int-no.) */
		OUT(0x02, AL); /* master */
		AL = 0x28; /* ICW2(int-no.) */
		OUT(0x12, AL); /* slave */
		AL = 0x80; /* ICW3 slaveãŒã¤ãªãŒã£ã¦ã„ã‚‹IRQã®bitã‚’1ã«ã™ã‚‹(bit7 = 1) */
		OUT(0x02, AL); /* master */
		AL = 0x07; /* ICW3 slaveã¯masterã®ä½•ç•ªã«æ¥ç¶šã•ã‚Œã¦ã„ã‚‹ã‹(IRQ 07) */
		OUT(0x12, AL); /* slave */
		AL = 0x1d; /* ICW4(buf.-master mode) */
		OUT(0x02, AL); /* master */
		AL = 0x09; /* ICW4(buf.-slave mode) */
		OUT(0x12, AL); /* slave */
		AL = 0x3d; /* OCW1 keyboardã¨slaveã¨FDCã ã‘ã‚’è¨±å¯ 00111101 */
		OUT(0x02, AL); /* master */
		AL = 0xff; /* OCW1 å…¨ã¦ãƒã‚¹ã‚¯ */
		OUT(0x12, AL); /* slave */
		AL = 0x4a; /* OCW3 IRRèª­ã¿è¾¼ã¿ ç‰¹æ®Šãƒã‚¹ã‚¯ãƒ¢ãƒ¼ãƒ‰ãƒªã‚»ãƒƒãƒˆ 01001010 */
		OUT(0x00, AL); /* master */
		AL = 0x4b; /* OCW3 ISRèª­ã¿è¾¼ã¿ ç‰¹æ®Šãƒã‚¹ã‚¯ãƒ¢ãƒ¼ãƒ‰ãƒªã‚»ãƒƒãƒˆ 01001011 */
		OUT(0x10, AL); /* slave */
	#endif
	#if (defined(NEC98))
		AL = 0x11; /* ICW1 (edge trigger) */
		OUT(0x00, AL); /* master */
		NOP();
		OUT(0x08, AL); /* slave */
		AL = 0x20; /* ICW2(int-no.) */
		OUT(0x02, AL); /* master */
		AL = 0x28; /* ICW2(int-no.) */
		OUT(0x0a, AL); /* slave */
		AL = 0x80; /* ICW3 slaveãŒã¤ãªãŒã£ã¦ã„ã‚‹IRQã®bitã‚’1ã«ã™ã‚‹(bit7 = 1) */
		OUT(0x02, AL); /* master */
		AL = 0x07; /* ICW3 slaveã¯masterã®ä½•ç•ªã«æ¥ç¶šã•ã‚Œã¦ã„ã‚‹ã‹(IRQ 07) */
		OUT(0x0a, AL); /* slave */
		AL = 0x1d; /* ICW4(buf.-master mode) */
		OUT(0x02, AL); /* master */
		AL = 0x09; /* ICW4(buf.-slave mode) */
		OUT(0x0a, AL); /* slave */
	//	AL = 0x7d; /* OCW1 keyboardã¨slaveã ã‘ã‚’è¨±å¯ 01111101 */
		AL = 0x7f; /* OCW1 slaveã ã‘ã‚’è¨±å¯ 01111101 */
		OUT(0x02, AL); /* master */
		AL = 0xf7; /* OCW1 FDCã ã‘ã‚’è¨±å¯ 11110111 */
		OUT(0x0a, AL); /* slave */
		AL = 0x4a; /* OCW3 IRRèª­ã¿è¾¼ã¿ ç‰¹æ®Šãƒã‚¹ã‚¯ãƒ¢ãƒ¼ãƒ‰ãƒªã‚»ãƒƒãƒˆ 01001010 */
		OUT(0x00, AL); /* master */
		AL = 0x4b; /* OCW3 ISRèª­ã¿è¾¼ã¿ ç‰¹æ®Šãƒã‚¹ã‚¯ãƒ¢ãƒ¼ãƒ‰ãƒªã‚»ãƒƒãƒˆ 01001011 */
		OUT(0x08, AL); /* slave */
	#endif

	STI(); // IF = 1;

	/* ãƒ•ã‚©ãƒ³ãƒˆãƒ­ãƒ¼ãƒ‰ for debug */
	#if (defined(BOCHS))
	//	PUSH((int) 0x0000);
		PUSH((int) 7 * 8 /* ankfont-sel */);
		PUSH((int) 0x0000 /* offset */);
		PUSH((int) 0x1000 /* to */);
		PUSH((int) 0x0100 /* len */);
		PUSH((int) 0x0001 /* type */);
		PUSH((int) 0x0000 /* opt */);
		PUSH((int) 0x0104 /* loadfont(gapi cmd) */);
		EBX = ESP;
	//	PUSH(SS);
	//	POP(FS);
		CALLFAR0(SEL_GAPI);
		ESP += 28; /* eocãŒæ®‹ã£ã¦ã„ã‚‹ */
	#endif

	/* ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰åˆæœŸåŒ–ã¨ãƒ—ãƒ­ãƒ†ã‚¯ãƒˆãƒ¡ãƒ¢ãƒªåˆæœŸåŒ–ã‚’ã‚„ã‚‹ */
	/* å¹³è¡Œã—ã¦ã€FDDåˆæœŸåŒ–ã‚‚ã§ãã‚‹ã€‚ */

//	PUSH((int) 0); /* eoc */
	PUSH((int) 0x0104 /* KeyboardReset */);
	EBX = ESP;
	CALLFAR0(SEL_KEYINT);
	POP(EAX); /* eocãŒæ®‹ã£ã¦ã„ã‚‹ */

	#if (defined(PCAT))
	//	PUSH((int) 0); /* eoc */
		PUSH((int) 0x0120 /* MouseEnable */);
		PUSH((int) 0x011c /* MouseReset */);
		EBX = ESP;
		CALLFAR0(SEL_KEYINT);
		POP(EAX);
		POP(EAX); /* eocãŒæ®‹ã£ã¦ã„ã‚‹ */

	//	PUSH((int) 0); /* eoc */
		EAX = (unsigned char) swork_ES->boot_keylock;
		PUSH(EAX); /* Lock Status */
		PUSH((int) 0x0104 /* Keydecode_setlock */);
		EBX = ESP;
		CALLFAR0(SEL_DECODE);
		POP(EAX);
		POP(EAX); /* eocãŒæ®‹ã£ã¦ã„ã‚‹ */
	#endif

	/* tapiworkã®ãŸã‚ã®ãƒ¡ãƒ¢ãƒªç©ºé–“ã‚’ç¢ºä¿ */
	PUSH(SS);
	/* ESI = (offset) work->linear_man; */ LEA(ESI, (int) work->linear_man);
	POP(DS);
	ECX = 64 * 4096; /* 256KB */
	get_area();
//	if (ZF == 1)
//		INT(0x03); /* ã‚ã‚Šãˆãªã„ï¼ */
	work->tapiwork_Laddr = EAX;
	EDX = EAX;

	/* å…±é€šéƒ¨åˆ†ã®4KBã ã‘ãƒ¡ãƒ¢ãƒªã‚’å‰²ã‚Šå½“ã¦ã¦ã‚„ã‚‹ */
	ECX = 4096;
	get_memory();
//	if (ZF == 1)
//		INT(0x03); /* ã‚ã‚Šãˆãªã„ï¼ */
	work->tapiwork_Paddr = EAX;

	EBX = 0;
//	PUSH((int) EBX /* eoc */);
	PUSH((int) EBX /* addr64(high) */);
	PUSH((int) EAX /* addr64(low) */);
	PUSH((int) EBX /* offset64(high) */);
	PUSH((int) EBX /* offset64(low) */);
	PUSH((int) EBX /* pageset */);
	PUSH((int) EDX /* linear */);
	PUSH((int) ECX /* size */);
	PUSH((int) 0x0007 /* opt(present, R/W, user) */);
	PUSH((int) 0x0108 /* cmd(mapping) */);
	EBX = ESP;
	CALLFAR0(SEL_PAPI);
	ESP += 36; /* eocãŒæ®‹ã£ã¦ã„ã‚‹ */

	PUSH(GS);
	EBX = 384 + SEL_TAPIWORK;
	PUSH(SEL_IDTGDT);
	ECX = 64 * 4096;
//	EDX = work->tapiwork_Laddr;
	POP(GS);
	EAX = 0x4092 /* lv0, Read/Write, use32 */;
	set_modulesegment();
	POP(GS);

//	AX = SS; FS = AX;

#ifdef DEBUG031127
PUSH(DS); PUSH(SEL_TAPIWORK); POP(DS); (int) [DS:12] = 1; POP(DS);
#endif

	PUSH(SEL_IDTGDT);
	POP(DS);

	#if (defined(PCAT) | defined(TOWNS))
	//	PUSH(0); /* EOC */
		ESP -= 24;
		PUSH(0x0008); /* vectors */
		PUSH(0x0004); /* special */
		EBX = ESP;
		CALLFAR0(SEL_TIMERINT);
		EAX = [SS:ESP + 0x10]; /* mscountç”¨ãƒ™ã‚¯ã‚¿ */
		EBX = 0x20 * 8;
		(short) [DS:EBX + 0] = AX;
		(unsigned int) EAX >>= 16;
		(short) [DS:EBX + 4] = 0x8e00;
		(short) [DS:EBX + 2] = SEL_TIMERINT;
		(short) [DS:EBX + 6] = AX;
		ESP += 24; /* ?, ?, eocã¯æ®‹ã£ã¦ã„ã‚‹ */
		PUSH(0x000c); /* calc_count1ms */
		PUSH(0x0004); /* special */
		EBX = ESP;
		CALLFAR0(SEL_TIMERINT);
		POP(EAX);
		POP(EAX);
		POP(EDX);
		POP(EAX); /* eocãŒæ®‹ã£ã¦ã„ã‚‹ */
	#endif
	#if (defined(QEMU) | 1)
		/* å®Ÿæ©Ÿã§ã¯ã“ã‚“ãªã‚³ãƒ¼ãƒ‰ã¯è¦ã‚‰ãªã„ã®ã ãŒãƒ»ãƒ»ãƒ» */
		/* qemuã¨bochsã®ãŸã‚ã« */
		if ((signed) EDX <= 15)
			EDX = 15; /* ã¦ãã¨ãƒ¼ãªã‚ãŸã„ */
	#endif

#ifdef DEBUG031127
PUSH(DS); PUSH(SEL_TAPIWORK); POP(DS); (int) [DS:12] = 2; POP(DS);
#endif

	/* Timer, TAPIã‚’èµ·å‹• */
	CLI();
//	PUSH(0 /* eoc */);
	PUSH(EAX /* reserve */);
	PUSH(EAX /* reserve */);
	PUSH(0 /* init */);
	PUSH(4 /* special */);
	EBX = ESP;
	CALLFAR0(SEL_TIMERINT);
	/* 4, 0, ?, ?, eocãŒæ®‹ã£ã¦ã„ã‚‹ */

#ifdef DEBUG031127
PUSH(DS); PUSH(SEL_TAPIWORK); POP(DS); (int) [DS:12] = 3; POP(DS);
#endif

	ESP -= 8;
	PUSH(8 /* intãƒãƒ³ãƒ‰ãƒ©æƒ…å ±è¦æ±‚ */);
	PUSH(4);
	EBX = ESP;
	CALLFAR0(SEL_TIMERINT);
	EAX = [SS:ESP + 8]; /* EAXã«ã‚ªãƒ•ã‚»ãƒƒãƒˆ */
	EBX = 0x20 * 8;
	(short) [DS:EBX + 0] = AX;
	(unsigned int) EAX >>= 16;
	(short) [DS:EBX + 4] = 0x8e00;
	(short) [DS:EBX + 2] = SEL_TIMERINT;
	(short) [DS:EBX + 6] = AX;
	STI();
	/* 4, 8, ?, ?, ?, ?, ?, ?, eocãŒæ®‹ã£ã¦ã„ã‚‹ */

#ifdef DEBUG031127
PUSH(DS); PUSH(SEL_TAPIWORK); POP(DS); (int) [DS:12] = 4; POP(DS);
#endif

	PUSH(4 /* ä¸€èˆ¬æƒ…å ±è¦æ±‚ */);
	PUSH(4);
	EBX = ESP;
	CALLFAR0(SEL_TIMERINT);
	EAX = [SS:ESP + 36]; /* å‰²ã‚Šè¾¼ã¿å‘¨æ³¢æ•°[Hz] */
	ECX = [SS:ESP + 28]; /* å‰²ã‚Šè¾¼ã¿å‘¨æœŸ[2^-32sec] */
	ESP += 44 - 4; /* eocãŒæ®‹ã£ã¦ã„ã‚‹ */
	work->timer_freq = EAX;
	work->timer_sec4 = ECX;

#ifdef DEBUG031127
PUSH(DS); PUSH(SEL_TAPIWORK); POP(DS); (int) [DS:12] = 5; POP(DS);
#endif

	PUSH((int) 0x0108 /* init */);
	EBX = ESP;
	CALLFAR0(SEL_TAPI);
	POP(EAX); /* eocãŒæ®‹ã£ã¦ã„ã‚‹ */

#ifdef DEBUG031127
PUSH(DS); PUSH(SEL_TAPIWORK); POP(DS); (int) [DS:12] = 6; POP(DS);
#endif

	PUSH(SEL_SYSWORK);
	POP(DS);
	#if (defined(PCAT))
		swork_DS->mscount[0] = EDX;
	#endif

#ifdef DEBUG031127
PUSH(DS); PUSH(SEL_TAPIWORK); POP(DS); (int) [DS:12] = 7; POP(DS);
#endif

	#if (defined(PCAT))
		AL = swork_DS->FD_motor_init;
		/* 0x0c(å…¨ãƒ¢ãƒ¼ã‚¿ãƒ¼åœæ­¢ã€ãƒ‰ãƒ©ã‚¤ãƒ–0é¸æŠ)ã‹0x1c(drv0ã®ãƒ¢ãƒ¼ã‚¿ãƒ¼å›è»¢ã€ä»–ã¯åœæ­¢ã€ãƒ‰ãƒ©ã‚¤ãƒ–0é¸æŠ) */
		PUSH(EAX);
	#elif (defined(TOWNS))
		PUSH((int) 0x0300 /* å…¨ãƒ¢ãƒ¼ã‚¿ãƒ¼åœæ­¢ã€ãƒ‰ãƒ©ã‚¤ãƒ–é¸æŠãªã— */);
	#elif (defined(NEC98))
		PUSH(0); /* å…¨ãƒ¢ãƒ¼ã‚¿ãƒ¼åœæ­¢ */
	#endif
	PUSH((int) 0x0100 /* åˆæœŸåŒ– */);
	EBX = ESP;
	CALLFAR0(SEL_FDCDRIVE);
	POP(EAX);
	POP(EAX); /* eocãŒæ®‹ã£ã¦ã„ã‚‹ */

	POP(EAX); /* eocãŒæ®‹ã£ã¦ãªã„ */

#ifdef DEBUG031127
PUSH(DS); PUSH(SEL_TAPIWORK); POP(DS); (int) [DS:12] = 8; POP(DS);
#endif

	/* PIT2ã®åˆæœŸåŒ–ã€æ¶ˆéŸ³ */
	CLI();
	#if (defined(PCAT))
		IN(AL, 0x0061);
		AL &= 0x0d;
		AL |= 0x01;
		OUT(0x0061, AL);
		AL = 0xb6;
		OUT(0x0043, AL);
		EAX = 0;
		OUT(0x0042, AL);
		NOP();
		OUT(0x0042, AL);
	#elif (defined(TOWNS))
		IN(AL, 0x0060);
		AL >>= 2;
		AL &= 0x03;
		OUT(0x0060, AL);
		AL = 0xb6;
		OUT(0x0046, AL);
		EAX = 0;
		OUT(0x0044, AL);
		NOP();
		OUT(0x0044, AL);
	#elif (defined(NEC98))
		AL = 0x07;
		OUT(0x0037, AL);
		AL = 0xb6;
		OUT(0x0077, AL);
		EDX = 0x3fdb;
		EAX = 0;
		OUT(DX, AL);
		NOP();
		OUT(DX, AL);
	#endif
	STI();

#ifdef DEBUG031127
PUSH(DS); PUSH(SEL_TAPIWORK); POP(DS); (int) [DS:12] = 9; POP(DS);
#endif

	/* rootä½œæˆ */
	/*	+0000 : header
		+0200 : tag-buf. area-struct
		+0400 : root-tags
		+0600 : directorys(for root)
		+0800 : task-tags
		+0a00 : directorys(for task)

		+0c00 : init-tags(task directory)
		+0e00 : directorys(for init)
	*/
	ECX = 512 * 512; /* 256KB */
	alloc_memory();
	if (ZF == 1)
		INT(0x03);
	work->root_size = ECX;
	work->root_addr = EDX;
	work->root_Paddr = EAX;
	PUSH(SEL_IDTGDT);
	EBX = 384 /* IDTã®åˆ† */ + SEL_ROOT;
	POP(GS);
	EAX = 0x4092; /* lv0, Read/Write, use32 */
	set_modulesegment();
	PUSH(SEL_ROOT);
	ESI = 512;
	POP(DS);
	EDX = 0;
	EAX = 0;
	EDX--;
	ECX = 512 - 40;
	area_man_struct *root_areastr == DS:ESI;
	root_areastr->use = EAX;
	root_areastr->size0 = ECX;
	root_areastr->data0.size = EAX;
	root_areastr->data0.addr = EAX;
	root_areastr->data[0].size = EDX;
	root_areastr->data[0].addr = EDX;
	EAX = 1024;
//	ECX = 1024 * 31;
	ECX = 1024 * 255;
	free_area();

#ifdef DEBUG031127
PUSH(DS); PUSH(SEL_TAPIWORK); POP(DS); (int) [DS:12] = 10; POP(DS);
#endif

	ECX = 512; /* tagç”¨ã®é ˜åŸŸ */
	ESI = 512; /* allocator */
	alloc_tagdir();
	PUSH(CS);
	asmout("MOV EBX,OFFSET #rootdir");
	POP(GS);
	add_tags(); /* GS:EBXã‚’DS:EDIã¸ã€‚EDIã¯ä¿å­˜ã•ã‚Œã‚‹ã€‚EAX, ECX, EDXã¯ç ´å£Š */
	/* "link to directory"ã‚¿ã‚°ã‚’è¦‹ã¤ã‘ã‚‹ã¨ã€è‡ªå‹•çš„ã«ã‚¢ãƒ­ã‚±ãƒ¼ãƒˆã™ã‚‹ */
	/* ã“ã“ã§ã¯ã€EDI = 1024ã¨åˆ†ã‹ã£ã¦ã„ã‚‹ã®ã§ã€EDIã‚’ä¿å­˜ã—ãªã„ */

	ECX = 512; /* tagç”¨ã®é ˜åŸŸ */
//	ESI = 512; /* allocator */
	alloc_tagdir(); /* EDI = 2048 */
	asmout("MOV EBX,OFFSET #tasksdir");
	add_tags(); /* GS:EBXã‚’DS:EDIã¸ã€‚EDIã¯ä¿å­˜ã•ã‚Œã‚‹ã€‚EAX, ECX, EDXã¯ç ´å£Š */
	/* "link to directory"ã‚¿ã‚°ã‚’è¦‹ã¤ã‘ã‚‹ã¨ã€è‡ªå‹•çš„ã«ã‚¢ãƒ­ã‚±ãƒ¼ãƒˆã™ã‚‹ */
	EBX = 1024;
	regist_module(); /* EBXã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«EDIã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«(ã‚¿ã‚°ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª)ã‚’æ¥ç¶šã™ã‚‹ */

	ECX = 512; /* tagç”¨ã®é ˜åŸŸ */
//	ESI = 512; /* allocator */
	alloc_tagdir(); /* EDI = 3072 */
	asmout("MOV EBX,.gapidata_mdl");
	add_tags(); /* GS:EBXã‚’DS:EDIã¸ã€‚EDIã¯ä¿å­˜ã•ã‚Œã‚‹ã€‚EAX, ECX, EDXã¯ç ´å£Š */
	EAX = swork_ES->alloclist[ENT_GAPIDATA + 12];
	[DS:EDI + 72] = EAX;
	EBX = 1024;
	regist_module(); /* EBXã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«EDIã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«(ã‚¿ã‚°ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª)ã‚’æ¥ç¶šã™ã‚‹ */

#ifdef DEBUG031127
PUSH(DS); PUSH(SEL_TAPIWORK); POP(DS); (int) [DS:12] = 11; POP(DS);
#endif

	/* GAPIã®ãƒ•ã‚©ãƒ³ãƒˆé ˜åŸŸç®¡ç†(æš«å®š) */
	area_man_struct *gapifontarea == DS:ESI;
	(offset) gapifontarea = 0x0e00;
	PUSH(SEL_GAPIWORK);
	EDX = 0;
	POP(DS);
	EAX = 0;
	EDX--;
	ECX = 512 - 40;
	gapifontarea->use = EAX;
	gapifontarea->size0 = ECX;
	gapifontarea->data0.size = EAX;
	gapifontarea->data0.addr = EAX;
	gapifontarea->data[0].size = EDX;
	gapifontarea->data[0].addr = EDX;
	EAX = 616 * 1024; /* æœ€åˆã®4KBã¯ãƒ¯ãƒ¼ã‚¯ã€‚æ¬¡ã®4KBã¯ANKã€‚æ¬¡ POP(DS);
#endif

	/* ‚±‚Ìƒ^ƒXƒN‚ÌLlv‚ğ’è‹`‚µATskPointer‚ğİ’è‚µATR‚Ö‘ã“ü‚·‚éB */

	TAPI_TSS *tss == DS:ESI;
	TAPI_LlvPrm *tss_Llv0 == DS:ESI + 256, *tss_Llv1 == DS:ESI + 256 + 32, *tss_Llv2 == DS:ESI + 256 + 64;
	TAPI_GlvPrm *glevel == DS:0x0100;

	PUSH((int) SEL_TAPIWORK);
	(offset) tss = EBP;
//	EDX = 0;
	POP(DS);

	LEA(EAX, (int) *tss_Llv1); // Llv1
	tss->Glv = /* (offset) glevel[4 * 64] */ 0x0200; // Glv‚Í0x100`0x800
	tss->Llv = EAX;
	tss->Ilv = EDX /* 0 */;
	tss->flags = DL /* 0 */;
	(char) tss->short_run[11] = 0xff;

	tss_Llv1->Glv = /* (offset) glevel[4 * 64] */ 0x0200;
	(char) tss_Llv1->short_run[11] = 0xff;
	tss_Llv1->Ilv = EDX /* 0 */;

	/* ƒ[ƒJƒ‹ƒŒƒxƒ‹‚ğ­‚µ‰º‚°‚ÄA‚Ü‚½ã‚ª‚é */
	/* –¢’m(TAPI‚©‚à???)‚ÌƒoƒO‰ñ”ğ(2001.08.01) */
	tss_Llv2->Glv = /* (offset) glevel[12 * 64] */ 0x0400;
	(char) tss_Llv2->short_run[11] = 0xff;
	tss_Llv2->Ilv = 11932; // 10msec.

	(int) [DS:EDX + 0x000c /* TskPointer */] = (offset) tss;
	(int) [DS:EDX + 0x001c /* GlvNow */] = /* (offset) glevel[4 * 64] */ 0x0200;

	LTR((short) tss->tr[0]);
	LLDT((short) tss->tss386.LDTR);
	tss->back = (offset) tss;
	tss->next = (offset) tss;

	TAPI_GlvPrm *glv == DS:EAX;

	LEA((offset) glv, (int) glevel[4 * 64]);
	glv->pointer = (offset) tss;
	glv->tasks = 1;
//	glv->MinIlv = 0;
//	glv->MaxIlv = 0xffffffff;
	glv->flags = 0x02; /* •ªŠ„—}§ƒ‚[ƒh */

	LEA((offset) glv, (int) glevel[12 * 64]);
//	glv->pointer = 0;
	glv->tasks = EDX /* 0 */;
	glv->MinIlv = EDX /* 0 */;
	glv->MaxIlv = 0xffffffff;
	glv->flags = DL /* = 0x00 */; /* •ªŠ„ƒ‚[ƒh */

//	glevel[26 * 64].pointer = 0; /* idle task */
//	glevel[26 * 64].tasks = 0;
//	glevel[26 * 64].MinIlv = 0;
//	glevel[26 * 64].MaxIlv = 0xffffffff;
	glevel[26 * 64].flags = 0x02; /* •ªŠ„—}§ƒ‚[ƒh */

//	glevel[27 * 64].pointer = 0; /* sleep level */
//	glevel[27 * 64].tasks = 0;
//	glevel[27 * 64].MinIlv = 0;
//	glevel[27 * 64].MaxIlv = 0xffffffff;
	glevel[27 * 64].flags = 0x02; /* •ªŠ„—}§ƒ‚[ƒh */

	/* ©•ª©g‚Ìsoftintİ’è */
	(offset) tss = [DS:EDX + 0x000c /* TskPointer */];
//	LEA(EAX, [(offset) tss + 0x0120 /* Llv1 */]);
//	tss->softint_Llv = EAX;
	tss->softint_Llv = 0x01;
//	tss->softint_mode = 0;

//	GUIGUI_task_struct *tasklist == SS:EBP;

	/* ƒAƒCƒhƒ‹ƒ^ƒXƒN¶¬ */
//	EAX = 0;
//	EDX = 0;
//	EAX--;
	LEA(EAX, [EDX - 1]);
	PUSH((int) EDX);
	PUSH((int) EDX /* stack3‚Ì•¨—ƒAƒhƒŒƒX(Šm•Û‚µ‚Ä‚¢‚È‚¯‚ê‚Î0xffffffff) */);
	PUSH((int) EDX /* stack3‚ÌƒTƒCƒY */);
	PUSH((int) EAX);
	PUSH((int) EAX /* stack0‚Ì•¨—ƒAƒhƒŒƒX(Šm•Û‚µ‚Ä‚¢‚È‚¯‚ê‚Î0xffffffff) */);
	PUSH((int) EAX /* stack0‚ÌƒTƒCƒY(©“®İ’è‚È‚ç0xffffffff) */);
	PUSH((int) EAX);
	PUSH((int) EAX /* ƒ^ƒXƒNƒfƒBƒŒƒNƒgƒŠ */);
	ESP -= 8;
	PUSH(EDX);
	PUSH(EDX);
	PUSH(EDX);
	PUSH((int) swork_GS->modulelist[ENT_INIT + 12]);
	PUSH((int) swork_GS->modulelist[ENT_INIT +  8]);
	EBX = ESP;
	create_task();
	ESP += 60;
//	EAX = SEL_TAPIWORK;
	(offset) tss = EBP;
//	DS = AX;
	asmout("MOV DWORD PTR DS:[ESI+32],OFFSET IdleTask");
	EAX = tss->tss386.stack0_ESP;
	ECX = (int) tss->tss386.stack0_SS;
	tss->tss386.ESP = EAX;
	(int) tss->tss386.SS = ECX;
//	EDX = 0;
	tss->tss386.CS = CS;
	(int) tss->tss386.ES = EDX;
	(int) tss->tss386.DS = EDX;
	(int) tss->tss386.FS = EDX;
	(int) tss->tss386.GS = EDX;
	tss_Llv1->Glv = /* (offset) glevel[26 * 64] */ 0x0780;
	(char) tss_Llv1->short_run[11] = 0xff;
//	tss_Llv1->Ilv = 11932; // 10msec.
//	tss_Llv2->Glv = /* (offset) glevel[26 * 64] */ 0x0780;
//	(char) tss_Llv2->short_run[11] = 0xff;
//	tss_Llv2->Ilv = 11932; // 10msec.
//	LEA(EDI, [tss_Llv1]);
//	EDI = 1;
	PUSH((int) EDX /* 0 */);
	PUSH((int) 1 /* Llv */);
	PUSH((offset) tss);
	PUSH((int) 0x0104 /* TAPI_RegisterTask_ChangeLlv */);
	EBX = ESP;
	CALLFAR0(SEL_TAPI);
	ESP += 16 - 4;

//!!!!

	/* winman0 */
//	EDX = 0;
	PUSH((int) SEL_ALL);
//	EAX--;
//	EAX = 0;
	LEA(EAX, [EDX - 1]);
	POP(DS);
	EBX = swork_GS->modulelist[ENT_WINMAN0 + 12];
	PUSH(EAX);
	PUSH(EAX /* (int) 0xffffffff */ /* stack3‚Ì•¨—ƒAƒhƒŒƒX(Šm•Û‚µ‚Ä‚¢‚È‚¯‚ê‚Î0xffffffff) */);
	PUSH(EAX /* (int) 0xffffffff */ /* stack3‚ÌƒTƒCƒY(©“®İ’è‚È‚ç0xffffffff) */);
	PUSH(EAX);
	PUSH(EAX /* (int) 0xffffffff */ /* stack0‚Ì•¨—ƒAƒhƒŒƒX(Šm•Û‚µ‚Ä‚¢‚È‚¯‚ê‚Î0xffffffff) */);
	PUSH(EAX /* (int) 0xffffffff */ /* stack0‚ÌƒTƒCƒY(©“®İ’è‚È‚ç0xffffffff) */);
	PUSH(EAX);
	PUSH(EAX /* (int) 0xffffffff */ /* ƒ^ƒXƒNƒfƒBƒŒƒNƒgƒŠ */);
	ESP -= 8;
	ESI = EBX;
	EBX -= swork_GS->bmodule_paddr;
	EBX += swork_GS->bmodule_laddr;
	PUSH((int) [DS:EBX + 20]);
	PUSH((int) [DS:EBX + 16]);
	PUSH((int) 0);
	PUSH((int) ESI);
	PUSH((int) swork_GS->modulelist[ENT_WINMAN0 +  8]);
	EBX = ESP;
	create_task(); /* 0x3000 */
	ESP += 60;
	PUSH(SEL_TAPIWORK);
	(offset) tss = EBP /* tasklist->tskptr */;
	POP(DS);
	tss_Llv1->Glv = /* (offset) glevel[4 * 64] */ 0x0200;
	(char) tss_Llv1->short_run[11] = 0xff;
	tss_Llv1->Ilv = /* 0 */ EDX;
	tss_Llv2->Glv = /* (offset) glevel[4 * 64] */ 0x0200;
	(char) tss_Llv2->short_run[11] = 0xff;
	tss_Llv2->Ilv = /* 0 */ EDX;
//	PUSH((int) /* 0 */ EDX);
	PUSH((int) 1 /* Llv */);
	PUSH((offset) tss);
	PUSH((int) 0x0104 /* TAPI_RegisterTask_ChangeLlv */);
	EBX = ESP;
	CALLFAR0(SEL_TAPI);
	ESP += 16 - 4;

	/* pokon0 */
	PUSH((int) SEL_ALL);
//	EDX = 0;
//	EAX = 0;
//	EAX--;
	LEA(EAX, [EDX - 1]);
	POP(DS);
	PUSH(EAX);
	PUSH(EAX /* (int) 0xffffffff */ /* stack3‚Ì•¨—ƒAƒhƒŒƒX(Šm•Û‚µ‚Ä‚¢‚È‚¯‚ê‚Î0xffffffff) */);
	PUSH(EAX /* (int) 0xffffffff */ /* stack3‚ÌƒTƒCƒY(©“®İ’è‚È‚ç0xffffffff) */);
	PUSH(EAX);
	PUSH(EAX /* (int) 0xffffffff */ /* stack0‚Ì•¨—ƒAƒhƒŒƒX(Šm•Û‚µ‚Ä‚¢‚È‚¯‚ê‚Î0xffffffff) */);
	PUSH(EAX /* (int) 0xffffffff */ /* stack0‚ÌƒTƒCƒY(©“®İ’è‚È‚ç0xffffffff) */);
	PUSH(EAX);
	PUSH(EAX /* (int) 0xffffffff */ /* ƒ^ƒXƒNƒfƒBƒŒƒNƒgƒŠ */);
	ESP -= 8;
	EAX = swork_GS->modulelist[ENT_POKON0 + 12];
	ESI = EAX;
	EAX -= swork_GS->bmodule_paddr;
	EAX += swork_GS->bmodule_laddr;
	PUSH((int) [DS:EAX + 20]);
	PUSH((int) [DS:EAX + 16]);
	PUSH((int) 0);
	PUSH(ESI);
	PUSH((int) swork_GS->modulelist[ENT_POKON0 +  8]);
	EBX = ESP;
	create_task(); /* 0x4000 */
	ESP += 60;
	PUSH(SEL_TAPIWORK);
	(offset) tss = EBP;
	POP(DS);
	tss_Llv1->Glv = /* (offset) glevel[4 * 64] */ 0x0200;
	(char) tss_Llv1->short_run[11] = 0xff;
	tss_Llv1->Ilv = EDX /* 0 */;
	tss_Llv2->Glv = /* (offset) glevel[4 * 64] */ 0x0200;
	(char) tss_Llv2->short_run[11] = 0xff;
	tss_Llv2->Ilv = EDX /* 0 */;
//	PUSH((int) EDX /* 0 */);
	PUSH((int) 1 /* Llv */);
	PUSH((offset) tss);
	PUSH((int) 0x0104 /* TAPI_RegisterTask_ChangeLlv */);
	EBX = ESP;
	CALLFAR0(SEL_TAPI);
	ESP += 16 - 4;

	#if (defined(PCAT))
		/* v86ƒ^ƒXƒN¶¬ */
	//	ECX = 4096; /* 4KB */
	//	/* ESI = (offset) work->mem20_man; */ LEA(ESI, (int) work->mem20_man);
	//	AX = SS;
	//	DS = AX;
	//	get_area(); /* –{—ˆ‚ÍZF‚É‚æ‚éƒGƒ‰[ƒ`ƒFƒbƒN‚ª•K—v */
	//	/* EBP‚ğ”j‰ó‚µ‚È‚¢‚±‚Æ */
	//	if (ZF == 1 /* error */) {
	//		INT(0x03);
	//	}

#if 0
	//	PUSH((int) 0);
		PUSH(EDX); /* ƒ_ƒ~[ */
		PUSH((int) 2 /* mem20 */);
		PUSH(EDX);
		PUSH((int) EDX /* 0 */);
		PUSH((int) 0x0114);
		EBX = ESP;
		CALLFAR0(SEL_PAPI);
		EAX = [SS:ESP + 16];
		ESP += 24 - 4;
#endif

	//	EDX = 0;
		PUSH(EDX);
		PUSH((int) EDX /* stack3‚Ì•¨—ƒAƒhƒŒƒX(Šm•Û‚µ‚Ä‚¢‚È‚¯‚ê‚Î0xffffffff) */);
		PUSH((int) EDX /* stack3‚ÌƒTƒCƒY(©“®İ’è‚È‚ç0xffffffff) */);
		PUSH(EDX);
	//	PUSH(0x9e000 /* stack0‚Ì•¨—ƒAƒhƒŒƒX(Šm•Û‚µ‚Ä‚¢‚È‚¯‚ê‚Î0xffffffff) */);
	//	PUSH(4096 /* stack0‚ÌƒTƒCƒY(©“®İ’è‚È‚ç0xffffffff) */);
	PUSH((int) 0xffffffff);
	PUSH((int) 0xffffffff);
		PUSH((int) 0xffffffff);
		PUSH((int) 0xffffffff /* ƒ^ƒXƒNƒfƒBƒŒƒNƒgƒŠ */);
	//	ESP -= 8;
		PUSH(EDX);
		PUSH(EDX);
		PUSH((int) EDX);
		PUSH((int) EDX);
		PUSH((int) 0);
		PUSH((int) swork_GS->modulelist[ENT_INIT + 12]);
		PUSH((int) swork_GS->modulelist[ENT_INIT +  8]);
		EBX = ESP;
		create_task(); /* TSS_V86(0x5000) */
		ESP += 60;
		PUSH(SEL_TAPIWORK);
		(offset) tss = EBP;
		POP(DS);
	//	tss->tss386.IOBitMap = 0x0100;
		tss_Llv1->Glv = /* (offset) glevel[4 * 64] */ 0x0200;
		(char) tss_Llv1->short_run[11] = 0xff;
		tss_Llv1->Ilv = EDX /* 0 */;
		tss_Llv2->Glv = /* (offset) glevel[4 * 64] */ 0x0200;
		(char) tss_Llv2->short_run[11] = 0xff;
		tss_Llv2->Ilv = EDX /* 0 */;
	//	PUSH((int) EDX /* 0 */);
		PUSH((int) EDX /* 0 */ /* Llv */);
		PUSH((offset) tss);
		PUSH((int) 0x0104 /* TAPI_RegisterTask_ChangeLlv */);
		EBX = ESP;
		CALLFAR0(SEL_TAPI);
		ESP += 16 - 4;
		asmout("MOV EBX,v86irq");
		work->v86flag = 0;
		work->v86irq_ofs = EBX;
		work->v86irq_sel = SEL_INIT;

#if 0
		PUSH(DS);
		PUSH(SEL_IDTGDT);
		EBX = 0x100; /* INT(0x20);‚Ìƒx[ƒX */
		EAX = 0x00008e00;
		POP(DS);
		asmout("MOV DWORD [DS:EBX+0x18+0],int35+0x00100000");
		(int) [DS:EBX + 0x18 + 4] = EAX;
		asmout("MOV DWORD [DS:EBX+0x20+0],int36+0x00100000");
		(int) [DS:EBX + 0x20 + 4] = EAX;
		asmout("MOV DWORD [DS:EBX+0x28+0],int37+0x00100000");
		(int) [DS:EBX + 0x28 + 4] = EAX;
	//	asmout("MOV DWORD [DS:EBX+0x38+0],int39+0x00100000");
	//	(int) [DS:EBX + 0x38 + 4] = EAX;
		asmout("MOV DWORD [DS:EBX+0x40+0],int40+0x00100000");
		(int) [DS:EBX + 0x40 + 4] = EAX;
		asmout("MOV DWORD [DS:EBX+0x48+0],int41+0x00100000");
		(int) [DS:EBX + 0x48 + 4] = EAX;
		asmout("MOV DWORD [DS:EBX+0x50+0],int42+0x00100000");
		(int) [DS:EBX + 0x50 + 4] = EAX;
		asmout("MOV DWORD [DS:EBX+0x58+0],int43+0x00100000");
		(int) [DS:EBX + 0x58 + 4] = EAX;
	//	asmout("MOV DWORD [DS:EBX+0x60+0],int44+0x00100000");
	//	(int) [DS:EBX + 0x60 + 4] = EAX;
		asmout("MOV DWORD [DS:EBX+0x68+0],int45+0x00100000");
		(int) [DS:EBX + 0x68 + 4] = EAX;
		asmout("MOV DWORD [DS:EBX+0x70+0],int46+0x00100000");
		(int) [DS:EBX + 0x70 + 4] = EAX;
		asmout("MOV DWORD [DS:EBX+0x78+0],int47+0x00100000");
		(int) [DS:EBX + 0x78 + 4] = EAX;
		POP(DS);
		IN(AL, 0x21); /* IMR */
		AL &= 0xc7; /* IRQ:3-5‚ğ‹–‰Â */
		OUT(0x21, AL); /* master, OCW1 */
		NOP();
		IN(AL, 0xa1); /* IMR */
		AL &= 0x10; /* IRQ:8-11, 13-15‚ğ‹–‰Â */
		OUT(0xa1, AL);
#endif
	#endif

//	PUSH((int) EDX /* 0 */);
	PUSH((int) 0x0010); /* ‰æ–Ê‰Šú‰»—v¿ */
	#if (defined(VMWARE3))
		PUSH((int) 1 /* to_winman0 */); /* for VM ware */
	#else
		PUSH((int) swork_GS->to_winman0);
	#endif
	PUSH((int) 0x0018); /* fromboot */
	PUSH((int) 0x7f000003);
	PUSH((int) 0x3240 + 4);
	PUSH((int) 0x0128 /* ƒRƒ}ƒ“ƒhƒVƒOƒiƒ‹’¼Ú(with wait) */);
	EBX = ESP;
	CALLFAR0(SEL_TAPI);
	ESP += 28 - 4;

//!!!

//	PUSH((int) 0); /* eoc */
	PUSH(EAX);
	PUSH(EAX);
	PUSH((int) 0x011c /* TAPI_SingnalMessageTimerƒxƒNƒ^—v‹ */);
	EBX = ESP;
	CALLFAR0(SEL_TAPI);
	POP(EAX);
	POP(work->TAPI_sendmsgofs);
	POP(work->TAPI_sendmsgsel);
//	POP(EAX);

#if 0
	/* cacheflags, track‰Šú‰» */
	EAX = 0;
	ECX = 16 + 5; /* (64 + 20) / 4 */
	LEA(EBP, work->cacheflags[ 0]);
	do {
		[SS:EBP] = EAX;
		EBP += 4;
		ECX--;
	} while (!= 0);

	PUSH(DS);

	PUSH(SS);
	/* ESI = (offset) work->linear_man; */ LEA(ESI, (int) work->linear_man);
	POP(DS);
	ECX = 0x00200000; /* 2MB */
	get_area();
	work->diskcache_Laddr = EAX;

	#if (defined(PCAT))
		ECX = 12 * 1024; /* 12KB */
		/* ESI = (offset) work->mem24_man; */ LEA(ESI, (int) work->mem24_man);
		get_area();
		if (ZF == 1) {
			/* ESI = (offset) work->mem20_man; */ LEA(ESI, (int) work->mem20_man);
			get_area();
		}
	#endif

	#if (defined(TOWNS))
		ECX = 8 * 1024; /* 8KB */
		get_memory();
	#endif

	work->diskbuf_Paddr = EAX;
	/* ESI = (offset) work->linear_man; */ LEA(ESI, (int) work->linear_man);
	get_area();
	PUSH(SEL_PDEPTE);
	EDX = EAX;
	POP(DS);
	work->diskbuf_Laddr = EAX;
	EAX = 0x07;
	EAX |= work->diskbuf_Paddr;
	mapping();

	POP(DS);
#endif

	int *msg == GS:ESI;
	unsigned int msgdw == EDI;

	PUSH(0);
	PUSH((int) [GS:0x0230] /* DiskCacheLength */);
	PUSH(0x010c /* FDC_diskcache0 */);
	PUSH(0x0108 /* FDC_diskchange */);
	EBX = ESP;
	CALLFAR0(SEL_FDCDRIVE);
	POP(EAX);
	POP(EBX);
	POP(EAX);
	POP(EBX);

	ECX = [GS:0x0018]; /* CFport */

	PUSH((int) 0x0024); // msgboxƒŠ[ƒhƒZƒŒƒNƒ^
	(offset) msg = 0;
	msgdw = 0;
	POP(GS);

	if (ECX != 0) {
		PUSH(EBX); /* EBX == 0 */
		PUSH(ECX);
		(char) [SS:ESP + 1] &= 0x7f;
		PUSH(0x0194 /* change device */);
		PUSH(0x0108 /* FDC_diskchange */);
		EBX = ESP;
		CALLFAR0(SEL_FDCDRIVE);
		POP(EAX);
		POP(EAX);
		POP(EAX);
		#if (defined(PCAT))
			PUSH((int) 0x000c /* FDD motor off */);
			PUSH((int) 0x0124 /* FDC motorcontrol */);
			EBX = ESP;
			CALLFAR0(SEL_FDCDRIVE);
			POP(EBX);
			POP(EBX);
		#elif (defined(TOWNS))
			PUSH((int) 0x0300 /* ‘Sƒ‚[ƒ^[’â~Aƒhƒ‰ƒCƒu‘I‘ğ‚È‚µ */);
			PUSH((int) 0x0124 /* FDC motorcontrol */);
			EBX = ESP;
			CALLFAR0(SEL_FDCDRIVE);
			POP(EBX);
			POP(EBX);
		#elif (defined(NEC98))
	//		PUSH((int) 0x0301 /* ‘Sƒ‚[ƒ^[’â~Aƒhƒ‰ƒCƒu0‘I‘ğ */);
	//		PUSH((int) 0x0124 /* FDC motorcontrol */);
	//		EBX = ESP;
	//		CALLFAR0(SEL_FDCDRIVE);
	//		POP(EBX);
	//		POP(EBX);
		#endif
		TEST(CH, 0x80);
		if (!= 0) {
			PUSH(0x007f);
			PUSH(0x0198 /* PC-Card reset */);
			EBX = ESP;
			CALLFAR0(SEL_FDCDRIVE);
			POP(EAX);
			POP(EAX);
			for (;;) {
				msgdw = 0;
				do {
					EAX = msg[0];
					if (EAX == 0) {	// terminate
						break;
					} else if (EAX == 1) {	// rewind
						msgdw += msg[4];
						(offset) msg = 0;
						continue;
					} else if (EAX == 0x7f) {
						(offset) msg += 4;
						msgdw++;
						goto next_7f;
					} else {
						INT(0x03);
					}
				} while (msgdw < 8);
				PUSH(msgdw); /* signals */
				PUSH(0); /* delta-nest(Š„‚è‚İ‚ğg‚í‚È‚¢‚©‚çAnest‚Í•ÏX‚µ‚È‚¢), Llv0(sleep) */
				PUSH((int) 0x010c); /* TAPI_AddNestSleep */
				EBX = ESP;
				CALLFAR0(SEL_TAPI);
				ESP += 12;
			}
	next_7f:
			EAX = 0;
			PUSH(EAX); /* eoc */
			PUSH(msgdw); /* signals */
			PUSH(0xff00); /* delta-nest(Š„‚è‚İ‚ğg‚í‚È‚¢‚©‚çAnest‚Í•ÏX‚µ‚È‚¢), Llv nochange */
			PUSH((int) 0x010c); /* TAPI_AddNestSleep */
			EBX = ESP;
			CALLFAR0(SEL_TAPI);
			ESP += 16;
		}
		POP(EBX); /* EBX = 0 */
		EAX = 0;
	}

	#if (defined(PCAT))
		/* ƒ[ƒfƒBƒ“ƒOŠJn */
		PUSH(EBX);
		if (EAX != 0) {
			PUSH((int) 0x000c /* FDD motor off */);
			PUSH((int) 0x0124 /* FDC motorcontrol */);
			EBX = ESP;
			CALLFAR0(SEL_FDCDRIVE);
			ESP += 12;
			goto next0;
		}
		PUSH(12 /* ì‹Æ’†‚ÌƒVƒOƒiƒ‹ */);
		PUSH(16 /* Š®—¹ƒVƒOƒiƒ‹ */);
		PUSH(0x0110 /* FDC_loadFAT */);
		EBX = ESP;
		CALLFAR0(SEL_FDCDRIVE);
		ESP += 20;
	#elif (defined(TOWNS))
		/* ƒ[ƒfƒBƒ“ƒOŠJn */
	//	if (EAX != 0) {
	//		PUSH((int) 0x0300 /* ‘Sƒ‚[ƒ^[’â~Aƒhƒ‰ƒCƒu‘I‘ğ‚È‚µ */);
	//		PUSH((int) 0x0124 /* FDC motorcontrol */);
	//		EBX = ESP;
	//		CALLFAR0(SEL_FDCDRIVE);
	//		ESP += 12;
	//		goto next0;
	//	}
		if (EAX != 0)
			goto next0; /* ‚Ç‚¤‚¹ƒ‚[ƒ^‚Í’â~‚µ‚Ä‚¢‚é */
		PUSH(EBX);
		PUSH(12 /* ì‹Æ’†‚ÌƒVƒOƒiƒ‹ */);
		PUSH(16 /* Š®—¹ƒVƒOƒiƒ‹ */);
		PUSH(0x0110 /* FDC_loadFAT */);
		EBX = ESP;
		CALLFAR0(SEL_FDCDRIVE);
		ESP += 20;
	#elif (defined(NEC98))
		/* ƒ[ƒfƒBƒ“ƒOŠJn */
	//	if (EAX != 0) {
	//		PUSH((int) 0x0301 /* ‘Sƒ‚[ƒ^[’â~Aƒhƒ‰ƒCƒu0‘I‘ğ */);
	//		PUSH((int) 0x0124 /* FDC motorcontrol */);
	//		EBX = ESP;
	//		CALLFAR0(SEL_FDCDRIVE);
	//		ESP += 12;
	//		goto next0;
	//	}
		if (EAX != 0)
			goto next0; /* í‚É‰ñ‚Á‚Ä‚¢‚é‚©‚çŠÖŒW‚È‚¢‚ñ‚¾‚Á‚¯H */
		PUSH(EBX);
		PUSH(12 /* ì‹Æ’†‚ÌƒVƒOƒiƒ‹ */);
		PUSH(16 /* Š®—¹ƒVƒOƒiƒ‹ */);
		PUSH(0x0110 /* FDC_loadFAT */);
		EBX = ESP;
		CALLFAR0(SEL_FDCDRIVE);
		ESP += 20;
	#endif

	/* ƒ‹[ƒv•s•ÏğŒFFS == SS */
	/* DS, ES‚Í•s’è’l‚ğ‚Æ‚Á‚Ä‚æ‚¢ */
	for (;;) {
		msgdw = 0;
		do {
			EAX = msg[0];
			if (EAX == 0) {	// terminate
				break;
			} else if (EAX == 1) {	// rewind
				msgdw += msg[4];
				(offset) msg = 0;
				continue;
			} else if (EAX == 2) { // mouse
			//	EAX = msg[4];
			//	mousetest();
			//	INT(0x03);
				(offset) msg += 8;
				msgdw += 2; /* ˆ—‚µ‚½ƒRƒ}ƒ“ƒh” */
			} else if (EAX == 12) {
				(offset) msg += 4;
				msgdw++;
			//	dosload_nextphase();
				PUSH((int) 0);
				PUSH((int) 0x0114 /* FDC_continue */);
				EBX = ESP;
				CALLFAR0(SEL_FDCDRIVE);
				ESP += 8;
			} else if (EAX == 16) { /* FATƒ[ƒhŠ®—¹ */
				(offset) msg += 4;
				msgdw++;
				goto next0;
			} else if ((unsigned) EAX >= 0xffffff00) {
				/* ƒŠƒZƒbƒg‚âÄ‹N“®—v‹EEE–³‹ */
				(offset) msg += 4;
				msgdw++;
			} else {
				INT(0x03);
			}
		} while (msgdw < 8);

		EAX = 0;
		PUSH(EAX); /* eoc */
		PUSH(msgdw); /* signals */
		PUSH(EAX); /* delta-nest(Š„‚è‚İ‚ğg‚í‚È‚¢‚©‚çAnest‚Í•ÏX‚µ‚È‚¢), Llv0(sleep) */
		PUSH((int) 0x010c); /* TAPI_AddNestSleep */
		EBX = ESP;
		CALLFAR0(SEL_TAPI);
		ESP += 16;
	}
next0:

	PUSH((int) 0); /* eoc */
	PUSH(msgdw); /* signals */
	PUSH((int) 0xff00); /* delta-nest(Š„‚è‚İ‚ğg‚í‚È‚¢‚©‚çAnest‚Í•ÏX‚µ‚È‚¢), Llv nochange */
	PUSH((int) 0x010c); /* TAPI_AddNestSleep */

	PUSH((int) 99); /* break wait */
	PUSH((int) 0x7f000001);
	PUSH((int) 0x4240 + 2);
	PUSH((int) 0x0128 /* ƒRƒ}ƒ“ƒhƒVƒOƒiƒ‹’¼Ú(with wait) */);
	EBX = ESP;
	CALLFAR0(SEL_TAPI);
	ESP += 32;

	PUSH((offset) msg);

//	for (;;); /* ‚±‚±‚¾‚Æ€‚È‚È‚¢ */
	EAX = 0;
	PUSH(EAX); /* eoc */
	PUSH(EAX); /* signals */
	PUSH(EAX); /* delta-nest(Š„‚è‚İ‚ğg‚í‚È‚¢‚©‚çAnest‚Í•ÏX‚µ‚È‚¢), Llv0(sleep) */
	PUSH((int) 0x010c); /* TAPI_AddNestSleep ‚Æ‚è‚ ‚¦‚¸ƒXƒŠ[ƒv */

/* ‚±‚±‚Åpokon‚Éƒƒ‚ƒŠŠÖŒW‚Ì€”õ‚ªŠ®—¹‚µ‚½‚±‚Æ‚ğ’Ê’m */

	PUSH((int) 98); /* refreshed! */
	PUSH((int) 0x7f000001);
	PUSH((int) 0x4240 + 2);
	PUSH((int) 0x0128 /* ƒRƒ}ƒ“ƒhƒVƒOƒiƒ‹’¼Ú(with wait) */);

	EBX = ESP;
	CALLFAR0(SEL_TAPI);
	ESP += 16 + 16;

/* !!!‚±‚±‚Ü‚Å‚Í¬Œ÷ NEC98 */

	POP((offset) msg);
//	for (;;); /* ‚±‚±‚¾‚Æ€‚Ê */
/* ‰¼à1:ƒ[ƒe[ƒVƒ‡ƒ“‚µ‚È‚¢‚Æ€‚Ê */
/* ‰¼à2:ƒfƒBƒXƒNƒLƒƒƒbƒVƒ…§ŒäŠÖŒW */

	/* ƒEƒBƒ“ƒhƒEƒI[ƒvƒ“ƒVƒOƒiƒ‹‚ª—ˆ‚é‚ÆA‚±‚±‚É—ˆ‚é */

//	int *msg == GS:ESI;
//	unsigned int msgdw == EDI;

	PUSH((int) 0x0024); // msgboxƒŠ[ƒhƒZƒŒƒNƒ^
//	(offset) msg = 0;
	POP(GS);

	/* ƒ‹[ƒv•s•ÏğŒFFS == SS‚Å‚ ‚é */
	for (;;) {
		msgdw = 0;
		do {
			EAX = msg[0];
			if (EAX == 0)	/* terminate */
				break;
			if (EAX == 12) {
				(offset) msg += 4;
				msgdw++;
				PUSH((int) 0);
				PUSH((int) 0x0114 /* FDC_continue */);
				EBX = ESP;
				CALLFAR0(SEL_FDCDRIVE);
				ESP += 8;
			} else if (EAX == 0x8000) {
				(offset) msg += 4;
				msgdw++;
		cmd8000_2:
				LEA(EBX, work->cmd0100_buf[0]);
				PUSH((int) 0);
				PUSH(SS);
				PUSH(EBX);
				PUSH(0x0118 /* ƒRƒ}ƒ“ƒhƒVƒOƒiƒ‹ŠÔÚ */);
				EBX = ESP;
				CALLFAR0(SEL_TAPI);
				ESP += 16;
			} else if (EAX == 0x8004) { /* Œã‘±‚Ìdw‚ğÅŒã‚Ìdw‚É‰ÁZ‚·‚é */
				EAX = msg[4];
				(offset) msg += 8;
				msgdw += 2;
				LEA(EBP, work->cmd0100_buf[0]);
				ECX = [SS:EBP];
				ECX &= 0x000f;
				(int) [SS:EBP + ECX * 4] += EAX;
				goto cmd8000_2;

/*
	0x0100‚Æ0x0104‚Íƒo[ƒWƒ‡ƒ“ƒAƒbƒv‚Ì“s‡‚Åíœ‚³‚ê‚½
*/

			} else if (EAX == 0x0108) {
				/* ƒ[ƒJƒ‹ƒŒƒxƒ‹İ’è */
				/* cmd, tss, Llv”Ô†(1`7 * 32), Glv(? * 64), Ilv */

				TAPI_TSS *cmd0108_tss == DS:EBX;
				TAPI_LlvPrm *cmd0108_tss_Llv == DS:EBX;

				EAX = SEL_TAPIWORK;
				PUSH(DS);
				DS = AX;
				(offset) cmd0108_tss = msg[ 4];
				EAX = msg[12]; // Glv
				(offset) cmd0108_tss_Llv = cmd0108_tss->Llv_base;
				ECX = msg[16]; // Ilv
				(offset) cmd0108_tss_Llv += msg[ 8]; // Llv
				msgdw += 5;
				(offset) msg += 20;
				cmd0108_tss_Llv->Glv = EAX;
				(char) cmd0108_tss_Llv->short_run[11] = 0xff;
				cmd0108_tss_Llv->Ilv = ECX;
				POP(DS);
			} else if (EAX == 0x010c) {
				/* ƒ^ƒXƒN‚Ì‹N“®(‹N“®‚ÌLlv‚ğw’è‚·‚é•K—v‚ ‚è) */
				/* cmd, tss, Llv”Ô†(1`7 * 32) */
#if 0
PUSH(SEL_SYSWORK);
POP(GS);
	EAX = *bootmalloc_fre2;
	ECX = *bootmalloc_adr2;
	EDX = *bootmalloc_fre3;
	EBX = *bootmalloc_adr3;
	ESI = *bootmalloc_fre1;
	EDI = *bootmalloc_adr1;
EAX = [GS:0x20];
ECX = [GS:0x24];
EDX = [GS:0x28];
EBX = [GS:0x2c];
INT(3);
#endif

				TAPI_TSS *cmd010c_tss == DS:EBX;

				PUSH(FS);
				EAX = SEL_TAPIWORK;
				PUSH(DS);
				DS = AX;
				(offset) cmd010c_tss = msg[ 4];
				EDX = msg[8]; // Llv
				msgdw += 3;
				(offset) msg += 12;
				PUSH(EDI);
				PUSH(ESI);
				EDI = EDX;
			//	EDI = cmd010c_tss->Llv_base;
				ESI = (offset) cmd010c_tss;
			//	EDI += EDX;
				(unsigned int) EDI /= 32;

				PUSH((int) 0);
				PUSH((int) 1 /* Llv */);
				PUSH((offset) tss);
				PUSH((int) 0x0104 /* TAPI_RegisterTask_ChangeLlv */);
				EBX = ESP;
				CALLFAR0(SEL_TAPI);
				ESP += 16;
				POP(ESI);
				POP(EDI);
				POP(DS);
				POP(FS);
			} else if (EAX == 0x0110) {
INT(0x03);
#if 0
				/* ƒƒ‚ƒŠ‰ğ•ú */
				/* cmd, ent(ofs) */
				PUSH(DS);
				EAX = SEL_SYSWORK;
				EBX = msg[4];
				(offset) msg += 8;
				DS = AX;
				msgdw += 2;
				EDX = 0; /* ‚±‚ê‚ç‚Í•K—v‚È‚Ì‚©H */
				ECX = [DS:EBX + 0x08];
				EAX = [DS:EBX + 0x0c];
				ECX += 0x00000fff;
				[DS:EBX + 0x08] = EDX; /* ‚±‚ê‚ç‚Í•K—v‚È‚Ì‚©H */
				ECX &= 0xfffff000;
				[DS:EBX + 0x0c] = EDX; /* ‚±‚ê‚ç‚Í•K—v‚È‚Ì‚©H */
				free_memory(); /* ƒtƒŠ[ƒƒ‚ƒŠ‚Ì“o˜^ */
				POP(DS);
#endif
			} else if (EAX == 0x0114) {
				/* diskƒLƒƒƒbƒVƒ…ƒtƒ‰ƒbƒVƒ… */
				/* cmd, opt, Š®—¹ƒVƒOƒiƒ‹(len‚ÍƒVƒOƒiƒ‹‚Ì‘æˆêdw‚©‚ç”»’f) */

				/* Š®—¹ƒVƒOƒiƒ‹‚ğó‚¯‚Á‚Æ‚Á‚½‚Æ‚«‚Ì‚½‚ß‚Ìƒoƒbƒtƒ@‚ğ—pˆÓ */
				LEA(EBP, work->cmd0100_buf[4]);
				ECX = msg[8];
				(offset) msg += 12;
				msgdw += 3;
				[SS:EBP - 4] = ECX;
				ECX &= 0x000f;
				do {
					EAX = *msg;
					(offset) msg += 4;
					[SS:EBP] = EAX;
					EBP += 4;
					msgdw++;
					ECX--;
				} while (!= 0);

			//	disable_diskcache();

				PUSH((int) 0);
				PUSH((int) 12 /* ì‹Æ’†‚ÌƒVƒOƒiƒ‹ */);
				PUSH((int) 0x8000 /* Š®—¹ƒVƒOƒiƒ‹ */);
				PUSH((int) 0x0110 /* FDC_loadFAT */);
				PUSH((int) 0x0108 /* FDC_diskchange */);
				EBX = ESP;
				CALLFAR0(SEL_FDCDRIVE);
				ESP += 20;
			} else if (EAX == 0x0118) {
				/* format(66KB) */
				/* cmd, opt, Š®—¹ƒVƒOƒiƒ‹(len‚ÍƒVƒOƒiƒ‹‚Ì‘æˆêdw‚©‚ç”»’f) */

				PUSH((int) 0);
				PUSH((int) 12 /* ì‹Æ’†‚ÌƒVƒOƒiƒ‹ */);
				PUSH((int) 0x8000 /* Š®—¹ƒVƒOƒiƒ‹ */);
				PUSH((int) 0x011c /* FDC_format */);

	cmd0118_cmd0124:

				/* Š®—¹ƒVƒOƒiƒ‹‚ğó‚¯‚Á‚Æ‚Á‚½‚Æ‚«‚Ì‚½‚ß‚Ìƒoƒbƒtƒ@‚ğ—pˆÓ */
				LEA(EBP, work->cmd0100_buf[4]);
				ECX = msg[8];
				(offset) msg += 12;
				msgdw += 3;
				[SS:EBP - 4] = ECX;
				ECX &= 0x000f;
				do {
					EAX = *msg;
					(offset) msg += 4;
					[SS:EBP] = EAX;
					EBP += 4;
					msgdw++;
					ECX--;
				} while (!= 0);

				EBX = ESP;
				CALLFAR0(SEL_FDCDRIVE);
				ESP += 16;
			} else if (EAX == 0x011c) {
				/* ƒVƒXƒeƒ€ƒCƒ[ƒW“]‘—(66KB) */
				/* cmd, opt, bsc_size, bsc_addr, exe_size, exe_addr,
					Š®—¹ƒVƒOƒiƒ‹(len‚ÍƒVƒOƒiƒ‹‚Ì‘æˆêdw‚©‚ç”»’f) */
				/* Š®—¹ƒVƒOƒiƒ‹‚ğó‚¯‚Á‚Æ‚Á‚½‚Æ‚«‚Ì‚½‚ß‚Ìƒoƒbƒtƒ@‚ğ—pˆÓ */
				PUSH((int) 0);
				PUSH((int) 12 /* ì‹Æ’†‚ÌƒVƒOƒiƒ‹ */);
				PUSH((int) 0x8000 /* Š®—¹ƒVƒOƒiƒ‹ */);
				PUSH((int) 0x00301000);
				PUSH(msg[16]);
				PUSH((int) 0x00300000);
				PUSH(msg[ 8]);
				PUSH((int) 0x0120 /* FDC_writeIPL */);
				goto cmd0128_cmd011c;
			} else if (EAX == 0x0120) {
				/* destory task */
				EAX = msg[4];
				(offset) msg += 8;
				msgdw += 2;
				ECX = SEL_TAPIWORK;
				PUSH(ES);
				PUSH(DS);
				PUSHAD();
				ES = CX;

				/* Å‰‚ÉØ‚è—£‚· */
				ESI = EAX;
				TAPI_TSS *cmd0120_tss == ES:ESI;
				int *cmd0120_tss_sysdat == ES:ESI + 748; /* 20ƒoƒCƒg */
			//	PUSH((int) cmd0120_tss->tr[0]);
				PUSH((int) 0);
				PUSH(EAX); // tss
				PUSH((int) 0x0110); /* TAPI_DestoryTask */
				EBX = ESP;
				CALLFAR0(SEL_TAPI);
				EAX = cmd0120_tss->fpu_reg_img;
				ESP += 12;
				EAX -= [ES:0x0024 /* taskFPU */];
				if (== 0)
					[ES:0x0024 /* taskFPU */] = EAX;

				/* Ÿ‚ÉƒŠƒ\[ƒX‰ğ•ú */
				EDX = 0;
				ECX = cmd0120_tss_sysdat[ 4 /* stack0_size */];
				EAX = cmd0120_tss_sysdat[ 8 /* stack0_addr(linear) */];
				PUSH((int) EDX /* 0 */ /* eoc */);
				PUSH((int) EDX /* 0 */ /* pageset */);
				PUSH((int) EAX /* linear */);
				PUSH((int) ECX /* size */);
				PUSH((int) EDX /* 0 */ /* opt */);
				PUSH((int) 0x010c /* cmd(unmapping) */);
				EBX = ESP;
				CALLFAR0(SEL_PAPI);
				ESP += 24;

				PUSH(ESI);
				PUSH(SEL_STACK);
				/* ESI = (offset) work->linear_man; */ LEA(ESI, (int) work->linear_man);
				POP(DS);
				free_area();
				POP(ESI);

				ECX = cmd0120_tss_sysdat[12 /* stack3_size */];
				if (ECX != 0) {
					EAX = cmd0120_tss_sysdat[16 /* stack3_addr(linear) */];
					PUSH((int) EDX /* 0 */ /* eoc */);
					PUSH((int) EDX /* 0 */ /* pageset */);
					PUSH((int) EAX /* linear */);
					PUSH((int) ECX /* size */);
					PUSH((int) EDX /* 0 */ /* opt */);
					PUSH((int) 0x010c /* cmd(unmapping) */);
					EBX = ESP;
					CALLFAR0(SEL_PAPI);
					ESP += 24;

					PUSH(ESI);
					PUSH(SEL_STACK);
					/* ESI = (offset) work->linear_man; */ LEA(ESI, (int) work->linear_man);
					POP(DS);
					free_area();
					POP(ESI);
				}
				EAX = work->tapiwork_Laddr;
				EAX += [SS:ESP + 28]; /* tss(EAX) */
				ESI = cmd0120_tss_sysdat[ 0 /* tskdir */];
				PUSH((int) EDX /* 0 */ /* eoc */);
				PUSH((int) EDX /* 0 */ /* pageset */);
				PUSH((int) EAX /* linear */);
				PUSH((int) 4096 /* size */);
				PUSH((int) EDX /* 0 */ /* opt */);
				PUSH((int) 0x010c /* cmd(unmapping) */);
				EBX = ESP;
				CALLFAR0(SEL_PAPI);
				ESP += 24;

				/* ƒ^ƒXƒNƒfƒBƒŒƒNƒgƒŠ“à‚Ìƒ‚ƒWƒ…[ƒ‹‚ğ‘S‚ÄŠJ•ú */

			//	PUSH(EDI);
				PUSH(ESI);
				PUSH(SEL_ROOT);
			//	ESI = cmd0120_tss_sysdat[ 0 /* tskdir */];
				POP(DS);
				ESI += 16;
				EAX = 0xffe00040; /* directory-link-to tag */
				EBX = 16;
				search_tag_EAX();
				EBX += (int) [DS:ESI + 16]; /* link */
				EDI = [DS:EBX];
				EBX += 4;
			//	if (EDI != 0xffffffff) {
					do {
						delete_binmodule(); /* ƒfƒBƒŒƒNƒgƒŠ‚ª¬‚´‚Á‚Ä‚¢‚é‚±‚Æ‚Í‘z’è‚µ‚Ä‚¢‚È‚¢ */
						EDI = [DS:EBX];
						EBX += 4;
					} while (EDI != 0xffffffff);
			//	}
				ESI = [SS:ESP + 28 + 4] /* EAX */;
			//	EDI = cmd0120_tss_sysdat[ 0 /* tskdir */];
				POP(EDI);
				delete_directory();
			//	POP(EDI);

				EAX = [SS:ESP + 28] /* EAX */;
				(unsigned int) EAX /= 4096;
				EAX--;
				BTS(work->tapiwork_man.bitmap[0], EAX);
	
				/* ÅŒã‚ÉAtss”Ô†‚ğpokon0‚É’Ê’B */
				/* pokon0‚ÍA‚»‚ê‚É‰‚¶‚Äƒƒ‚ƒŠƒoƒ“ƒN‚ğ‰ğ•ú‚µ‚Ä‚à‚¢‚¢‚µA‚µ‚È‚­‚Ä‚à‚¢‚¢B */
				EAX = [SS:ESP + 28]; // EAX
				PUSH((int) 0);
				PUSH(EAX);
				PUSH((int) 0x0080);
				PUSH((int) 0x7f000002);
				PUSH((int) 0x4240 + 3);
				PUSH((int) 0x0128 /* ƒRƒ}ƒ“ƒhƒVƒOƒiƒ‹’¼Ú(with wait) */);
				EBX = ESP;
				CALLFAR0(SEL_TAPI);
				ESP += 24;
				POPAD();
				POP(DS);
				POP(ES);
			} else if (EAX == 0x0124) {
				/* format(72KB 512Byets/Sector) */
				/* cmd, opt, Š®—¹ƒVƒOƒiƒ‹(len‚ÍƒVƒOƒiƒ‹‚Ì‘æˆêdw‚©‚ç”»’f) */
				PUSH((int) 0);
				PUSH((int) 12 /* ì‹Æ’†‚ÌƒVƒOƒiƒ‹ */);
				PUSH((int) 0x8000 /* Š®—¹ƒVƒOƒiƒ‹ */);
				PUSH((int) 0x0128 /* FDC_format2 */);
				goto cmd0118_cmd0124;
			} else if (EAX == 0x0128) {
				/* ƒVƒXƒeƒ€ƒCƒ[ƒW“]‘—(512bytes/sector) */
				/* cmd, opt, bsc_size, bsc_addr, exe_size, exe_addr,
					Š®—¹ƒVƒOƒiƒ‹(len‚ÍƒVƒOƒiƒ‹‚Ì‘æˆêdw‚©‚ç”»’f) */
				/* Š®—¹ƒVƒOƒiƒ‹‚ğó‚¯‚Á‚Æ‚Á‚½‚Æ‚«‚Ì‚½‚ß‚Ìƒoƒbƒtƒ@‚ğ—pˆÓ */
				PUSH((int) 0);
				PUSH((int) 12 /* ì‹Æ’†‚ÌƒVƒOƒiƒ‹ */);
				PUSH((int) 0x8000 /* Š®—¹ƒVƒOƒiƒ‹ */);
				PUSH((int) 0x00301000);
				PUSH(msg[16]);
				PUSH((int) 0x00300000);
				PUSH(msg[ 8]);
				PUSH((int) 0x012c /* FDC_writeIPL2 */);

	cmd0128_cmd011c:
				LEA(EBP, work->cmd0100_buf[4]);
				PUSH(ES);
				PUSH(DS);
				PUSH(msg[20]);
				PUSH(msg[16]);
				PUSH(msg[12]);
				PUSH(msg[ 8]);
				ECX = msg[24];
				(offset) msg += 28;
				msgdw += 7;
				[SS:EBP - 4] = ECX;
				ECX &= 0x000f;
				do {
					EAX = *msg;
					(offset) msg += 4;
					[SS:EBP] = EAX;
					EBP += 4;
					msgdw++;
					ECX--;
				} while (!= 0);

				/* ƒ}ƒbƒsƒ“ƒO */
				PUSH(SEL_SYSWORK);
				POP(ES);
				EAX = [SS:ESP + 4 /* bsc_addr */];
			//	EDX = 0x00300000; /* 3MB */
			//	EAX |= 0x07;
				EBX = 0;
				PUSH((int) EBX /* eoc */);
				PUSH((int) EBX /* addr64(high) */);
				PUSH((int) EAX /* addr64(low) */);
				PUSH((int) EBX /* offset64(high) */);
				PUSH((int) EBX /* offset64(low) */);
				PUSH((int) EBX /* pageset */);
				PUSH((int) 0x00300000 /* 3MB */ /* linear */);
				PUSH((int) 4096 /* size */);
				PUSH((int) 0x1007 /* opt(over-mapping, present, R/W, user) */);
				PUSH((int) 0x0108 /* cmd(mapping) */);
				EBX = ESP;
				CALLFAR0(SEL_PAPI);
				ESP += 40;

				ECX = [SS:ESP +  8 /* exe_size */];
				EAX = [SS:ESP + 12 /* exe_addr */];
				ECX += 0x0fff;
				EDX = 0x00301000; /* 3MB + 4KB */
			//	EAX |= 0x07;
				ECX &= 0xfffff000;

				EBX = 0;
				PUSH((int) EBX /* eoc */);
				PUSH((int) EBX /* addr64(high) */);
				PUSH((int) EAX /* addr64(low) */);
				PUSH((int) EBX /* offset64(high) */);
				PUSH((int) EBX /* offset64(low) */);
				PUSH((int) EBX /* pageset */);
				PUSH((int) EDX /* linear */);
				PUSH((int) ECX /* size */);
				PUSH((int) 0x1007 /* opt(over-mapping, present, R/W, user) */);
				PUSH((int) 0x0108 /* cmd(mapping) */);
				EBX = ESP;
				CALLFAR0(SEL_PAPI);
				ESP += 40;

				/* ƒwƒbƒ_‰ğ“Ç */
				PUSH(SEL_ALL);
			//	EDX = 0x00301000;
				POP(DS);
				EBX = (unsigned short) [DS:EDX + 0x18 /* relocation table pointer */];
				for (;;) {
					EAX = (unsigned short) [DS:EDX + EBX    ];
					ECX = (unsigned short) [DS:EDX + EBX + 2];
					EBX += 4;
					ECX *= 16;
					EAX += ECX;
					if (== 0)
						break;
					(char) [DS:EDX + EAX + 512 + 1] += 0x08;
				}
				LEA(EBX, [SS:ESP + 24]);
				CALLFAR0(SEL_FDCDRIVE);
				ESP += 16;
				POP(DS);
				POP(ES);
				ESP += 32;
			} else if (EAX == 0x012c) {
				/* ƒAƒvƒŠƒP[ƒVƒ‡ƒ“ƒ[ƒh(2)
				   cmd, ƒfƒBƒŒƒNƒgƒŠƒGƒ“ƒgƒŠ,
				     Š®—¹ƒVƒOƒiƒ‹(len‚ÍƒVƒOƒiƒ‹‚Ì‘æˆêdw‚©‚ç”»’f) */

				PUSH(DS);
				EBX = msg[4];

				/* Š®—¹ƒVƒOƒiƒ‹‚ğó‚¯‚Á‚Æ‚Á‚½‚Æ‚«‚Ì‚½‚ß‚Ìƒoƒbƒtƒ@‚ğ—pˆÓ */
				LEA(EBP, work->cmd0100_buf[4]);
				ECX = msg[8];
				(offset) msg += 12;
				msgdw += 3;
				[SS:EBP - 4] = ECX;
				ECX &= 0x000f;
				do {
					EAX = *msg;
					(offset) msg += 4;
					[SS:EBP] = EAX;
					EBP += 4;
					msgdw++;
					ECX--;
				} while (!= 0);

				/* ƒTƒCƒY‚ğ”»’è‚µ‚ÄAmalloc */
				EAX = SEL_ALL;
			//	PUSH(msgdw);
				DS = EAX;
			//	PUSH((offset) msg);
				ECX = [DS:EBX + 0x1c]; /* file size */
			//	(int) [SS:EBP - 4] = ECX;
				ECX += 0x00000fff;
				ECX &= 0xfffff000;
				(int) [SS:EBP - 8] = ECX; /* for addr == 0 */
				if (== 0)
					goto skip012c;
				get_memory();
				(int) [SS:EBP - 8] = EAX;
				if (ZF == 1 /* error */) {
					(int) [SS:EBP - 4] = 0xffffffff;
	skip012c:
					POP(DS);
					goto cmd8000_2;
				}
			//	ESI = [SS:ESP + 12]; /* ƒfƒBƒŒƒNƒgƒŠƒGƒ“ƒgƒŠ */

/* Šm•Û‚µ‚½ƒƒ‚ƒŠ‚ğ3MB‚©‚ç‚Ì1.5MB‚Éƒ}ƒbƒv‚·‚é */
//EDX = pdepte_sel;
//ECX += 0xfff;
//DS = DX;
EDX = 0x00300000; /* 3MB */
//ECX &= 0xfffff000;
//EAX |= 0x07;

				PUSH(EBX);
				EBX = 0;
				PUSH((int) EBX /* eoc */);
				PUSH((int) EBX /* addr64(high) */);
				PUSH((int) EAX /* addr64(low) */);
				PUSH((int) EBX /* offset64(high) */);
				PUSH((int) EBX /* offset64(low) */);
				PUSH((int) EBX /* pageset */);
				PUSH((int) EDX /* linear */);
				PUSH((int) ECX /* size */);
				PUSH((int) 0x1007 /* opt(over-mapping, present, R/W, user) */);
				PUSH((int) 0x0108 /* cmd(mapping) */);
				EBX = ESP;
				CALLFAR0(SEL_PAPI);
				ESP += 40;
				POP(EBX);

// !!! /* ‚±‚±‚Éƒ[ƒfƒBƒ“ƒOƒR[ƒh‚ğ‘‚­ */


				PUSH((int) 0);
				PUSH((int) 12); /* ì‹Æ’†‚ÌƒVƒOƒiƒ‹ */
				PUSH((int) 0x8004); /* Š®—¹ƒVƒOƒiƒ‹ */
				PUSH(EDX); /* ƒ[ƒhƒŠƒjƒAƒAƒhƒŒƒX */
				PUSH(SEL_ALL);
				PUSH(EBX); /* ƒfƒBƒŒƒNƒgƒŠƒGƒ“ƒgƒŠ */
				PUSH((int) 0x0118 /* FDC_dosload */);
				EBX = ESP;
				CALLFAR0(SEL_FDCDRIVE);
				ESP += 28;
			//	POP((offset) msg);
			//	POP(msgdw);
				POP(DS);
			} else if (EAX == 0x0130) {
				/* ƒAƒvƒŠƒP[ƒVƒ‡ƒ“ƒ^ƒXƒN¶¬(ƒ^ƒXƒNƒvƒƒOƒ‰ƒ€‚É‚Í“o˜^‚³‚ê‚È‚¢) */
				/* cmd, size, addr,
				     Š®—¹ƒVƒOƒiƒ‹(len‚ÍƒVƒOƒiƒ‹‚Ì‘æˆêdw‚©‚ç”»’f) */
				/* ‚È‚¨AƒVƒOƒiƒ‹‚ÌÅŒã‚ÍAŠl“¾‚µ‚½tss‚ª‰ÁZ‚³‚ê‚é */
				PUSH(DS);
				EAX = msg[8]; /* addr */
				ESP -= 68; // eoc‚Ì‚½‚ß‚É4ƒoƒCƒg—]Œv‚É‚Æ‚Á‚Ä‚¢‚é

				/* ‚±‚±‚ÅAƒwƒbƒ_‚ğ“Ç‚Ş‚½‚ß‚¾‚¯‚ÉAƒ}ƒbƒsƒ“ƒO‚µ‚Ä‚â‚é */
				/* ƒ}ƒbƒv‚·‚éêŠ‚ÍA0x002ff000(3MB-4KB)B */
				ECX = 0;
				EDX = 0x002ff000;
				PUSH((int) ECX /* eoc */);
				PUSH((int) ECX /* addr64(high) */);
				PUSH((int) EAX /* addr64(low) */);
				PUSH((int) ECX /* offset64(high) */);
				PUSH((int) ECX /* offset64(low) */);
				PUSH((int) ECX /* pageset */);
				PUSH((int) EDX /* linear */);
				PUSH((int) 4096 /* size */);
				PUSH((int) 0x1007 /* opt(over-map, present, R/W, user) */);
				PUSH((int) 0x0108 /* cmd(mapping) */);
				EBX = ESP;
				CALLFAR0(SEL_PAPI);
				ESP += 40;
				ECX = SEL_ALL;
				EAX = SEL_SYSWORK;
				DS = CX;

				if ((unsigned) (int) [DS:EDX +  8] == 0x47495547 /* 'GUIG' */) {
					if ((unsigned) (int) [DS:EDX + 12] == 0x30304955 /* 'UI00' */) {
						PUSH(ES);
						ES = AX;
						EAX = 0;
						EAX--;
						PUSH(EAX);
						PUSH(EAX /* (int) 0xffffffff */ /* stack3‚Ì•¨—ƒAƒhƒŒƒX(Šm•Û‚µ‚Ä‚¢‚È‚¯‚ê‚Î0xffffffff) */);
						PUSH(EAX /* (int) 0xffffffff */ /* stack3‚ÌƒTƒCƒY(©“®İ’è‚È‚ç0xffffffff) */);
						PUSH(EAX);
						PUSH(EAX /* (int) 0xffffffff */ /* stack0‚Ì•¨—ƒAƒhƒŒƒX(Šm•Û‚µ‚Ä‚¢‚È‚¯‚ê‚Î0xffffffff) */);
						PUSH(EAX /* (int) 0xffffffff */ /* stack0‚ÌƒTƒCƒY(©“®İ’è‚È‚ç0xffffffff) */);
						PUSH(EAX);
						PUSH(EAX /* (int) 0xffffffff */ /* ƒ^ƒXƒNƒfƒBƒŒƒNƒgƒŠ */);
						ESP -= 8;
						PUSH((int) [DS:EDX + 20]);
						PUSH((int) [DS:EDX + 16]);
						PUSH((int) 0);
						PUSH((int) msg[8]);
						PUSH((int) msg[4]);
						MOV(EAX, SS);
						EBX = ESP;
						ES = AX;
						create_task();
						LEA(ESP, [SS:ESP + 60]);
						POP(ES);
						if (ZF == 1)
							goto cmd0130_outofresource;
						EDX = EBP;
		cmd0130_not_GUIGUI00:
						ECX = msg[12];
						(offset) msg += 16;
						msgdw += 4;
						[SS:ESP] = ECX;
						LEA(EBP, [SS:ESP + 4]);
						ECX &= 0x000f;
						do {
							EAX = *msg;
							msg += 4;
							[SS:EBP] = EAX;
							EBP += 4;
							msgdw++;
							ECX--;
						} while (!= 0);
						EAX += EDX;
						[SS:EBP] = ECX; /* eoc */
						[SS:EBP - 4] = EAX;
						PUSH(0x0128 /* ƒRƒ}ƒ“ƒhƒVƒOƒiƒ‹’¼Ú(with wait) */);
						EBX = ESP;
						CALLFAR0(SEL_TAPI);
						ESP += 72; /* 64 + 4 + 4 */
						POP(DS);
						continue;
					}
				}
				EDX = 0;
				goto cmd0130_not_GUIGUI00;
		cmd0130_outofresource:
				INT(0x03);
#if 0
				/* ƒŠƒ\[ƒX‰ğ•ú */
				PUSH((offset) msg);
				EDX = pdepte_sel; EAX = 0; DS = DX; EAX--;
				if ((unsigned) (offset) tasklist != EAX) {
					EDX = tasklist->stack0_addr;
					if (EDX != EAX) {
						ECX = tasklist->stack0_size;
						unmapping();
					}
					EDX = tasklist->stack3_addr;
					if (EDX != EAX) {
						ECX = tasklist->stack3_size;
						if (ECX != 0)
							unmapping();
					}
					/* ƒ^ƒXƒNƒfƒBƒŒƒNƒgƒŠ“à‚Ìƒ‚ƒWƒ…[ƒ‹‚ğ‘S‚ÄŠJ•ú */
					PUSH(EDI);
					EAX = SEL_ROOT;
					ESI = tasklist->tskdir;
					DS = AX;
					if (ESI != 0xffffffff) {
						EAX = 0xffe00040; /* directory-link-to tag */
						EBX = 16;
						search_tag_EAX();
						EBX += (int) [DS:ESI + 16]; /* link */
						EDI = [DS:EBX];
						EBX += 4;
						if (EDI != 0xffffffff) {
							do {
								delete_binmodule(); /* ƒfƒBƒŒƒNƒgƒŠ‚ª¬‚´‚Á‚Ä‚¢‚é‚±‚Æ‚Í‘z’è‚µ‚Ä‚¢‚È‚¢ */
								EDI = [DS:EBX];
								EBX += 4;
							} while (EDI != 0xffffffff);
						}
						EDI = tasklist->tskdir;
						delete_directory();
					}
					POP(EDI);

					EAX = 0;
					EDX = SEL_STACK;
					EAX--;
					DS = DX;
					if (tasklist->tskptr != EAX) {
					//	/* ESI = (offset) work->gdt_man; */ LEA(ESI, (int) work->gdt_man);
					//	ECX = 16; /* 2 selectors */
					//	EAX = ...
						/* ESI = (offset) work->tapiwork_man; */ LEA(ESI, (int) work->tapiwork_man);
						ECX = 0x1000; /* 4KB */
						EAX = tasklist->tskptr;
						free_area();
					}
				//	(int) tasklist->name[0] = 0;
					tasklist->tskptr = 0;
				}
				POP((offset) msg);
				EDX = 0;
				goto cmd0130_not_GUIGUI00;
#endif

			} else if (EAX == 0x0134) {
				/* ƒƒ‚ƒŠ‰ğ•ú */
				/* cmd, fileid, size, addr */
				if (msg[4] != 0xffffffff) {
					ECX = msg[8];
					EAX = 0;
					ECX += 0x0fff;
					PUSH((int) EAX /* eoc */);
					ECX &= 0xfffff000;
					EDX = 0x00300000 /* 3MB */;
					PUSH((int) EAX /* addr64(high) */);
					PUSH((int) msg[12] /* addr64(low) */);
					PUSH((int) EAX /* offset64(high) */);
					PUSH((int) EAX /* offset64(low) */);
					PUSH((int) EAX /* pageset */);
					PUSH((int) EDX /* linear */);
					PUSH((int) ECX /* size */);
					PUSH((int) 0x1007 /* opt(over-mapping, present, R/W, user) */);
					PUSH((int) 0x0108 /* cmd(mapping) */);
					EBX = ESP;
					CALLFAR0(SEL_PAPI);
					ESP += 40 - 4;

				//	PUSH((int) 0);
					PUSH(EDX);
					PUSH(SEL_ALL);
					PUSH((int) msg[4]); /* fileid */
					PUSH((int) 0x0134 /* FDC_doswrite */);
					EBX = ESP;
					CALLFAR0(SEL_FDCDRIVE);
					ESP += 20;
				}
				ECX = msg[8];
				EAX = msg[12];
				(offset) msg += 16;
				ECX += 0x00000fff;
				msgdw += 4;
				ECX &= 0xfffff000;
				free_memory(); /* ƒtƒŠ[ƒƒ‚ƒŠ‚Ì“o˜^ */

			} else if (EAX == 0x0138) {
				/* ƒVƒXƒeƒ€ƒCƒ[ƒW“]‘—(512bytes/sector, LZˆ³k) */
				/* cmd, opt, bsc_size, bsc_addr, exe_size, exe_addr,
					Š®—¹ƒVƒOƒiƒ‹(len‚ÍƒVƒOƒiƒ‹‚Ì‘æˆêdw‚©‚ç”»’f) */
				/* Š®—¹ƒVƒOƒiƒ‹‚ğó‚¯‚Á‚Æ‚Á‚½‚Æ‚«‚Ì‚½‚ß‚Ìƒoƒbƒtƒ@‚ğ—pˆÓ */
				PUSH((int) 0);
				PUSH((int) 12 /* ì‹Æ’†‚ÌƒVƒOƒiƒ‹ */);
				PUSH((int) 0x8000 /* Š®—¹ƒVƒOƒiƒ‹ */);
				PUSH((int) 0x00301000);
				PUSH(msg[16]);
				PUSH((int) 0x00300000);
				PUSH(msg[ 8]);
				PUSH((int) 0x0130 /* FDC_writeIPL3 */);
				goto cmd0128_cmd011c;
			} else if (EAX == 0x013c) {
				/* check wb cahce */
				/* cmd, fileid, size, addr, Š®—¹ƒVƒOƒiƒ‹(len‚ÍƒVƒOƒiƒ‹‚Ì‘æˆêdw‚©‚ç”»’f) */

				ECX = msg[8];
				EAX = 0;
				ECX += 0x0fff;
				PUSH((int) EAX /* eoc */);
				ECX &= 0xfffff000;
				EDX = 0x00300000 /* 3MB */;
				PUSH((int) EAX /* addr64(high) */);
				PUSH((int) msg[12] /* addr64(low) */);
				PUSH((int) EAX /* offset64(high) */);
				PUSH((int) EAX /* offset64(low) */);
				PUSH((int) EAX /* pageset */);
				PUSH((int) EDX /* linear */);
				PUSH((int) ECX /* size */);
				PUSH((int) 0x1007 /* opt(over-mapping, present, R/W, user) */);
				PUSH((int) 0x0108 /* cmd(mapping) */);
				EBX = ESP;
				CALLFAR0(SEL_PAPI);
				ESP += 40 - 4;

			//	PUSH((int) 0);
				PUSH(EDX);
				PUSH(SEL_ALL);
				PUSH((int) msg[4]); /* fileid */
				PUSH((int) 0x0134 /* FDC_doswrite */);
				EBX = ESP;
				CALLFAR0(SEL_FDCDRIVE);
				ESP += 20 - 4;

				(offset) msg += 16;
				msgdw += 4;
				goto cmd0140_directsignal;

			} else if (EAX == 0x0140) {
				/* writeback cache */
				/* cmd, Š®—¹ƒVƒOƒiƒ‹(len‚ÍƒVƒOƒiƒ‹‚Ì‘æˆêdw‚©‚ç”»’f) */

				/* Š®—¹ƒVƒOƒiƒ‹‚ğó‚¯‚Á‚Æ‚Á‚½‚Æ‚«‚Ì‚½‚ß‚Ìƒoƒbƒtƒ@‚ğ—pˆÓ */
				LEA(EBP, work->cmd0100_buf[4]);
				ECX = msg[4];
				EBX = (offset) msg;
				(offset) msg += 8;
				msgdw += 2;
				[SS:EBP - 4] = ECX;
				ECX &= 0x000f;
				do {
					EAX = *msg;
					(offset) msg += 4;
					[SS:EBP] = EAX;
					EBP += 4;
					msgdw++;
					ECX--;
				} while (!= 0);

				PUSH((int) ECX);
				PUSH((int) 12); /* ì‹Æ’†‚ÌƒVƒOƒiƒ‹ */
				PUSH((int) 0x8000); /* Š®—¹ƒVƒOƒiƒ‹ */
				PUSH((int) 0x013c);

				EBX = ESP;
				CALLFAR0(SEL_FDCDRIVE);
				ESP += 16;

			} else if (EAX == 0x0144) {
				/* invalid WB cache */
				/* cmd, Š®—¹ƒVƒOƒiƒ‹(len‚ÍƒVƒOƒiƒ‹‚Ì‘æˆêdw‚©‚ç”»’f) */
				PUSH((int) 0);
				PUSH((int) 0x0138);
				EBX = ESP;
				CALLFAR0(SEL_FDCDRIVE);
				POP(EAX);

				(offset) msg += 4;
				msgdw++;
			//	PUSH((int) 0);
	cmd0140_directsignal:
				PUSH(GS);
				PUSH((offset) msg);
				PUSH(0x0118 /* ƒRƒ}ƒ“ƒhƒVƒOƒiƒ‹ŠÔÚ */);
				EBX = ESP;
				CALLFAR0(SEL_TAPI);
				ECX = msg[0];
				ESP += 16;
				ECX &= 0x0f;
				ECX++;
				msgdw += ECX;
				LEA((offset) msg, msg[ECX * 4]);

			} else if (EAX == 0x0148) {
				/* create file */
				/* cmd, ƒtƒ@ƒCƒ‹–¼3dw, Š®—¹ƒVƒOƒiƒ‹(len‚ÍƒVƒOƒiƒ‹‚Ì‘æˆêdw‚©‚ç”»’f) */

				/* Š®—¹ƒVƒOƒiƒ‹‚ğó‚¯‚Á‚Æ‚Á‚½‚Æ‚«‚Ì‚½‚ß‚Ìƒoƒbƒtƒ@‚ğ—pˆÓ */
				LEA(EBP, work->cmd0100_buf[4]);
				ECX = msg[16];
				EBX = (offset) msg;
				(offset) msg += 20;
				msgdw += 5;
				[SS:EBP - 4] = ECX;
				ECX &= 0x000f;
				do {
					EAX = *msg;
					(offset) msg += 4;
					[SS:EBP] = EAX;
					EBP += 4;
					msgdw++;
					ECX--;
				} while (!= 0);

				PUSH((int) ECX); /* file-size:0 */
				PUSH((int) ECX); /* 1980.01.01 */
				PUSH((int) ECX); /* 00:00:00 */
				PUSH((int) ECX);
				PUSH((int) ECX);
				PUSH((int) [GS:EBX + 12]);
				PUSH((int) [GS:EBX + 8]);
				PUSH((int) [GS:EBX + 4]);
				EAX = ESP;
				PUSH((int) ECX);
				PUSH((int) 12); /* ì‹Æ’†‚ÌƒVƒOƒiƒ‹ */
				PUSH((int) 0x8000); /* Š®—¹ƒVƒOƒiƒ‹ */
				PUSH(SS);
				PUSH(EAX);
				PUSH((int) 0x0180);

				EBX = ESP;
				CALLFAR0(SEL_FDCDRIVE);
				ESP += 56;
			} else if (EAX == 0x014c) {
				/* rename file */
				/* cmd, ‹Œƒtƒ@ƒCƒ‹–¼3dw, Vƒtƒ@ƒCƒ‹–¼3dw, Š®—¹ƒVƒOƒiƒ‹(len‚ÍƒVƒOƒiƒ‹‚Ì‘æˆêdw‚©‚ç”»’f) */

				/* Š®—¹ƒVƒOƒiƒ‹‚ğó‚¯‚Á‚Æ‚Á‚½‚Æ‚«‚Ì‚½‚ß‚Ìƒoƒbƒtƒ@‚ğ—pˆÓ */
				LEA(EBP, work->cmd0100_buf[4]);
				ECX = msg[28];
				EBX = (offset) msg;
				(offset) msg += 32;
				msgdw += 8;
				[SS:EBP - 4] = ECX;
				ECX &= 0x000f;
				do {
					EAX = *msg;
					(offset) msg += 4;
					[SS:EBP] = EAX;
					EBP += 4;
					msgdw++;
					ECX--;
				} while (!= 0);

				PUSH((int) [GS:EBX + 24]);
				PUSH((int) [GS:EBX + 20]);
				PUSH((int) [GS:EBX + 16]);
				PUSH((int) [GS:EBX + 12]);
				PUSH((int) [GS:EBX +  8]);
				PUSH((int) [GS:EBX +  4]);
				EAX = ESP;
				PUSH((int) ECX);
				PUSH((int) 12); /* ì‹Æ’†‚ÌƒVƒOƒiƒ‹ */
				PUSH((int) 0x8000); /* Š®—¹ƒVƒOƒiƒ‹ */
				PUSH(SS);
				PUSH(EAX);
				PUSH((int) 0x0188);

				EBX = ESP;
				CALLFAR0(SEL_FDCDRIVE);
				ESP += 48;

			} else if (EAX == 0x0150) {
				/* resize file */
				/* cmd, ƒtƒ@ƒCƒ‹–¼3dw, VƒTƒCƒY, Š®—¹ƒVƒOƒiƒ‹(len‚ÍƒVƒOƒiƒ‹‚Ì‘æˆêdw‚©‚ç”»’f) */

				/* Š®—¹ƒVƒOƒiƒ‹‚ğó‚¯‚Á‚Æ‚Á‚½‚Æ‚«‚Ì‚½‚ß‚Ìƒoƒbƒtƒ@‚ğ—pˆÓ */
				LEA(EBP, work->cmd0100_buf[4]);
				ECX = msg[20];
				EBX = (offset) msg;
				(offset) msg += 24;
				msgdw += 6;
				[SS:EBP - 4] = ECX;
				ECX &= 0x000f;
				do {
					EAX = *msg;
					(offset) msg += 4;
					[SS:EBP] = EAX;
					EBP += 4;
					msgdw++;
					ECX--;
				} while (!= 0);

				PUSH((int) [GS:EBX + 12]);
				PUSH((int) [GS:EBX +  8]);
				PUSH((int) [GS:EBX +  4]);
				EAX = ESP;
				PUSH((int) ECX);
				PUSH((int) 12); /* ì‹Æ’†‚ÌƒVƒOƒiƒ‹ */
				PUSH((int) 0x8004); /* Š®—¹ƒVƒOƒiƒ‹ */
				PUSH((int) [GS:EBX + 16]); /* new-size */
				PUSH(SS);
				PUSH(EAX);
				PUSH((int) 0x018c);

				EBX = ESP;
				CALLFAR0(SEL_FDCDRIVE);
				ESP += 40;

			} else if (EAX == 0x0154) {
				/* delete file */
				/* cmd, ƒtƒ@ƒCƒ‹–¼3dw, Š®—¹ƒVƒOƒiƒ‹(len‚ÍƒVƒOƒiƒ‹‚Ì‘æˆêdw‚©‚ç”»’f) */

				/* Š®—¹ƒVƒOƒiƒ‹‚ğó‚¯‚Á‚Æ‚Á‚½‚Æ‚«‚Ì‚½‚ß‚Ìƒoƒbƒtƒ@‚ğ—pˆÓ */
				LEA(EBP, work->cmd0100_buf[4]);
				ECX = msg[16];
				EBX = (offset) msg;
				(offset) msg += 20;
				msgdw += 5;
				[SS:EBP - 4] = ECX;
				ECX &= 0x000f;
				do {
					EAX = *msg;
					(offset) msg += 4;
					[SS:EBP] = EAX;
					EBP += 4;
					msgdw++;
					ECX--;
				} while (!= 0);

				PUSH((int) [GS:EBX + 12]);
				PUSH((int) [GS:EBX + 8]);
				PUSH((int) [GS:EBX + 4]);
				EAX = ESP;
				PUSH((int) ECX);
				PUSH((int) 12); /* ì‹Æ’†‚ÌƒVƒOƒiƒ‹ */
				PUSH((int) 0x8000); /* Š®—¹ƒVƒOƒiƒ‹ */
				PUSH(SS);
				PUSH(EAX);
				PUSH((int) 0x0184);

				EBX = ESP;
				CALLFAR0(SEL_FDCDRIVE);
				ESP += 36;

			} else if (EAX == 0x0158) {
				/* PC-card reset */
				/* cmd, opt, Š®—¹ƒVƒOƒiƒ‹(len‚ÍƒVƒOƒiƒ‹‚Ì‘æˆêdw‚©‚ç”»’f) */

				/* Š®—¹ƒVƒOƒiƒ‹‚ğó‚¯‚Á‚Æ‚Á‚½‚Æ‚«‚Ì‚½‚ß‚Ìƒoƒbƒtƒ@‚ğ—pˆÓ */
				LEA(EBP, work->cmd0100_buf[4]);
				ECX = msg[8];
				(offset) msg += 12;
				msgdw += 3;
				[SS:EBP - 4] = ECX;
				ECX &= 0x000f;
				do {
					EAX = *msg;
					(offset) msg += 4;
					[SS:EBP] = EAX;
					EBP += 4;
					msgdw++;
					ECX--;
				} while (!= 0);

				PUSH((int) ECX);
				PUSH((int) 0x8000); /* Š®—¹ƒVƒOƒiƒ‹ */
				PUSH((int) 0x0198);

				EBX = ESP;
				CALLFAR0(SEL_FDCDRIVE);
				ESP += 12;

			} else if (EAX == 0xffffff00) {
system_reset:
				INT(0x03);
			//	asmout("fcall 8*8, KeyResetCPU");
			//	for (;;)
			//		HLT();

			} else if (EAX == 0xffffff01) {
				msg += 4;
				msgdw++;
			} else if (EAX == 1) {	// rewind
				msgdw += msg[4];
				(offset) msg = 0;
			} else {
				INT(0x03);
			}
		} while ((unsigned) msgdw < 8);
		EAX = 0;
		PUSH(EAX); // eoc
		PUSH(msgdw); // signals
		PUSH(EAX); /* delta-nest(Š„‚è‚İ‚ğg‚í‚È‚¢‚©‚çAnest‚Í•ÏX‚µ‚È‚¢), Llv0(sleep) */
		PUSH((int) 0x010c); // TAPI_AddNestSleep
		EBX = ESP;
		CALLFAR0(SEL_TAPI);
		ESP += 16;
	}

	// tasklist‚Ö‚Ìƒ|ƒCƒ“ƒ^‚Æent_module‚ğ—^‚¦‚é‚ÆA‰Šú‰»‚µ‚Ä‚­‚ê‚éB
	// tss_work‚ÌŠm•Û•‰Šú‰»(tskptr == -1‚Ì‚Æ‚«‚Ì‚İ)B
	// stack‚ÌŠm•Û•‰Šú‰»(addr == -1‚Ì‚Æ‚«‚Ì‚İ)B
	// Llv‚Í‘S‚ÄƒXƒŠ[ƒv‚É‚È‚èAƒ^ƒXƒN‚ÍLlv0‚ğ‘I‘ğ‚µ‚½ó‘Ô‚É‚È‚éB
	// ‚±‚ê‚ğAddTsk‚µ‚ÄALlvƒ`ƒFƒ“ƒW‚·‚ê‚Î‹N“®‚Å‚«‚éB
	// tasklist‚Ö‚Ìƒ|ƒCƒ“ƒ^‚³‚¦‚à-1‚È‚çA‚»‚ê‚àŠm•Û‚µ‚Ä‚­‚ê‚éB
	// ‚¤[‚ñA–Ê“|Œ©‚Ì‚æ‚¢ƒ‹[ƒ`ƒ“‚¾B
	// ‚È‚¨Aent_module‚Å¦‚³‚ê‚½ƒR[ƒh‚É‚ÍASEL_ALL‚ğ—p‚¢‚ÄƒAƒNƒZƒX‚·‚éB

//EAX = swork_DS->modulelist[ENT_TIMERDAT + 12]; /* base */
//EAX += 0x0004;
//asmout("MOV DR0,EAX");
//EAX = 0;
//asmout("MOV DR6,EAX");
//asmout("MOV EAX,1000000010B+1101B*10000H"); /* GE = G0 = 1; LEN0 = 3 /* DW */; RW0 = 01 (write only) */
//asmout("MOV DR7,EAX");

	// ƒ^ƒXƒNî•ñ
	// ƒR[ƒhƒTƒCƒYAƒXƒ^ƒbƒNƒTƒCƒY(lv3)ALDTƒTƒCƒY
	// ƒGƒ“ƒgƒŠƒ|ƒCƒ“ƒg
	// “‡“ü—Í‚ÉŠÖ‚·‚éİ’è‚ÍAGUIGUI‚Æ‚ÌŠÔ‚Å‹N“®Œã‚É‚â‚éBGUIGUI00‚Å‚Í‹K’è‚³‚ê‚Ä‚¢‚È‚¢‚½‚ßB

	ALIGN(4);
rootdir:
	DD(0xffe00000); DD(12); asmout("DB 'root'");
	DD(0xffe00002); DD(16); DD(0 /* normal-directry */); DD(0);
	DD(0xffe00040); DD(16); DD(20); DD(512 /* ‚±‚±‚ğ©“®“I‚ÉŒŸo */); DD(0); DD(0);
	DD(0xfff00000); DD(0xffffffff); /* DD(0); DD(0); */
tasksdir:
	DD(0xffe00000); DD(16); asmout("DB 'tasks', 0, 0, 0");
	DD(0xffe00002); DD(16); DD(0 /* normal-directry */); DD(0);
	DD(0xffe00040); DD(16); DD(20); DD(512 /* ‚±‚±‚ğ©“®“I‚ÉŒŸo */); DD(0); DD(0);
	DD(0xfff00000); DD(0xffffffff); /* DD(0); DD(0); */
gapidata_mdl:
	DD(0xffe00000); DD(16); asmout("DB 'gapidata'");
	DD(0xffe00002); DD(16); DD(1 /* normal-module */); DD(0);
	DD(0xffe00003); DD(32); DD(0xb0000); DD(0); DD(0xb0000); DD(0); DD(0 /* addr */); DD(0);
	DD(0xfff00000); DD(0xffffffff); /* DD(0); DD(0); */


	ALIGN(2); /* 7‚Æ14‚ÍŒã‚©‚ç’è‹`‚³‚ê‚é */
	asmout("Init_idt_table:");
	asmout("DW 0x008f,int_other,2*8");
	asmout("DW 0x018f,int01,2*8");
	asmout("DW 0x028f,int02,2*8");
	asmout("DW 0x03ef,int03,2*8");
	asmout("DW 0x048f,int_other,2*8");
	asmout("DW 0x058f,int_other,2*8");
	asmout("DW 0x068f,int06,2*8");
	asmout("DW 0x088f,int08,2*8");
	asmout("DW 0x098f,int_other,2*8");
	asmout("DW 0x0a8f,int10,2*8");
	asmout("DW 0x0b8f,int_other_ec,2*8");
	asmout("DW 0x0c8f,int12,2*8");
	asmout("DW 0x0d8f,int13,2*8");
	asmout("DW 0x108f,int_other,2*8");
	asmout("DW 0x118f,int_other_ec,2*8");
	#if (defined(PCAT) || defined(NEC98))
		asmout("DW 278EH,OFFSET int39,2*8");
	#endif
	asmout("DW 0");
}

void near init_areastr()
/* EAX = 0; EDX = -1; ECX = size0;
  area_man_struct *areastrEBP == SS:EBP; */
{
	area_man_struct *areastrEBP == SS:EBP;

	areastrEBP->use = EAX;
	areastrEBP->size0 = ECX;
	areastrEBP->data0.size = EAX;
	areastrEBP->data0.addr = EAX;
	areastrEBP->data[0].size = EDX;
	areastrEBP->data[0].addr = EDX;
	return;
}

void far IdleTask()
{
	#if (!defined(NOHLT))
		for (;;) {
			HLT();
		}
	#else
		for (;;) {
			NOP();
		}
	#endif
}

#if 0

void near get_page()
/* EAX‚Éƒy[ƒWƒAƒhƒŒƒXB-1‚Ìê‡AƒGƒ‰[ */
{
	int *work == DS:?, worksize == 64;
	PUSH(ECX);
	ECX = work[0];
	EAX = work[4];
	ECX -= 4096;
	if ((unsigned) > 0) {
		work[0] = ECX;
		work[4] += 4096; /* CF = 0 */
		POP(ECX);
		return;
	}
	if (== 0) {
		PUSH(EAX);
		PUSH(EBX);
		EBX = (offset) work;
		ECX = worksize / 4 - 2;
		do {
			EAX = [DS:EBX + 8];
			ECX--;
			[DS:EBX] = EAX;
			LEA(EBX,[EBX + 4]);
		} while (!= 0);
		POP(EBX);
		POP(EAX);
		POP(ECX);
		return; /* ECX‚Í0‚É‚È‚Á‚½‚¾‚¯‚È‚Ì‚ÅACF = 0 */
	}
	EAX = -1;
	POP(ECX);
	STC();
	return;
	// ÅŒã‚ÌƒuƒƒbƒN‚ÍA0,0xffffffff
}

#endif

void near get_area()
/* DS:ESI‚ÉŠÇ—î•ñ\‘¢‘Ì‚Ö‚Ìƒ|ƒCƒ“ƒ^B
   ECX‚É—v‹˜A‘±ƒTƒCƒYB
   EAX‚Éƒy[ƒWƒAƒhƒŒƒXB-1‚Ìê‡AƒGƒ‰[B */

/* \‘¢‘Ì‚ÌÅ‰‚Ì8ƒoƒCƒg‚ÍƒŠƒU[ƒu
   Ÿ‚Ì8ƒoƒCƒg‚ÍAg—pƒoƒCƒg”‚Æ\‘¢‘ÌƒTƒCƒY
   ‚»‚ÌŸ‚Ì16ƒoƒCƒg‚ÍƒŠƒU[ƒu
   ‚Æ‚¢‚¤‚±‚Æ‚ÅAÅ‰‚Ìƒf[ƒ^[‚Í+40‚©‚ç */

/* first_fitƒAƒ‹ƒSƒŠƒYƒ€
   ƒAƒNƒZƒX‹£‡‚È‚Ç‚ÍAãˆÊƒ‹[ƒ`ƒ“‚Å‰ğŒˆ‚µ‚Ä‚¨‚­‚±‚Æ
   ZF == 1‚ÍƒGƒ‰[ (EAX == -1) */
{
	area_man_struct *work == DS:ESI;
	area_man_struct_sub *dat == DS:EBX;
	unsigned int req == ECX;
	PUSH((offset) dat);
	/* LEA((offset) dat,[(offset) work->data]); */ LEA((offset) dat, (int) [work->data]);

	if (req > dat->size) {
		do {
			unsigned int next_size == EAX;
			next_size = dat[sizeof (area_man_struct_sub)].size;
			(offset) dat += sizeof (area_man_struct_sub);
		} while (next_size < req);
	}

	EAX = dat->addr;
	if (EAX != 0xffffffff) {
		dat->addr += req;
		dat->size -= req;
		if (== 0) {
			work->use -= sizeof (area_man_struct_sub);
			/* “]‘—(sizeof (area_man_struct_sub) == 8‚ğ‰¼’è) */
			PUSH(ECX);
			PUSH(EAX);
			do {
				EAX = /* (dat + 8)->size */ dat[8].size;
				ECX = /* (dat + 8)->addr */ dat[8].addr;
				dat->size = EAX;
				dat->addr = ECX;
				(offset) dat += 8;
			} while (EAX != 0xffffffff);
			POP(EAX);
			POP(ECX);
			CMP(EAX, 0xffffffff); /* for ZF == 0 */
		}
		/* ‚±‚±‚É—ˆ‚é‚Æ‚«AZF == 0 */
	}
	POP((offset) dat);
	return;
}

void free_area()
/* DS:ESI‚ÉŠÇ—î•ñ\‘¢‘Ì‚Ö‚Ìƒ|ƒCƒ“ƒ^B */
/* ECX‚É‰ğ•úƒTƒCƒYB */
/* EAX‚Éƒy[ƒWƒAƒhƒŒƒXB */
/* ‘SƒŒƒWƒXƒ^•Û‘¶ */
/* ‚Q•ªŒŸõƒAƒ‹ƒSƒŠƒYƒ€ */
/* ƒAƒNƒZƒX‹£‡‚È‚Ç‚ÍAãˆÊƒ‹[ƒ`ƒ“‚Å‰ğŒˆ‚µ‚Ä‚¨‚­‚±‚Æ */
/* ZF == 1‚ÍƒGƒ‰[(ŠÇ——Ìˆæ•s‘«) */
{
	area_man_struct *work == DS:ESI;
	area_man_struct_sub *dat == DS:EBX;
	unsigned int dat0 == EDX, dat1 == EDI;
	unsigned int size == ECX, addr == EAX;
	PUSH(dat1);
	dat1 = work->use;
	PUSH(dat0);
	PUSH((offset) dat);
	LEA(dat0, (int) work->data0);
//	dat1 = (offset) work->data[dat1]; // ‚±‚ê‚ª‚¤‚Ü‚­ƒRƒ“ƒpƒCƒ‹‚Å‚«‚È‚¢
	LEA(dat1, [dat1 + (offset) work->data]);

	LEA((offset) dat, [dat0 + dat1]);
	(offset) dat /= 2;
	(offset) dat &= 0xfffffff8; // 8ƒoƒCƒgƒAƒ‰ƒCƒ“
	if ((unsigned) (offset) dat > dat0) {
		for (;;) {
			if (addr < dat->addr) {
				dat1 = (offset) dat;
				(offset) dat += dat0;
				(offset) dat /= 2;
				(offset) dat &= 0xfffffff8; // 8ƒoƒCƒgƒAƒ‰ƒCƒ“
				if ((unsigned) (offset) dat > dat0)
					continue;
				break;
			}
			/* == ‚Í‚ ‚è‚¦‚È‚¢ */
			dat0 = (offset) dat;
			(offset) dat += dat1;
			(offset) dat /= 2;
			(offset) dat &= 0xfffffff8; // 8ƒoƒCƒgƒAƒ‰ƒCƒ“
			if ((unsigned) (offset) dat > dat0)
				continue;
			break;
		}
	}

	/* dat->addr < addr < dat[8]->addr */

	EDI = dat->size;
	LEA(EDX, [addr + size]);
	EDI += dat->addr;
	if (!= 0) {
		/* ã‚Í”Ô•º‚Å‚Í‚È‚¢ */
		if (addr == EDI) {
			/* ã‚Æ‚Ì—Z‡‚Í‰Â”\ */
			dat->size += size;
			if (EDX == dat[8].addr) {
				/* ‰º‚Æ‚Ì—Z‡‚à‰Â”\ */
				EDX = dat[8].size;
				dat->size += EDX;
				/* “]‘—(sizeof (area_man_struct_sub) == 8‚ğ‰¼’è) */
				(offset) dat += sizeof (area_man_struct_sub);
				PUSH(ECX);
				PUSH(EAX);
				do {
					EAX = /* (dat + 8)->size */ dat[8].size;
					ECX = /* (dat + 8)->addr */ dat[8].addr;
					dat->size = EAX;
					dat->addr = ECX;
					(offset) dat += 8;
				} while (EAX != 0xffffffff);
				work->use -= sizeof (area_man_struct_sub);
				POP(EAX);
				POP(ECX);
				CMP(addr, 0xffffffff); // for ZF == 0
			}
			POP((offset) dat);
			POP(dat0);
			POP(dat1);
			return;
		}
	}

	if (EDX == dat[8].addr) {
		/* ‰º‚Æ‚Ì—Z‡‚Í‰Â”\ */
		dat[8].size += size; // ZF = 0
		dat[8].addr = addr;
		POP((offset) dat);
		POP(dat0);
		POP(dat1);
		return;
	}

	/* —Z‡•s‰Â”\E—v‘}“ü */

	(offset) dat = work->use;
	(offset) dat += sizeof (area_man_struct_sub); 
	if ((unsigned) (offset) dat < work->size0) { /* ‚±‚ê‚ª¬—§‚µ‚È‚¢ê‡AZF == 1 */
		work->use = (offset) dat;
		LEA((offset) dat, [/* (offset) dat */ EBX + (offset) work->data]);
	//	PUSH(EDX);
		PUSH(ECX);
		do {
			ECX = /* (dat - 8)->size */ dat[-8].size;
			EDX = /* (dat - 8)->addr */ dat[-8].addr;
			dat->size = ECX;
			dat->addr = EDX;
			(offset) dat -= 8;
		} while (addr < EDX); // í‚ÉZF == 0
		POP(ECX);
	//	POP(EDX);
		/* (dat + 8)->size */ dat[8].size = size;
		/* (dat + 8)->addr */ dat[8].addr = addr;
	}
	POP((offset) dat);
	POP((offset) dat0);
	POP((offset) dat1);
	return;
}

#if 0

void near count_free()
/* DS:ESI‚ÉŠÇ—î•ñ\‘¢‘Ì‚Ö‚Ìƒ|ƒCƒ“ƒ^B */
/* ECX‚É‡ŒvƒTƒCƒY‚ª•Ô‚èAEAX‚ÉÅ‘åƒTƒCƒY‚ª•Ô‚é */
{
	area_man_struct *work == DS:ESI;
	area_man_struct_sub *dat == DS:EBX;
	PUSH(EBX);
	PUSH(EDX);
	LEA((offset) dat, (int) [work->data]);
	EDX = 0;
	EAX = 0;
	EDX--;
	ECX = 0;
	if (EDX != dat->size) {
		do {
			ECX += dat->size;
			if ((unsigned) EAX <= dat->size)
				EAX = dat->size;
			(offset) dat += sizeof (area_man_struct_sub);
		} while (EDX != dat->size);
	}
	POP(EDX);
	POP(EBX);
	return;
}

#endif

void get_memory()
/* ECX‚É—v‹ƒTƒCƒY */
{
	PUSH(FS);
	PUSH(EBX);
	MOV(EBX, SS);
	PUSH((int) 0);
	PUSH(ECX); /* ƒ_ƒ~[ */
	PUSH((int) 0);
	PUSH(ECX);
	PUSH((int) 0);
	PUSH((int) 0x0114);
	FS = EBX;
	EBX = ESP;
	CALLFAR0(SEL_PAPI);
	EAX = [SS:ESP + 16];
	ESP += 24;
	POP(EBX);
	POP(FS);
	return;
}

void free_memory()
{
	PUSH(FS);
	PUSH(EBX);
	MOV(EBX, SS);
	PUSH((int) 0);
	PUSH(EAX);
	PUSH(ECX);
	PUSH((int) 0);
	PUSH((int) 0x0110);
	FS = EBX;
	EBX = ESP;
	CALLFAR0(SEL_PAPI);
	ESP += 20;
	POP(EBX);
	POP(FS);
	return;
}


void near get_virtual()
/* ECX‚É—v‹ƒTƒCƒY */
/* EDX:EAX‚É64bitƒAƒhƒŒƒX */
{
	unsigned int stack_sel    ==  6 * 8, ankfont_sel   ==  7 * 8;
	GUIGUI_work *work == DS:0xffffd000;
	PUSH(DS);
	PUSH(ESI);
	ESI = stack_sel;
	PUSH(ECX);
	DS = ESI;
	ECX += 4095;
	/* ESI = (offset) work->virtual_man; */ LEA(ESI, (int) work->virtual_man);
	(unsigned int) ECX /= 4096;
	get_area();
	EDX = EAX;
	EAX <<= 12;
	(unsigned int) EDX >>= 20;

	/* ‚±‚±‚ÅAPAPI‚ÉV‹Kƒy[ƒW‚Å‚ ‚é‚±‚Æ‚ğ’Ê’m */
	/* V‹Kƒy[ƒW‚Íƒ[ƒh‚µ‚È‚¢ */

	POP(ECX);
	POP(ESI);
	POP(DS);
	return;
}

void near free_memory64()
{
	TEST(EDX, EDX);
	asmout("JZ free_memory");
}

void near free_virtual()
/* ECX‚ÉŠJ•úƒTƒCƒY */
/* EDX:EAX‚É64bitƒAƒhƒŒƒX */
{
	unsigned int stack_sel    ==  6 * 8, ankfont_sel   ==  7 * 8;
	unsigned int papi_sel     == 18 * 8, papiwork_sel  == 19 * 8;
	GUIGUI_work *work == DS:0xffffd000;

	PUSH(FS);
	PUSH(DS);
	PUSH(ESI);
	ESI = stack_sel;
	PUSH(EBX);
	PUSH(EDX);
	PUSH(ECX);
	PUSH(EAX);
	DS = ESI;
	SHRD(EAX, EDX, 12);
	ECX += 4095;
	/* ESI = (offset) work->virtual_man; */ LEA(ESI, (int) work->virtual_man);
	(unsigned int) ECX /= 4096;
	free_area();

	ESI = 0;
	EAX = [SS:ESP];
	ECX = [SS:ESP + 4];
	EDX = [SS:ESP + 8];
	PUSH((int) ESI /* eoc */);
	PUSH(EDX /* addr64(high) */);
	PUSH(EAX /* addr64(low) */);
	PUSH(ESI /* offset(high) */);
	PUSH(ESI /* offset(low) */);
	PUSH(ESI /* size(high) */);
	PUSH(ECX /* size(low) */);
	PUSH(ESI /* opt */);
	PUSH((int) 0x0118 /* cmd(delete pages) */);
	MOV(ESI, SS);
	EBX = ESP;
	FS = ESI;
	CALLFAR0(papi_sel);
	ESP += 36;

	POP(EAX);
	POP(ECX);
	POP(EDX);
	POP(EBX);
	POP(ESI);
	POP(DS);
	POP(FS);
	return;
}

void near alloc_memory()
/* ECX‚É—v‹ƒTƒCƒY -> EAX(•¨—ƒAƒhƒŒƒX), EDX(üŒ`ƒAƒhƒŒƒX)‚ğ•Ô‚· */
{
	unsigned int stack_sel    ==  6 * 8, ankfont_sel   ==  7 * 8;
	unsigned int pdepte_sel   == 14 * 8, idtgdt_sel    == 15 * 8;
	unsigned int papi_sel     == 18 * 8;
	GUIGUI_work *work == DS:0xffffd000;
	PUSH(DS);
	PUSH(ESI);
	EAX = stack_sel;
	/* ESI = (offset) work->linear_man; */ LEA(ESI, (int) work->linear_man);
	DS = AX;
	get_area();
	EDX = EAX;
	if (ZF == 1 /* error */)
		goto fin;
	get_memory();
	if (ZF == 1 /* error */) {
		/* ESI = (offset) work->linear_man; */ LEA(ESI, (int) work->linear_man);
		EAX = EDX;
		free_area();
		goto fin;
	}
	ESI = pdepte_sel;
	DS = SI;

	PUSH(FS);
	PUSH(EBX);
	MOV(EBX, SS);
	FS = EBX;
	EBX = 0;
	PUSH((int) EBX /* eoc */);
	PUSH((int) EBX /* addr64(high) */);
	PUSH((int) EAX /* addr64(low) */);
	PUSH((int) EBX /* offset64(high) */);
	PUSH((int) EBX /* offset64(low) */);
	PUSH((int) EBX /* pageset */);
	PUSH((int) EDX /* linear */);
	PUSH((int) ECX /* size */);
	PUSH((int) 0x0007 /* opt(present, R/W, user) */);
	PUSH((int) 0x0108 /* cmd(mapping) */);
	EBX = ESP;
	CALLFAR0(papi_sel);
	ESP += 40;	// ZF = 0
	POP(EBX);
	POP(FS);

//	TEST(ESP, ESP); // ZF = 0
fin:
	POP(ESI);
	POP(DS);
	return;
}

void near alloc_tagdir()
/* ECX, ESI‚ğƒZƒbƒgBEDI(== EAX)‚É•Ô‚· */
/* ZF == 1‚ÅƒGƒ‰[ */
{
	get_area();
	if (ZF == 0) {
		EDI = EAX;
		(int) [DS:EAX + 0] = 32;
		(int) [DS:EAX + 4] = ECX; /* allocated */
		(int) [DS:EAX + 16] = 0xfff00000;
		(int) [DS:EAX + 20] = 0xffffffff;
		(int) [DS:EAX + 24] = 0;
		(int) [DS:EAX + 28] = 0;
	}
	return;
}

void near add_tags()
/* GS:EBX‚ğDS:EDI‚ÖBEDI‚Í•Û‘¶‚³‚ê‚éBEAX, ECX, EDX‚Í”j‰ó */
/* "link to"ƒ^ƒO‚ğŒ©‚Â‚¯‚é‚ÆA©“®“I‚ÉƒAƒƒP[ƒg‚·‚é */
{
	EDX = (int) [DS:EDI];
	ECX = [GS:EBX + 4];
	asmout("LEA EDX,[EDX+EDI-16]");
	ECX /= 4;
	if (CF == 0) {
		do {
			EAX = [GS:EBX];
			if (EAX == 0xffe00040) { /* "link to directory(name-sorted)" */
				ECX = [GS:EBX + 12];
				(int) [DS:EDX     ] = EAX;
				(int) [DS:EDX +  4] = 24;
				(int) [DS:EDX +  8] = 20;
				(int) [DS:EDX + 12] = ECX;
				get_area();
				if (ZF == 1)
					INT(0x03);
				(int) [DS:EDX + 16] = EAX;
				(int) [DS:EDX + 20] = 0;
				(int) [DS:EAX     ] = 20;
				(int) [DS:EAX +  4] = ECX;
				(int) [DS:EAX + 16] = 0xffffffff; /* directory terminator */
			//	(int) [DS:EAX + 20] = 0xffffffff;
				EBX += 24;
				EDX += 24;
			} else {
				do {
					EAX = [GS:EBX];
					EBX += 4;
					[DS:EDX] = EAX;
					EDX += 4;
					ECX--;
				} while (!= 0);
			}
			ECX = [GS:EBX + 4];
			ECX /= 4;
		} while (CF == 0);
	}
	LEA(EAX, [EDX + 16]);
	(int) [DS:EDX +  0] = 0xfff00000;
	(int) [DS:EDX +  4] = 0xffffffff;
	(int) [DS:EDX +  8] = 0;
	(int) [DS:EDX + 12] = 0;
	EDX -= EAX;
	(int) [DS:EDI + 0] = EDX;
	return;
}

void near search_tag_EAX()
/* ZF == 1:ŒŸo */
{
	if (EAX != (int) [DS:ESI]) {
		do {
			ESI += (int) [DS:ESI + 4];
			if (CF == 1)
				goto error;
		} while (EAX != (int) [DS:ESI]);
	}
error:
	return;
}

void near regist_module()
/* EBX‚ÌƒfƒBƒŒƒNƒgƒŠ‚ÉEDI‚Ìƒ‚ƒWƒ…[ƒ‹(ƒ^ƒOƒfƒBƒŒƒNƒgƒŠ)‚ğÚ‘±‚·‚é */
{
	PUSH(ESI);
	/* EBX‚ğ‰ğÍ‚µ‚ÄA"directory link to"‚ğ’T‚· */
	LEA(ESI, [EBX + 16]);
	PUSH(EBX);
	EAX = 0xffe00040;
	search_tag_EAX();
	if (ZF == 0)
		INT(0x03);
	EBX = [DS:ESI + 16];
	EAX = [DS:EBX];
//	asmout("MOV DWORD PTR DS:[EBX+EAX-4],EDI");
	(int) [DS:EBX + EAX - 4] = EDI;
	(int) [DS:EBX + EAX]= 0xffffffff;
//	asmout("MOV DWORD PTR DS:[EBX+EAX],-1");
	EAX += 4;
	(int) [DS:EBX] = EAX;
	(int) [DS:ESI + 8] = EAX;
	POP(EBX);
	POP(ESI);
	return;
}

void near delete_directory()
/* DS:EDI‚ÌƒfƒBƒŒƒNƒgƒŠƒ‚ƒWƒ…[ƒ‹‚ğíœ‚·‚é */
/* 0xffe00040‚ğŒŸo‚µ‚½‚çAŠJ•ú‚·‚é */
{
	PUSH(ESI);
	/* EBX‚ğ‰ğÍ‚µ‚ÄA"directory link to"‚ğ’T‚· */
	LEA(ESI, [EDI + 16]);
	EAX = 0xffe00040;
	search_tag_EAX();
	if (ZF == 1) {
		do {
			PUSH(ESI);
			EAX = [DS:ESI + 16];
			ECX = [DS:ESI + 12];
			ESI = 512;
			free_area();
			if (ZF == 1)
				goto error;
			POP(ESI);
			EAX = 0xffe00040;
			ESI += [DS:ESI + 4];
			if (CF == 1)
				break;
			search_tag_EAX();
		} while (ZF == 1);
	}
	ESI = 512;
	EAX = EDI;
	ECX = [DS:EDI + 4];
	free_area();
	POP(ESI);
	return;
error:
	INT(0x03);
}

void near delete_binmodule()
/* DS:EDI‚ÌƒoƒCƒiƒŠ[ƒ‚ƒWƒ…[ƒ‹‚ğíœ‚·‚é */
/* 0xffe00003‚ğ’T‚µ‚ÄAŠJ•ú‚·‚é */
{
	PUSH(ESI);
	/* EBX‚ğ‰ğÍ‚µ‚ÄA"standard link to"‚ğ’T‚· */
	LEA(ESI, [EDI + 16]);
	EAX = 0xffe00003;
	search_tag_EAX();
	if (ZF == 1) {
		ECX = [DS:ESI + 16];
		EAX = [DS:ESI + 24];
		EDX = [DS:ESI + 28];
		if (ECX != 0)
			free_memory64();
	}
	ESI = 512;
	EAX = EDI;
	ECX = [DS:EDI + 4];
	free_area();
	POP(ESI);
	return;
error:
	INT(0x03);
}

void near memcopy16()
{
	do {
		EAX = [DS:ESI +  0];
		ECX = [DS:ESI +  4];
		EDX = [DS:ESI +  8];
		EBX = [DS:ESI + 12];
		ESI += 16;
		[DS:EDI +  0] = EAX;
		[DS:EDI +  4] = ECX;
		[DS:EDI +  8] = EDX;
		[DS:EDI + 12] = EBX;
		EDI += 16;
		EBP -= 16;
	} while ((unsigned) > 0);
	return;
}

struct createtask_param {
	unsigned int codesize /* + 0 */, codeaddr[8] /* + 4 */;
	unsigned int header[8] /* +12 */, reserve[8] /* +20 */;
	unsigned int tskdir[8] /* +28 */; /* ‚±‚±‚ÍAroot‚ÌƒŠƒjƒAƒAƒhƒŒƒX‚ª“ü‚Á‚Ä‚¢‚é */
	unsigned int stack0size /* +36 */, stack0addr[8] /* +40 */;
	unsigned int stack3size /* +48 */, stack3addr[8] /* +52 */;
};

void create_task()
/*	ƒ^ƒXƒNƒl[ƒ€‚Íİ’è‚µ‚È‚¢
	ES:EBX ‚É ƒ‚ƒWƒ…[ƒ‹ƒpƒ‰ƒ[ƒ^[
	SS:EBP ‚É task_struct */
{
	GUIGUI_work *work == SS:0xffffd000;
//	GUIGUI_task_struct *task == SS:EBP;
	createtask_param *param == ES:EBX;
	STR_SYSWORK *swork_DS == DS:0;

	unsigned int                         all_sel       ==  1 * 8;
	unsigned int init_sel     ==  2 * 8, syswork_sel   ==  3 * 8;
	unsigned int GAPI_sel     ==  4 * 8, GAPIwork_sel  ==  5 * 8;
	unsigned int stack_sel    ==  6 * 8, ankfont_sel   ==  7 * 8;
	unsigned int keyint_sel   ==  8 * 8, keydata_sel   ==  9 * 8;
	unsigned int timerint_sel == 10 * 8, timerdata_sel == 11 * 8;
	unsigned int tapi_sel     == 12 * 8, tapiwork_sel  == 13 * 8;
	unsigned int pdepte_sel   == 14 * 8, idtgdt_sel    == 15 * 8;
	unsigned int root_sel     == 16 * 8, tmp_sel       == 17 * 8;
	unsigned int papi_sel     == 18 * 8;
	unsigned int decode_sel   == 22 * 8, decowork_sel  == 23 * 8;
	unsigned int fdcdrive_sel == 28 * 8, fdcwork_sel   == 29 * 8;
	unsigned int diskbuf_sel  == 30 * 8, textbuf_sel   == 31 * 8;
	unsigned int freegdt_sel  == 32 * 8;

	PUSH(GS);
//	PUSH(ES);
	PUSH(DS);
	PUSHAD();

	EAX = root_sel;
	ESI = 512;
	DS = AX;
	if (param->tskdir[0] == 0xffffffff) {
		ECX = 512; /* 0.5KB */
		alloc_tagdir();
		if (ZF == 1)
			goto error;
		param->tskdir[0] = EDI;
		param->tskdir[4] = 0;
		PUSH(CS);
		asmout("MOV EBX,OFFSET #taskdir");
		POP(GS);
		add_tags();
	}

	PUSH(SS);
	POP(GS);

	/* tss‚ÌŠm•Û */
	ECX = 4096; /* 4KB */
	get_memory();
	if (ZF == 1)
		goto error;
#if 0
	ESP -= 72;
	EBP = EAX;
	(int) [SS:ESP +  0] = 0xffe00000; /* module name */
	(int) [SS:ESP +  4] = 12;
	(int) [SS:ESP +  8] = 0x00737374; /* 'tss' */
	(int) [SS:ESP + 12] = 0xffe00002; /* module type */
	(int) [SS:ESP + 16] = 16;
	(int) [SS:ESP + 20] = 1; /* normal module (binary) */
	(int) [SS:ESP + 24] = 0;
	(int) [SS:ESP + 28] = 0xffe00003; /* standard link-to */
	(int) [SS:ESP + 32] = 32;
	(int) [SS:ESP + 36] = ECX;
	(int) [SS:ESP + 40] = 0;
	(int) [SS:ESP + 44] = ECX;
	(int) [SS:ESP + 48] = 0;
	(int) [SS:ESP + 52] = EAX;
	(int) [SS:ESP + 56] = 0;
	(int) [SS:ESP + 60] = 0xffffffff;
	(int) [SS:ESP + 64] = 0xffffffff;
#endif
	EBP = EAX;
	PUSH(EAX); /* +68 */
	PUSH((int) 0xffffffff); /* +64 */
	PUSH((int) 0xffffffff); /* +60 */
	PUSH((int) 0); /* +56 */
	PUSH(EAX); /* +52 */
	PUSH((int) 0); /* +48 */
	PUSH((int) ECX); /* +44 */
	PUSH((int) 0); /* +40 */
	PUSH((int) ECX); /* +36 */
	PUSH((int) 32); /* +32 */
	PUSH((int) 0xffe00003); /* +28 */
	PUSH((int) 0); /* +24 */
	PUSH((int) 1); /* +20 */
	PUSH((int) 16); /* +16 */
	PUSH((int) 0xffe00002); /* +12 */
	PUSH((int) 0x00737374); /* +8 */
	PUSH((int) 12); /* +4 */
	PUSH((int) 0xffe00000); /* +0 */

	ECX = 512;
	alloc_tagdir();
	EBX = ESP;
	add_tags();
	(offset) param = (int) [SS:ESP + 16 /* EBX */ + 72];
	ESP += 72;
	EBX = param->tskdir[0];
	regist_module();

	(offset) param = (int) [SS:ESP + 16 /* EBX */];

	if (param->stack0addr[0] == 0xffffffff) {
		ECX = 4096; /* 4KB */
		get_memory();
		if (ZF == 1)
			goto error;
#if 0
		ESP -= 72;
		(int) [SS:ESP +  0] = 0xffe00000; /* module name */
		(int) [SS:ESP +  4] = 16;
		(int) [SS:ESP +  8] = 0x63617473; /* 'stac' */
		(int) [SS:ESP + 12] = 0x0000306b; /* 'k0'   */
		(int) [SS:ESP + 16] = 0xffe00002; /* module type */
		(int) [SS:ESP + 20] = 16;
		(int) [SS:ESP + 24] = 1; /* normal module (binary) */
		(int) [SS:ESP + 28] = 0;
		(int) [SS:ESP + 32] = 0xffe00003; /* standard link-to */
		(int) [SS:ESP + 36] = 32;
		(int) [SS:ESP + 40] = ECX;
		(int) [SS:ESP + 44] = 0;
		(int) [SS:ESP + 48] = ECX;
		(int) [SS:ESP + 52] = 0;
		param->stack0size = ECX;
		(int) [SS:ESP + 56] = EAX;
		(int) [SS:ESP + 60] = 0;
		param->stack0addr[0] = EAX;
		param->stack0addr[4] = EAX;
		(int) [SS:ESP + 64] = 0xffffffff;
		(int) [SS:ESP + 68] = 0xffffffff;
#endif
		PUSH((int) 0xffffffff); /* +68 */
		PUSH((int) 0xffffffff); /* +64 */
		param->stack0addr[0] = EAX;
		param->stack0addr[4] = EAX;
		PUSH((int) 0); /* +60 */
		PUSH(EAX); /* +56 */
		param->stack0size = ECX;
		PUSH((int) 0); /* +52 */
		PUSH(ECX); /* +48 */
		PUSH((int) 0); /* +44 */
		PUSH(ECX); /* +40 */
		PUSH((int) 32); /* +36 */
		PUSH((int) 0xffe00003); /* +32 */
		PUSH((int) 0); /* +28 */
		PUSH((int) 1); /* +24 */
		PUSH((int) 16); /* +20 */
		PUSH((int) 0xffe00002); /* +16 */
		PUSH((int) 0x0000306b); /* +12 */
		PUSH((int) 0x63617473); /* +8 */
		PUSH((int) 16); /* +4 */
		PUSH((int) 0xffe00000); /* +0 */

		ECX = 512;
		alloc_tagdir();
		EBX = ESP;
		add_tags();
		(offset) param = (int) [SS:ESP + 16 /* EBX */ + 72];
		ESP += 72;
		EBX = param->tskdir[0];
		regist_module();
	}

	(offset) param = (int) [SS:ESP + 16 /* EBX */];
	if (param->stack3addr[0] == 0xffffffff) {
		ECX = param->header[0];
		if (ECX != 0) {
		//	get_memory();
		//	if (ZF == 1)
		//		goto error;
			PUSH(EDX);
			EDX = 0;
			get_virtual();
			ESI = 512;
#if 0
			ESP -= 72;
			(int) [SS:ESP +  0] = 0xffe00000; /* module name */
			(int) [SS:ESP +  4] = 16;
			(int) [SS:ESP +  8] = 0x63617473; /* 'stac' */
			(int) [SS:ESP + 12] = 0x0000336b; /* 'k3'   */
			(int) [SS:ESP + 16] = 0xffe00002; /* module type */
			(int) [SS:ESP + 20] = 16;
			(int) [SS:ESP + 24] = 1; /* normal module (binary) */
			(int) [SS:ESP + 28] = 0;
			(int) [SS:ESP + 32] = 0xffe00003; /* standard link-to */
			(int) [SS:ESP + 36] = 32;
			(int) [SS:ESP + 40] = ECX;
			(int) [SS:ESP + 44] = 0;
			(int) [SS:ESP + 48] = ECX;
			(int) [SS:ESP + 52] = 0;
			param->stack3size = ECX;
			(int) [SS:ESP + 56] = EAX;
			(int) [SS:ESP + 60] = EDX;
			param->stack3addr[0] = EAX;
			param->stack3addr[4] = EDX;
			(int) [SS:ESP + 64] = 0xffffffff;
			(int) [SS:ESP + 68] = 0xffffffff;
#endif
			PUSH((int) 0xffffffff); /* +68 */
			PUSH((int) 0xffffffff); /* +64 */
			param->stack3addr[0] = EAX;
			param->stack3addr[4] = EDX;
			PUSH(EDX); /* +60 */
			PUSH(EAX); /* +56 */
			param->stack3size = ECX;
			PUSH((int) 0); /* +52 */
			PUSH(ECX); /* +48 */
			PUSH((int) 0); /* +44 */
			PUSH(ECX); /* +40 */
			PUSH((int) 32); /* +36 */
			PUSH((int) 0xffe00003); /* +32 */
			PUSH((int) 0); /* +28 */
			PUSH((int) 1); /* +24 */
			PUSH((int) 16); /* +20 */
			PUSH((int) 0xffe00002); /* +16 */
			PUSH((int) 0x0000336b); /* +12 */
			PUSH((int) 0x63617473); /* +8 */
			PUSH((int) 16); /* +4 */
			PUSH((int) 0xffe00000); /* +0 */

			PUSH((int) root_sel);
			ECX = 512;
			POP(DS);
			alloc_tagdir();
			EBX = ESP;
			add_tags();
			(offset) param = (int) [SS:ESP + 16 /* EBX */ + 72 + 4];
			ESP += 72;
			EBX = param->tskdir[0];
			regist_module();
			POP(EDX);
		}
	}

	(offset) param = (int) [SS:ESP + 16 /* EBX */];

	/* code, stack0, stack3 */
	ECX = param->codesize;
	PUSH((int) stack_sel);
	ECX += 0x1fff;
	/* ESI = (offset) work->linear_man; */ LEA(ESI, (int) work->linear_man);
	ECX &= 0xfffff000;
	POP(DS);
	ECX += param->stack0size;
	ECX += param->stack3size;
	ECX += param->header[4];
	ECX &= 0xfffffffe;
	get_area();
	if (ZF == 1)
		goto error;
	PUSH(EAX);
	PUSH(ECX);

	PUSH(EBP);
	LEA(EBP, (int) work->tapiwork_man);
	EAX = 0;
	ESI = EBP;
	ECX = [SS:EBP /* len */];
	do {
		EBP += 4;
	} while (EAX == [SS:EBP]);
	EAX = [SS:EBP];
	EBP -= ESI;
	/* (false) */ if ((unsigned) ECX <= EBP)
		INT(0x03); /* resource error */
	BSF(EAX, EAX);
	LEA(EAX, [EAX + EBP * 8 - 32]);
	BTR(work->tapiwork_man.bitmap[0], EAX);
	EAX++;
	EAX <<= 12;
	[SS:ESP + 8 /* EBP */ + 12] = EAX;
	POP(EBP);

//	EAX -= 0x1000;
	(unsigned int) EAX >>= 8; /* 4096‚ÅŠ„‚Á‚ÄA16”{‚·‚é */
//	EAX += freegdt_sel - 0x10 /* 0x10 == 0x1000 >> 8 */;
	EAX += 240;

	PUSH(EAX);

	/* mapping */
	EDX = [SS:ESP + 4 + 4]; /* linear‚Ìæ“ª */
	ECX = param->codesize;
	EAX = param->codeaddr[0];
	ECX += 0x1fff;
	EAX &= 0xfffff000;
	ECX &= 0xfffff000;

	PUSH(FS);
	PUSH(EBX);
	MOV(EBX, SS);
	FS = EBX;
	EBX = 0;
	PUSH((int) EBX /* eoc */);
	PUSH((int) EBX /* addr64(high) */);
	PUSH((int) EAX /* addr64(low) */);
	PUSH((int) EBX /* offset64(high) */);
	PUSH((int) EBX /* offset64(low) */);
	PUSH((int) EBX /* pageset */);
	PUSH((int) EDX /* linear */);
	PUSH((int) ECX /* size */);
	PUSH((int) 0x0007 /* opt(present, R/W, user) */);
	PUSH((int) 0x0108 /* cmd(mapping) */);
	EBX = ESP;
	CALLFAR0(papi_sel);
	ESP += 40;
	POP(EBX);
//	POP(FS);

	EDX += ECX;
	EAX = param->stack0addr[0];
	ECX = param->stack0size;

//	PUSH(FS);
	PUSH(EBX);
//	MOV(EBX, SS);
//	FS = EBX;
	EBX = 0;
	PUSH((int) EBX /* eoc */);
	PUSH((int) EBX /* addr64(high) */);
	PUSH((int) EAX /* addr64(low) */);
	PUSH((int) EBX /* offset64(high) */);
	PUSH((int) EBX /* offset64(low) */);
	PUSH((int) EBX /* pageset */);
	PUSH((int) EDX /* linear */);
	PUSH((int) ECX /* size */);
	PUSH((int) 0x0007 /* opt(present, R/W, user) */);
	PUSH((int) 0x0108 /* cmd(mapping) */);
	EBX = ESP;
	CALLFAR0(papi_sel);
	ESP += 40;
	POP(EBX);
	POP(FS);

	EAX = param->header[4];
	EDX += ECX;
	if (AL == 0)
		EDX += EAX;
	ECX = param->stack3size;
	if (ECX != 0) {
		EAX = param->stack3addr[0];
		PUSH(FS);
		PUSH(EBP);
		PUSH(EBX);
		EBP = param->stack3addr[4];
		MOV(EBX, SS);
		FS = EBX;
		EBX = 0;
		PUSH((int) EBX /* eoc */);
		PUSH((int) EBP /* addr64(high) */);
		PUSH((int) EAX /* addr64(low) */);
		PUSH((int) EBX /* offset64(high) */);
		PUSH((int) EBX /* offset64(low) */);
		PUSH((int) EBX /* pageset */);
		PUSH((int) EDX /* linear */);
		PUSH((int) ECX /* size */);
		PUSH((int) 0x0007 /* opt(present, R/W, user) */);
		PUSH((int) 0x0108 /* cmd(mapping) */);

#if 0
EBX = [SS:ESP + 8 /* EBP */ + 12 + 40 + 12];
if (EBX == 0xffff)
	INT(0x03);
/* tss:3000 45f000 */
/* tss:4000 480000 */
#endif
		EBX = ESP;
		CALLFAR0(papi_sel);
		ESP += 40;
		POP(EBX);
		POP(EBP);
		POP(FS);
	}
	EDX = work->tapiwork_Laddr;
	EDX += [SS:ESP + 8 /* EBP */ + 12];
//	LEA(EAX, [SS:EBP + 0x07  /* present, R/W, user */]);
//	ECX = 4096;

	PUSH(FS);
	PUSH(EBX);
	MOV(EBX, SS);
	FS = EBX;
	EBX = 0;
	PUSH((int) EBX /* eoc */);
	PUSH((int) EBX /* addr64(high) */);
	PUSH((int) EBP /* addr64(low) */);
	PUSH((int) EBX /* offset64(high) */);
	PUSH((int) EBX /* offset64(low) */);
	PUSH((int) EBX /* pageset */);
	PUSH((int) EDX /* linear */);
	PUSH((int) 4096 /* size */);
	PUSH((int) 0x0007 /* opt(present, R/W, user) */);
	PUSH((int) 0x0108 /* cmd(mapping) */);
	EBX = ESP;
	CALLFAR0(papi_sel);
	ESP += 40;
	POP(EBX);
	POP(FS);

	POP(EAX);

	TAPI_TSS *tss == DS:ESI /* 256bytes */;
	TAPI_LlvPrm *tss_LlvPrm == DS:ESI + 256 /* 256bytes(8Llv) */;
//	TAPI_msgbox *tss_msgbox == DS:ESI + 512 /* 64bytes */;
	int *tss_msg_in == DS:ESI + 576 /* 64bytes */, *fpu_reg == DS:ESI + 640 /* 128bytes */;
	/* 256bytes‚ÌƒŠƒU[ƒu—Ìˆæ */
	int *tss_msgbuf == DS:ESI + 1024, *tss_sysbuf == DS:ESI + 1536, *ldt_img == DS:ESI + 2048, *tss_systemslot == DS:ESI + 3072;
	int *tss_sysdat == DS:ESI + 748; /* 20ƒoƒCƒg */

	ESI = [SS:ESP + 8 /* EBP */ + 8];
	PUSH((int) tapiwork_sel);
	EDX = 0;
	POP(DS);
	ECX = 0x1000 / 4;
	PUSH(ESI);
	do {
		[DS:ESI] = EDX;
		ESI += 4;
		ECX--;
	} while (!= 0);

//	(offset) tss = [SS:ESP + 8 /* EBP */ + 8];
//	ESI -= 0x1000;
	POP(ESI);

//	if (ESI == 0x3000) {
//		EAX = param[ 4 /* code_addr */];
//		ECX = param[32 /* stack0_addr */];
//		EDX = param[40 /* stack3_addr */];
//		INT(0x03);
//	}

	tss->tr[0] = EAX;
	EAX += 0x0008;
	(int) tss->tss386.LDTR = EAX;
	POP(tss_sysdat[4 /* stack0size */]); /* linear‚Ì‡ŒvƒTƒCƒY */
	POP(tss_sysdat[8 /* stack0addr(linear) */]); /* linear‚Ìæ“ª */
	tss_sysdat[12 /* stack3size */] = 0;
	tss_sysdat[16 /* stack3addr(linear) */] = 0;

//	EAX = tapiwork_sel; DS = AX;

	EAX = CR3;
	tss->tss386.CR3 = EAX;
	(int) tss->tss386.TaskFlags = 0x00800000; // IOBitMap = 128;
	tss->tss386.stack0_ESP = 0xffffffc0;
	(int) tss->tss386.stack0_SS = 0x001c;
//	tss->tss386.EIP = 0;
//	tss->tss386.EFLAGS = 0x0202; /* STI */
	tss->tss386.EFLAGS = 0x3202; /* STI, IOPL=3 */
//	tss->tss386.EAX = 0;
//	tss->tss386.ECX = 0;
//	tss->tss386.EDX = 0;
//	tss->tss386.EBX = 0;
//	tss->tss386.ESP = 0;
//	tss->tss386.EBP = 0;
//	tss->tss386.ESI = 0;
//	tss->tss386.EDI = 0;
//	EAX = 0;
	AL = 0x0f;
	(char) tss->tss386.ES = AL;
	(char) tss->tss386.CS = 0x0007;
	(char) tss->tss386.SS = AL;
	(char) tss->tss386.DS = AL;
	(char) tss->tss386.FS = AL;
	(char) tss->tss386.GS = 0x0027;
//	tss->tss386.ESP = /* 0x0c00 */ 0xffffffc0;

//	tss->set[0] = 0;
//	tss->set[4] = 0;
//	tss->set[8] = 0;
//	tss->run[0] = 0;
//	tss->run[4] = 0;
//	tss->run[8] = 0;
	tss->softint_nest = 0xff; /* Å‰‚Í‚İ‚ñ‚Èsoftint-disable‚É‚È‚Á‚Ä‚¢‚éB */
	tss->msgbox_rewind_code = 0x01; /* default(‚±‚±‚ÍAƒ^ƒO‚Å•ÏX‰Â”\‚É‚µ‚Ä‚¨‚­‚×‚«‚¾‚ë‚¤) */
	tss->softint_Llv = 0xff; /* default(‚±‚±‚àAƒ^ƒO‚Å•ÏX‰Â”\‚É‚µ‚Ä‚¨‚­‚×‚«‚¾‚ë‚¤) */
	tss->softint_oldLlv = 0xff; /* default */

	LEA(EAX, (int) *tss_LlvPrm);
	tss->Glv = /* (offset) glevel_sleep */ 0x07c0;
	tss->Llv = /* (offset) tss_lv0 */ EAX;
	tss->now_Llv = 0;
	tss->Llv_base = EAX;
//	tss->Ilv = 0;
//	tss->flags = 0;
//	LEA(EAX, (int) *tss_msgbox);
//	tss->msgbox = EAX;
	(char) tss->short_run[11] = 0xff;

	PUSH(ECX);
	ECX = 8;
	do {
		tss_LlvPrm->Glv = /* (offset) glevel_sleep */ 0x07c0;
		(char) tss_LlvPrm->short_run[11] = 0xff;
		(offset) ESI += 32;
		ECX--;
	} while (!= 0);
	POP(ECX);
	ESI -= 256;

	LEA(EAX, *tss_msgbuf);
	tss->msgbox_write_free = 512 / 4 - 2 /* EOS‚Å1Brewind—p‚Ì—\”õ‚Å1 */;
	tss->msgbox_write_ptr = EAX;
	tss->msgbox_write_ptr0 = EAX;
	EAX += 512 - 4;
	tss->msgbox_write_ptr1 = EAX;
//	tss->msgbox_eom_code = 0;
	tss->msgbox_rewind_code = 1;
//	tss->msgbox_status = 0;

	*tss_msg_in = (offset) tss;

	fpu_reg[0] = 0x037f; // CW(control word)
//	fpu_reg[4] = 0; // SW(status word)
	fpu_reg[8] = 0xffff; // TW(tag word)
	LEA(EAX, [fpu_reg]);
	tss->fpu_reg_img = EAX;

//	(offset) task = (int) [SS:ESP + 8]; /* EBP */

	(offset) param = (int) [SS:ESP + 16 /* EBX */];
	PUSH(work->tapiwork_Laddr);
	PUSH((int) tapiwork_sel);
	POP(GS);

	EAX = param->tskdir[0];
	tss_sysdat[0] = EAX;

	/* ldt:0004 ƒR[ƒh */
	EDX = tss_sysdat[ 8];
	EAX = param->codeaddr[0]; /* ƒy[ƒW‘®«QÆ‚Ì‚½‚ß */
	ECX = param->codesize;
	EAX &= 0xfff;
	PUSH(EDX);
	EDX |= EAX;
	PUSH(ECX);
	LEA(EBX, ldt_img[0x0000]);
	EAX = 0x40fa; /* lv3, Exec/Read, use32 */
	set_modulesegment();
	POP(ECX);
	POP(EDX);
	ECX += 0x1fff;
	(offset) param = (int) [SS:ESP + 16 /* EBX */ + 4];
	ECX &= 0xfffff000;
	EDX += ECX;

	/* ldt:001c lv0ƒXƒ^ƒbƒN */
	ECX = param->stack0size;
//	if (DL == 0x01) {
//		EDX &= 0xffffff80;
//		ECX = 4096;
//		task->stack0_addr = EDX;
//	}
	LEA(EBX, ldt_img[0x0018]);
	EDX += ECX;
	EAX = 0xc096; /* lv0, Stack, use32, page */
	PUSH(EDX);
	set_modulesegment();
	POP(EDX);
	(offset) param = (int) [SS:ESP + 16 /* EBX */ + 4];

	/* ldt:000c ƒf[ƒ^[Œ“ƒXƒ^ƒbƒN */
	ECX = param->stack3size;
	if (ECX != 0) {
		EAX = param->header[4];
		ECX += EAX;
		if (AL == 0)
			EDX += EAX;
		ECX &= 0xfffffffe;
		LEA(EBX, ldt_img[0x0008]);
		EAX = 0x40f2; /* lv3, Read/Write, use32 */
		set_modulesegment();
	}

	/* ldt:0014 ƒVƒXƒeƒ€ƒR[ƒ‹ƒQ[ƒgi“‡EEE‚©‚Âb’è“I‚È‚à‚Ìj */
//	LEA(EBX, ldt_img[0x0010]);
//	(short) [DS:EBX + 0] = (offset) &GUIGUI_shellcall;
	asmout("MOV EAX,OFFSET GUIGUI_shellcall");
	(short) ldt_img[0x0010 + 0] = AX;
	(short) ldt_img[0x0010 + 2] = (short) init_sel;
	(int) ldt_img[0x0010 + 4] = 0x0000ec00; // call-gate

	/* ldt:0024 msgboxƒŠ[ƒhƒZƒŒƒNƒ^ */
	ECX = tss->msgbox_write_ptr1;
	LEA(EBX, ldt_img[0x0020]);
	EAX = 0x40f0; /* lv3, Read, use32 */
	LEA(EDX, *tss_msgbuf);
	ECX -= tss->msgbox_write_ptr0;
	EDX += (int) [SS:ESP];
	ECX += 4; // rewind‚Ì—\”õ‚Ì•ª
	set_modulesegment();

	/* ldt:003c system-slot */
	LEA(EBX, ldt_img[0x0038]);
	ECX = 1024;
	EAX = 0x4092; /* lv0, Read/Write, use32 */
	LEA(EDX, *tss_systemslot);
	EDX += (int) [SS:ESP];
	set_modulesegment();

	/* ldt:00c4 pioneer0 */
	PUSH(DS);
	PUSH((int) syswork_sel);
	POP(DS);
	ECX = swork_DS->modulelist[ENT_PIONEER0 +  8];
	EDX = swork_DS->modulelist[ENT_PIONEER0 + 12];
	EDX -= swork_DS->bmodule_paddr;
	EDX += swork_DS->bmodule_laddr;
	POP(DS);
	LEA(EBX, ldt_img[0x00c0]);
	EAX = 0x40fa; /* lv3, Exec/Read, use32 */
	set_modulesegment();

	/* ldt:00cc sysgg00 */
//	LEA(EBX, ldt_img[0x0010]);
//	(short) [DS:EBX + 0] = (offset) &GUIGUI_shellcall2;
	asmout("MOV EAX,GUIGUI_shellcall2");
	(short) ldt_img[0x00c8 + 0] = AX;
	(short) ldt_img[0x00c8 + 2] = (short) init_sel;
	(int) ldt_img[0x00c8 + 4] = 0x0000ec00; // call-gate

	// ldt:0044 GUIGUI-gate
	// ldt:004c GAPI-gate
	// ldt:0054 Timer-gate
	// ldt:005c TAPI-gate

	/* ldt:0100`07ff ƒ†[ƒU[‰ğ•ú(112ŒÂ) */

	/* 104 : I/OƒRƒ“ƒgƒ[ƒ‹—p‚Ì–³§ŒÀƒZƒŒƒNƒ^(‚±‚ê‚ğg‚¤ƒAƒvƒŠ‚Íì‡GÀ„§‚ªâ‘Î‚É“¾‚ç‚ê‚È‚¢BÀŒ±—p) */
	ldt_img[0x0100] = 0x0000ffff;
	ldt_img[0x0104] = 0x00cff200;

	tss_systemslot[0x0008] = 512; /* slotƒTƒCƒY */
	tss_systemslot[0x000c] = 0xffffffff; // g—p’†(reserve)
	tss_systemslot[0x00c0] = 256;
	tss_systemslot[0x00c4] = 0; /* base */
	tss_systemslot[0x00c8] = 0x1004; /* conv */
	tss_systemslot[0x00d0] = 0; /* terminator */
	LEA(EAX, *tss_msg_in);
	tss_systemslot[0x0148] = EAX;

	/* gdt‚Ìİ’è */
	EDX = (int) [SS:ESP];
	EAX = idtgdt_sel;
	EDX += (offset) tss;
	EBX = tss->tr[0];
	GS = AX;
	ECX = 128;
	EAX = 0x0089 /* use16, lv0, TSS386 */;
	EBX += 0x0030 * 8; /* IDT‚Ì•ª */
	set_modulesegment();

	POP(EDX);
	EBX = (int) tss->tss386.LDTR;
//	EDX += (offset) ldt_img;
	/* LEA(EDX, ldt_img[EDX]) */ LEA(EDX, [EDX + ESI + 2048]);
	ECX = 1024;
	EAX = 0x0082 /* use16, lv0, LDT */;
	EBX += 0x0030 * 8; /* IDT‚Ì•ª */
	set_modulesegment();

	/* stack0‚Ì‰Šú‰» */
	/* DS‚ğg‚Á‚ÄƒAƒNƒZƒX‚·‚é */
	SLDT(DX);
	CLI();
	LLDT((short) tss->tss386.LDTR);
	EBX = 0x001c /* stack0 */;
	DS = BX;
	EBX = 0;
	EBP = 0;
	(int) [DS:EBX + 0xffffffe0] = 0xffffff80;
	(int) [DS:EBX + 0xfffffff0] = 0xffffff80;
	EAX = (int) [SS:EBP + 0xffffffe8];
	ECX = (int) [SS:EBP + 0xffffffec];
	(int) [DS:EBX + 0xffffffe8] = EAX;
	(int) [DS:EBX + 0xffffffec] = ECX;
	EAX = (int) [SS:EBP + 0xfffffff8];
	ECX = (int) [SS:EBP + 0xfffffffc];
	(int) [DS:EBX + 0xfffffff8] = EAX;
	(int) [DS:EBX + 0xfffffffc] = ECX;
	#if (VMWARE3)
		if (EDX != 0)
			LLDT(DX);
	#else
		LLDT(DX);
	#endif
	STI();
	TEST(ESP, ESP); /* ZF = 0 */

error:
	POPAD();
	POP(DS);
//	POP(ES);
	POP(GS);
	return;

	ALIGN(4);
taskdir:
	DD(0xffe00000); DD(12); asmout("DB 'task'");
	DD(0xffe00002); DD(16); DD(0 /* normal-directry */); DD(0);
	DD(0xffe00040); DD(16); DD(20); DD(512 /* ‚±‚±‚ğ©“®“I‚ÉŒŸo */); DD(0); DD(0);
	DD(0xfff00000); DD(0xffffffff); /* DD(0); DD(0); */
}

#if 0

void near disable_diskcache()
/* EAX, ECX, EDX‚ğ”j‰ó */
{
	GUIGUI_work *work == SS:0xffffd000;
	PUSH(DS);
	EAX = pdepte_sel;
	DS = AX;
	EAX = 0;
	do {
		BTR(work->cacheflags[0], EAX);
		if (CF == 1) {
			EDX = EAX;
		//	PUSH(EAX);
			EDX *= 4096;
			ECX = 4096;
			EDX += work->diskcache_Laddr;
			unmapping0();
		//	POP(EAX);
		}
		EAX++;
	} while (EAX != 512 /* 2MB•ª */);
	POP(DS);

	/* track‰Šú‰» */
	EAX = 0;
	LEA(EBP, work->track[0]);
	[SS:EBP +  0] = EAX;
	[SS:EBP +  4] = EAX;
	[SS:EBP +  8] = EAX;
	[SS:EBP + 12] = EAX;
	[SS:EBP + 16] = EAX;
	return;
}

void near dosload_loadtrack()
/* EAX‚ªƒgƒ‰ƒbƒN”Ô† */
/* ƒ[ƒhƒAƒhƒŒƒX‚È‚Ç‚Í©“®İ’è‚³‚ê‚é */
/* phase‚Í©“®“I‚ÉƒCƒ“ƒNƒŠƒƒ“ƒg‚³‚ê‚é */
{
	GUIGUI_work *work == SS:0xffffd000;
	work->dosload_phase++;

}

void near dosload_nextphase()
{
	GUIGUI_work *work == SS:0xffffd000;
	EBX = work->dosload_phase;

	asmout("dosload_stratphase:");
		/* EBX‚ªˆø”(EAX`EDX‚Íƒpƒ‰ƒ[ƒ^[) */

next_phase:
	#if (defined(PCAT) || defined(TOWNS))
		if (EBX == 1)
			goto phase00001;
		if (EBX == 2)
			goto phase00002;
		if (EBX == 3)
			goto phase00002;
	#endif
	INT(0x03);

phase00001:
	/* load FAT(1) */
	work->dosload_work[0] = EAX; /* signal */
	EAX = 0;
	BTS(work->track[0], EAX);
	asmout("JNC dosload_loadtrack");

phase00002:
	/* load FAT(2) */
	EAX = 1;
	BTS(work->track[0], EAX);
	asmout("JNC dosload_loadtrack");

phase00003:
	PUSH((int) 0); // eoc
	PUSH(work->dosload_work[0]);
	PUSH(0x1241);
	PUSH(0x0114 /* ƒRƒ}ƒ“ƒhƒVƒOƒiƒ‹’¼Ú */);
	EBX = ESP;
	CALLFAR0(tapi_sel);
	ESP += 16;
	return;


}

#endif

void far GUIGUI_shellcall()
{
	unsigned int                         all_sel       ==  1 * 8;
	unsigned int init_sel     ==  2 * 8, syswork_sel   ==  3 * 8;
	unsigned int GAPI_sel     ==  4 * 8, GAPIwork_sel  ==  5 * 8;
	unsigned int stack_sel    ==  6 * 8, ankfont_sel   ==  7 * 8;
	unsigned int keyint_sel   ==  8 * 8, keydata_sel   ==  9 * 8;
	unsigned int timerint_sel == 10 * 8, timerdata_sel == 11 * 8;
	unsigned int tapi_sel     == 12 * 8, tapiwork_sel  == 13 * 8;
	unsigned int pdepte_sel   == 14 * 8, idtgdt_sel    == 15 * 8;
	unsigned int root_sel     == 16 * 8, tmp_sel       == 17 * 8;
	unsigned int papi_sel     == 18 * 8;
	unsigned int decode_sel   == 22 * 8, decowork_sel  == 23 * 8;
	unsigned int fdcdrive_sel == 28 * 8, fdcwork_sel   == 29 * 8;
	unsigned int diskbuf_sel  == 30 * 8, textbuf_sel   == 31 * 8;
	unsigned int freegdt_sel  == 32 * 8;

	int *cmd == GS:EBP;

	/* lv3‚©‚ç‚Ìi“ü‚Ì‰Â”\«‚ª‚ ‚é‚Ì‚ÅAƒJƒEƒ“ƒg‚ğ‘‚â‚·B */
	(char) [SS:0xffffffe0]++;

	if ((unsigned) (offset) EBX == 0xffffffff) {
		if (EAX == 0x0004) {
			EDX = 0x003c; // slot_sel
			PUSH(DS);
			DS = EDX;
			EAX = (int) [DS:ECX    ];
			EDX = (int) [DS:ECX + 8];
			ECX = (int) [DS:ECX + 4];
			POP(DS);
			goto dec_lv0cnt_ret;
		}
		INT(0x03);
	}

	PUSH(DS);
	PUSH(ES);
	PUSH(FS);
	PUSH(GS);
	PUSHAD();
	MOV(EAX, FS);
	MOV(ECX, SS);
	EBP = EBX;
	GS = EAX;
	FS = ECX;

nextcmd:
	EAX = cmd[0];
	if ((unsigned) EAX < 0x0200) {
		if (EAX == 0)
			goto cmd0000; // end of command
		if (EAX == 0x0040)
			goto cmd0040; // close task
		if (EAX == 0x0080)
			goto cmd0080; // user slot define
		if (EAX == 0x0100)
			goto cmd0100; // open window
		if (EAX == 0x0104)
			goto cmd0104; // close window
		if (EAX == 0x0140)
			goto cmd0140; // send access-disabled-signal
		if (EAX == 0x0144)
			goto cmd0144; // send draw-finished-signal
		INT(0x03);
	}
	if ((unsigned) EAX < 0x0400) {
		if (EAX == 0x0200)
			goto cmd0200; // set soft-int vector
		if (EAX == 0x0204)
			goto cmd0204; // add nest
		if (EAX == 0x0208)
			goto cmd0208; // add nest & return soft-int
		if (EAX == 0x0210)
			goto cmd0210;	/* get info */
		if (EAX == 0x0240)
			goto cmd0240; // set segment
		if (EAX == 0x0300)
			goto cmd0300; // open timer
		if (EAX == 0x0304)
			goto cmd0304; // close timer
		if (EAX == 0x0308)
			goto cmd0308; // regist timer
		if (EAX == 0x030c)
			goto cmd030c; // cancel timer
		if (EAX == 0x0310)
			goto cmd0310; // load time
		if (EAX == 0x0314)
			goto cmd0314; // add time
		if (EAX == 0x0318)
			goto cmd0318; // set timer message
		if (EAX == 0x031c)
			goto cmd031c; // set timer interval
		if (EAX == 0x0320)
			goto cmd0320; // set timer opt81
		if (EAX == 0x0324)
			goto cmd0324; // set timer opt82
		if (EAX == 0x0328)
			goto cmd0328; // get randseed
		INT(0x03);
	}
	if ((unsigned) EAX < 0x0600) {
		if (EAX == 0x0400)
			goto cmd0400; // line
		if (EAX == 0x0404)
			goto cmd0404; // put string
		if (EAX == 0x0408)
			goto cmd0408; /* load font */
		if (EAX == 0x040c)
			goto cmd040c; /* free font */
		if (EAX == 0x0410)
			goto cmd0410; /* make charset */
		if (EAX == 0x0414)
			goto cmd0414; /* put graphic box */
		if (EAX == 0x0418)
			goto cmd0418; /* linear dots */
		if (EAX == 0x041c)
			goto cmd041c; /* points */
		if (EAX == 0x0420)
			goto cmd0420; // store font
		if (EAX == 0x0510)
			goto cmd0510; // define signal
		INT(0x03);
	}
	if ((unsigned) EAX < 0x0800) {
		if (EAX == 0x0600)
			goto cmd0600; // open sound track
		if (EAX == 0x0604)
			goto cmd0604; // close sound track
		if (EAX == 0x0608)
			goto cmd0608; // enable/disable sound track
		if (EAX == 0x060c)
			goto cmd060c; // control sound track
		if (EAX == 0x0700)
			goto cmd0700; /* init handle */ 
		if (EAX == 0x0708)
			goto cmd0708; /* copy handle */ 
		if (EAX == 0x070c)
			goto cmd070c; /* change directory */ 
		if (EAX == 0x0710)
			goto cmd0710; /* create module */ 
		if (EAX == 0x0720)
			goto cmd0720; /* map module */
		if (EAX == 0x0728)
			goto cmd0728; /* read tag */
		if (EAX == 0x0730)
			goto cmd0730; /* tag listing */ 
		if (EAX == 0x0740)
			goto cmd0740; /* resize file */
		INT(0x03);
	}
	if (EAX == 0xffffffff)
		goto cmd0ffffffff;
	INT(0x03);

cmd0000:
	EBX = (offset) cmd;
	EDI = (int) [SS:ESP +  0];
	ESI = (int) [SS:ESP +  4];
	EBP = (int) [SS:ESP +  8];
	EDX = (int) [SS:ESP + 20];
	ECX = (int) [SS:ESP + 24];
	EAX = (int) [SS:ESP + 28];
	GS = (short) [SS:ESP + 32];
	FS = (short) [SS:ESP + 36];
	ES = (short) [SS:ESP + 40];
	DS = (short) [SS:ESP + 44];
	ESP += 48;
dec_lv0cnt_ret:
	CLI();
	(char) [SS:0xffffffe0]--;
	if (!= 0) {
		STI();
		return; // CF = 0, ZF = 0
	}
	TEST(ESP, ESP); // ZF = 0
	PUSHFD();
//	(int) [SS:ESP] |= 0x0200; // IF = 1, ZF == 0
	(char) [SS:ESP + 1] |= 0x02; // IF = 1, ZF == 0
	jmp_system_count0();

cmd0040:
	// close task
//	(offset) cmd += 8;

	EAX = cmd[4];
	TEST(AL, 0x01);
	if (== 0)
		goto cmd0040_skip;

	/* ƒXƒƒbƒg‚ÉŠÜ‚Ü‚ê‚é‚à‚Ì‚ğŒŸõ‚µ‚ÄA‰ğ•ú‚·‚é */
	EDX = 0x003c; /* slot_sel */
	LSL(ECX, EDX);
	ES = EDX;
	ECX++;
	ESI = 0;
	(unsigned int) ECX /= 16;
	do {
		EAX = [ES:ESI + 12];
		if (EAX == 0x0100 /* window */) {
		//	GUIGUI_window_struct *cmd0040_win == DS:EDX;
		//	EAX = stack_sel;
		//	(offset) cmd0040_win = (int) [ES:ESI +  8];
		//	DS = EAX;
		//	cmd0040_win->status = 0; // ”jŠü
			PUSH((int) 0);
			PUSH((int) [ES:ESI +  8]);
			PUSH((int) 0x0024); // close window
			PUSH((int) 0x7f000002);
			PUSH((int) 0x3240 + 3);
			PUSH((int) 0x0128 /* ƒRƒ}ƒ“ƒhƒVƒOƒiƒ‹’¼Ú(with wait) */);
			EBX = ESP;
			CALLFAR0(tapi_sel);
			(char) cmd[6]++; /* ƒNƒ[ƒY’Ê’m” */
			ESP += 24;
		} else if (EAX == 0x0104) { /* timer */
			EAX = (int) [ES:ESI];
			PUSH((int) 0);
			PUSH(EAX);
			PUSH((int) 0x000c /* FreeNode */);
			PUSH(EAX);
			PUSH((int) 0x0014 /* CancelTimer */);
			EBX = ESP;
			DB(0x9a); DD(0); DW((short) timerint_sel);
			if (CF == 1) {
				INT(0x03);
			}
		//	(char) cmd[6]++; /* ƒNƒ[ƒY’Ê’m” */
			ESP += 20;
		} else if (EAX == 0x0110) { /* soundtrack */
			EDX = [ES:ESI + 8]; /* system-ID */
			TEST(DL, 0x01);
			if (!= 0) { /* g—p’†‚¾‚Á‚½‚çAÁ‰¹‚·‚é */
				PUSHFD();
				CLI();
				#if (defined(PCAT))
					IN(AL, 0x0061);
					AL &= 0x0d;
					AL |= 0x01;
					OUT(0x0061, AL);
				#endif
				#if (defined(TOWNS))
					IN(AL, 0x0060);
					AL >>= 2;
					AL &= 0x03;
					OUT(0x0060, AL);
				#endif
				#if (defined(NEC98))
					AL = 0x07;
					OUT(0x0037, AL);
				#endif
				POPFD();
			}
			EDX &= 0xffffffe;
			PUSH((int) 0);
			PUSH(EDX); // slot
			PUSH((int) 0x0044); // command(close sound track)
			PUSH((int) 0x7f000002);
			PUSH((int) 0x3240 /* winman0 */ + 3);
			PUSH((int) 0x0128 /* ƒRƒ}ƒ“ƒhƒVƒOƒiƒ‹’¼Ú(with wait) */);
			EBX = ESP;
			CALLFAR0(tapi_sel);
			(char) cmd[6]++; /* ƒNƒ[ƒY’Ê’m” */
			ESP += 24;

// 0108‚Ísubtimer

		} else if (EAX == 0x0118) {
			/* alloced font mark */
			EAX = GAPIwork_sel;
			PUSH(ESI);
			PUSH(ECX);
			ECX = [ES:ESI + 4] /* conv */;
			DS = AX;
			EBX = [ES:ESI + 0] /* max-range */;
			EAX = ECX;
			ECX &= 0x0f;
			EAX &= 0xfffffff0;
		//	EBX <<= CL;
			SHL(EBX, CL);
			ESI = 0x0e00;
			ECX = EBX;
			free_area();
			POP(ECX);
			POP(ESI);
		}
		EAX = 0;
	//	[ES:ESI + 12] = EAX;
		ESI += 16;
		ECX--;
	} while (!= 0);

	EAX = cmd[4];
cmd0040_skip:
	TEST(AL, 0x02);
	if (== 0)
		goto cmd0040_skip2;

	EAX = tapiwork_sel;
	DS = AX;

	// ‘S‚Ä‚ªÏ‚ñ‚¾‚çAInitƒ^ƒXƒN‚ÉƒVƒOƒiƒ‹‚ğ‘—‚Á‚ÄA
	// ©•ª‚ÍƒXƒŠ[ƒv
//	PUSH((int) 0);
//	PUSH((int) [DS:0x000c]);
//	PUSH((int) 0x0120); // destory task
//	PUSH((int) 0x1240 + 2);
//	AX = SS;
//	ESI = ESP;
//	DS = AX;
//	asmout("fcall 12*8,TAPI_SingnalMessageTimer"); // (not init task...ƒRƒ}ƒ“ƒhƒVƒOƒiƒ‹...‰º‚Ì‚Æ‚Ü‚Æ‚ß‚ç‚ê‚é)
//	ESP += 20;


	// –{“–‚ÍƒxƒNƒ^‚ğØ‚è—£‚µAƒƒbƒZ[ƒW‚ğ‹ó‚É‚µ‚ÄAƒXƒŠ[ƒvB
	EAX = 0;
	PUSH(EAX); // eoc
	PUSH(EAX); // signals
	PUSH(EAX); // delta-nest, Llv0(sleep)
	PUSH((int) 0x010c); // TAPI_AddNestSleep // ‚«‚Á‚ÆA‚±‚ÌƒRƒ}ƒ“ƒh‚ÍŒø‚¢‚Ä‚¢‚È‚¢

	PUSH((int) [DS:0x000c]);
	PUSH((int) 0x0120); // destory task
	PUSH((int) 0x1240 + 2);
	PUSH((int) 0x0128 /* ƒRƒ}ƒ“ƒhƒVƒOƒiƒ‹’¼Ú(with wait) */);

	EBX = ESP;
	CALLFAR0(tapi_sel);
//	ESP += ??;

	INT(0x03);
cmd0040_skip2:
	(offset) cmd += 8;
	goto nextcmd;

cmd0080:
	// user slot define
	EDX = 0x003c; /* slot_sel */
	ESI = cmd[ 4];
	DS = EDX;
	EAX = cmd[ 8];
	ECX = cmd[12];
	EDX = cmd[16];
	(offset) cmd += 20;
	(int) [DS:ESI     ] = EAX;
	(int) [DS:ESI +  4] = ECX;
	(int) [DS:ESI +  8] = EDX;
//	STR(BX);
//	if (BX == 0x0130)
//		INT(0x03);
	goto nextcmd;

cmd0100:
	PUSH((int) stack_sel);
//	INC((char) [SS:0xfffffff0]); // ƒ^ƒXƒNØ‚è‘Ö‚¦—}§
	CLI();
	POP(DS);
	GUIGUI_work *cmd0100_work == DS:0xffffd000;
	GUIGUI_window_struct *cmd0100_win == DS:ESI;
//	(offset) cmd0100_win = (offset) cmd0100_work->winlist;
	LEA((offset) cmd0100_win, (int) cmd0100_work->winlist[0]);
	ECX = MAXWINDOW;
	do {
		if (cmd0100_win->status == 0)
			goto get_free_win_slot;
		(offset) cmd0100_win += sizeof (GUIGUI_window_struct);
		ECX--;
	} while (!= 0);
	// winlist full
	INT(0x03);

get_free_win_slot:
	(char) cmd0100_win->status = 1; // ƒI[ƒvƒ“—v¿’†
	STI();
//	DEC((char) [SS:0xfffffff0]); // ƒ^ƒXƒNØ‚è‘Ö‚¦—}§‰ğœ
//	if (== 0) {
//		PUSH((offset) cmd);
//		asmout("CALL FAR DWORD SS:[0FFFFFFF8H]");
//		EAX = stack_sel;
//		POP((offset) cmd);
//		DS = AX;
//	}
	EDX = cmd[ 4]; // slot-no
	EAX = cmd[ 8]; // user-no
	ECX = cmd[12]; // x-size
	cmd0100_win->win_id_task = EAX;
	cmd0100_win->x_size = ECX;
	EAX = cmd[16]; // y-size
	ECX = cmd[24]; // signal-base
	cmd0100_win->y_size = EAX;
	cmd0100_win->signal_base = ECX;
	(offset) cmd += 28;
//	cmd0100_win->keyfilter = 0x1000;
	EAX = tapiwork_sel;
	ES = AX;
	EAX = [ES:0x000c /* TskPointer */];
	EAX += 0x0240;
	cmd0100_win->msgbox = EAX;
	EAX = 0x003c; /* slot_sel */
	DS = AX;
	(int) [DS:EDX +  8] = (offset) cmd0100_win;
	(int) [DS:EDX + 12] = 0x0100; // window-id mark
	// ÅŒã‚ÉAwinman0‚ÉAwindow openƒVƒOƒiƒ‹‚ğ‘—‚é
	PUSH((int) 0);
	PUSH((offset) cmd0100_win);
	PUSH((int) 0x0020);
cmd0100_send:
	PUSH((int) 0x7f000002);
	PUSH((int) 0x3240 + 3);
	PUSH((int) 0x0128 /* ƒRƒ}ƒ“ƒhƒVƒOƒiƒ‹’¼Ú(with wait) */);
	EBX = ESP;
	CALLFAR0(tapi_sel);
	ESP += 24;
	goto nextcmd;

cmd0104:
	// close window
	GUIGUI_window_struct *cmd0104_win == DS:ESI;
	EAX = 0x003c; /* slot_sel */
	EDX = cmd[4];
	(offset) cmd += 8;
	DS = EAX;
//	EAX = stack_sel;
	(offset) cmd0104_win = [DS:EDX + 8];
	(int) [DS:EDX + 12] = 0;
//	DS = EAX;
//	cmd0104_win->status = 0; // ”jŠü
	PUSH((int) 0);
	PUSH((offset) cmd0104_win);
	PUSH((int) 0x0024); // close window
	PUSH((int) 0x7f000002);
	PUSH((int) 0x3240 + 3);
	PUSH((int) 0x0128 /* ƒRƒ}ƒ“ƒhƒVƒOƒiƒ‹’¼Ú(with wait) */);
	EBX = ESP;
	CALLFAR0(tapi_sel);
	ESP += 24;
	goto nextcmd;

cmd0140:
	// •\¦‹Ö~ƒVƒOƒiƒ‹ó—
	EAX = 0x003c; /* slot_sel */
	EDX = cmd[ 4]; // slot-no
	DS = AX;
	(offset) cmd += 8;
	PUSH((int) 0);
	PUSH((int) [DS:EDX +  8]);
	PUSH((int) 0x00c0);
	goto cmd0100_send;

cmd0144:
	// •`‰æŠ®—¹ƒVƒOƒiƒ‹ó—
	EAX = 0x003c; /* slot_sel */
	EDX = cmd[ 4]; // slot-no
	DS = AX;
	(offset) cmd += 8;
	PUSH((int) 0);
	PUSH((int) [DS:EDX +  8]);
	PUSH((int) 0x00c4);
	goto cmd0100_send;

cmd0200:
	// softint vector İ’è
	// 0x0200, EIP, CS, Llv, flgas
	EAX = tapiwork_sel;
	DS = AX;
	TAPI_TSS *cmd0200_tss == DS:ESI;
	(offset) cmd0200_tss = [DS:0x000c /* TskPointer */];
	EAX = cmd[ 4]; // EIP
	ECX = cmd[ 8]; // CS(eom, rewind)
	cmd0200_tss->softint_EIP = EAX;
	(int) cmd0200_tss->softint_CS = ECX;
	AL = cmd[12]; // Llv
	(offset) cmd += 16;
//	cmd0200_tss->softint_mode = AH;

	cmd0200_tss->softint_Llv = AL;
	cmd0200_tss->softint_oldLlv = 0xff;
//	AL = cmd0200_tss->msgbox_status; TEST(AL, 0x80);
//	if (!= 0) {
		// ‚à‚¤ƒƒbƒZ[ƒW‚ª—ˆ‚Ä‚¢‚é...‚¢‚âAƒxƒNƒ^‚Ì•ÏX‚Ínest‚Åƒ}ƒXƒN‚µ‚Ä‚©‚çs‚¤‚Ì‚Å–â‘è‚Í‚È‚¢
//		INT(0x03); // –¢Š®¬
//		EAX = cmd0200_tss->softint_Llv;
//		if ((unsigned) EAX != cmd0200_tss->Llv) {
//			// ‚µ‚©‚àAŒ»İ‚ÌƒŒƒxƒ‹‚Æ‚Íˆá‚¤İ’è
//			INT(0x03);
//		}
//	}
	goto nextcmd;

cmd0204:
	// add nest

//	AL = (char) cmd[8];
//	ECX = cmd[4];
//	DL = (char) cmd[9];
	PUSH((int) 0); // eoc
	PUSH(cmd[4]); // signals
	PUSH(cmd[8]); // delta-nest(Š„‚è‚İ‚ğg‚í‚È‚¢‚©‚çAnest‚Í•ÏX‚µ‚È‚¢), Llv
	PUSH((int) 0x010c); // TAPI_AddNestSleep
	EBX = ESP;
	CALLFAR0(tapi_sel);
	ESP += 16;
	(offset) cmd += 12;
	goto nextcmd;

cmd0208:
	// add nest & ret from softint
	ECX = cmd[4];
	AL = (char) cmd[8];
	(offset) cmd += 12;
	PUSH((int) 0);
	PUSH(EAX);
	PUSH(ECX);
	PUSH((int) 0x0124 /* TAPI_Softint1Ret */);
	EBX = ESP;
	CALLFAR0(tapi_sel);
	ESP += 16;
	goto nextcmd;

cmd0210:
	/* get info : cmd, opt, len, ofs, far-ptr */
	ECX = cmd[ 8];
	LES(EBX, cmd[16]);
	GUIGUI_work *cmd0210_work == DS:0xffffd000;
	PUSH(stack_sel);
	LEA(EDX, cmd0210_work->infobuf[0]);
	POP(DS);
	EDX += cmd[12];
	do {
		EAX = [DS:EDX];
		EDX += 4;
		[ES:EBX] = EAX;
		EBX += 4;
		ECX--;
	} while (!= 0);
	(offset) cmd += 24;
	goto nextcmd;

cmd0240:
	// set segment
	// opt, selector, ar, limit, offset, base_selector
	EAX = tapiwork_sel;
	EDX = 0x0800;
	DS = AX;
	EDX += [DS:0x0c];
	ECX = EDX;
	EDX += cmd[24]; /* base_selector */
	ECX += cmd[ 8]; /* selector */
	EDX &= 0xfffffff8;
	ECX &= 0xfffffff8;
	AL = [DS:EDX + 4];
	AH = [DS:EDX + 7];
	EAX <<= 16;
	AX = [DS:EDX + 2];
	EAX += cmd[20]; /* offset */
	[DS:ECX + 2] = AX;
	(unsigned int) EAX >>= 16;
	[DS:ECX + 4] = AL;
	[DS:ECX + 7] = AH;
	EAX = cmd[16]; /* limit */
	[DS:ECX + 0] = AX;
	(unsigned int) EAX >>= 16;
	AL |= (char) cmd[13]; /* ar[1] */
	[DS:ECX + 6] = AL;
	AL = cmd[12]; /* ar[0] */
	[DS:ECX + 5] = AL;
	(offset) cmd += 28;
	goto nextcmd;

cmd0300:
	// ƒ^ƒCƒ}[ƒm[ƒhæ“¾
	EDX = cmd[4];
	(offset) cmd += 8;
	EAX = 0x003c;
	DS = AX;
	ESP -= 20;
	EBX = ESP;
	(int) [SS:ESP     ] = 0x0008 /* GetNode */;
	(int) [SS:ESP +  8] = 0x0000 /* EOC */;
	DB(0x9a); DD(0); DW((short) timerint_sel);
	EAX = (int) [SS:ESP + 4];
	if (CF == 1) {
		INT(0x03);
	}
//	PUSH(ES);
	GUIGUI_work *cmd0300_work == ES:0xffffd000;
	PUSH(stack_sel);
	POP(ES);
	ECX = cmd0300_work->TAPI_sendmsgofs;
//	POP(ES);
	(int) [DS:EDX     ] = EAX;
	(int) [DS:EDX + 12] = 0x0104; // timer
	(int) [DS:EDX + 28] = 0x0108; // subtimer
	(int) [DS:EDX + 44] = 0x0108; // subtimer
	(int) [SS:ESP     ] = 0x0028 /* SetCallVectorNode */;
	(int) [SS:ESP +  8] = ECX;
	(int) [SS:ESP + 12] = tapi_sel;
	(int) [SS:ESP + 16] = 0x0000 /* EOC */;
	EBX = ESP;
	DB(0x9a); DD(0); DW((short) timerint_sel);
//	if (CF == 1) {
//		INT(0x03);
//	}
	ESP += 20;
	(char) [DS:EDX +  7] = 0; // ƒƒbƒZ[ƒW‚ÌÅ‰‚ÌDW
	goto nextcmd;

cmd0304:
	// ƒ^ƒCƒ}[ƒm[ƒh•Ô‹p
	INT(0x03);

cmd0308:
	// ƒ^ƒCƒ}[“o˜^
	EDX = cmd[4];
	(offset) cmd += 8;
	PUSH((int) 0x003c);
	POP(DS);
	PUSH((int) 0x0000 /* EOC */);
	ECX = (int) [DS:EDX     ];
	PUSH(ECX);
	PUSH((int) 0x0010 /* SetTimer */);
	PUSH((int) [DS:EDX + 40]);
	PUSH((int) [DS:EDX + 36]);
	PUSH((int) [DS:EDX + 32]);
	PUSH((int) [DS:EDX + 24]);
	PUSH((int) [DS:EDX + 20]);
	PUSH((int) [DS:EDX + 16]);
	PUSH((int) [DS:EDX +  8]);
	PUSH((int) [DS:EDX +  4]);
	PUSH((int) 8);
	PUSH(ECX);
	PUSH((int) 0x002c /* SetMsgDataNode */);
	EBX = ESP;
	DB(0x9a); DD(0); DW((short) timerint_sel);
	if (CF == 1) {
		INT(0x03);
	}
	ESP += 56;
	goto nextcmd;

cmd030c:
	// ƒ^ƒCƒ}[‰ğ–ñ
	EDX = cmd[4];
	(offset) cmd += 8;
	PUSH((int) 0x003c);
	POP(DS);
	PUSH((int) 0x0000 /* EOC */);
	PUSH((int) [DS:EDX     ]);
	PUSH((int) 0x0014 /* CancelTimer */);
	EBX = ESP;
	DB(0x9a); DD(0); DW((short) timerint_sel);
	if (CF == 1) {
		INT(0x03);
	}
	ESP += 12;
	goto nextcmd;

cmd0310:
	// Œ»İƒ[ƒh
	EDX = cmd[4];
	(offset) cmd += 8;
	EAX = 0x003c;
	DS = AX;
	PUSH((int) 0x0000 /* EOC */);
	PUSH((int) [DS:EDX    ]);
	PUSH((int) 0x001c /* SetNowTimeNode */);
	EBX = ESP;
	DB(0x9a); DD(0); DW((short) timerint_sel);
	if (CF == 1) {
		INT(0x03);
	}
	ESP += 12;
	goto nextcmd;

cmd0314:
	// ŠÔ‰ÁZ
	GUIGUI_work *cmd0314_work == ES:0xffffd000;
	EDX = cmd[ 4];
	ECX = 0;
	EAX = 0x003c;
	PUSH(ECX /* EOC */);
	DS = AX;
	PUSH(ECX);
	PUSH(ECX);
	PUSH(ECX);
	PUSH((int) [DS:EDX    ]);
	PUSH((int) stack_sel);
	POP(ES);
	PUSH((int) 0x0020 /* AddTimeNode */);
	ECX = cmd0314_work->timer_freq; // 1193180;
	EAX = cmd[ 8];
	if (EAX != 0) {
		MUL(ECX);
		EAX <<= 1; // EAX‚ÌMSB‚ğCF‚ÖB
	//	(int) [SS:ESP +  8] += EDX + CF;
		ADC((int) [SS:ESP +  8], EDX);
	}
	EAX = cmd[12];
	if (EAX != 0) {
		MUL(ECX);
		(int) [SS:ESP +  8] += EAX;
	//	(int) [SS:ESP + 12] += EDX + CF;
		ADC((int) [SS:ESP + 12], EDX);
	}
	EAX = cmd[16];
	if (EAX != 0) {
		MUL(ECX);
		(int) [SS:ESP + 12] += EAX;
	//	(int) [SS:ESP + 16] += EDX + CF;
		ADC((int) [SS:ESP + 16], EDX);
	}
	EBX = ESP;
	DB(0x9a); DD(0); DW((short) timerint_sel);
//	if (CF == 1) {
//		INT(0x03);
//	}
	ESP += 24;
	(offset) cmd += 20;
	goto nextcmd;

cmd0318:
	// ƒƒbƒZ[ƒWİ’è
	EAX = 0x003c;
	ECX = cmd[12];
	DS = AX;
	EDX = cmd[ 8];
	ESI = cmd[ 4];
	EAX = [DS:EDX +  8]; // ƒXƒƒbƒg”Ô†
	(offset) cmd += 16;
	(int) [DS:ESI +  4] &= 0x80000000; // ÅãˆÊbit‚ğc‚·
	EAX |= ECX;
	(int) [DS:ESI +  4] |= EAX;
	EAX = *cmd;
	(offset) cmd += 4;
	ECX--;
	(int) [DS:ESI +  8] = EAX;
	if (== 0)
		goto nextcmd;
	EAX = *cmd;
	(offset) cmd += 4;
	ECX--;
	(int) [DS:ESI + 16] = EAX;
	if (== 0)
		goto nextcmd;
	EAX = *cmd;
	(offset) cmd += 4;
	ECX--;
	(int) [DS:ESI + 20] = EAX;
	if (== 0)
		goto nextcmd;
	EAX = *cmd;
	(offset) cmd += 4;
	ECX--;
	(int) [DS:ESI + 24] = EAX;
	if (== 0)
		goto nextcmd;
	EAX = *cmd;
	(offset) cmd += 4;
	ECX--;
	(int) [DS:ESI + 32] = EAX;
	if (== 0)
		goto nextcmd;
	EAX = *cmd;
	(offset) cmd += 4;
	ECX--;
	(int) [DS:ESI + 36] = EAX;
	if (== 0)
		goto nextcmd;
	EAX = *cmd;
	(offset) cmd += 4;
//	ECX--;
	(int) [DS:ESI + 40] = EAX;
//	if (== 0)
//		goto cmd0318_fin;
	goto nextcmd;

cmd031c:
	// ƒCƒ“ƒ^[ƒoƒ‹ŠÔŠuİ’è
	GUIGUI_work *cmd031c_work == ES:0xffffd000;
	ECX = 0x003c;
	EAX = cmd[ 8];
	DS = CX;
	ECX = stack_sel;
	ESI = cmd[ 4];
	ES = CX;
	EAX |= cmd[12];
	(char) [DS:ESI +  7] &= 0x7f; // ’P”­ƒ‚[ƒh
	EAX |= cmd[16];
	if (!= 0) {
		EAX = 0;
		(char) [DS:ESI +  7] |= 0x80; // ˜A‘±ƒ‚[ƒh
		(int) [DS:ESI + 32] = EAX;
		(int) [DS:ESI + 36] = EAX;
		(int) [DS:ESI + 40] = EAX;
		ECX = cmd031c_work->timer_freq; // 1193180;
		EAX = cmd[ 8];
		if (EAX != 0) {
			MUL(ECX);
			EAX <<= 1; // EAX‚ÌMSB‚ğCF‚ÖB
		//	(int) [DS:ESI + 32] += EDX + CF;
			ADC((int) [DS:ESI + 32], EDX);
		}
		EAX = cmd[12];
		if (EAX != 0) {
			MUL(ECX);
			(int) [DS:ESI + 32] += EAX;
		//	(int) [DS:ESI + 36] += EDX + CF;
			ADC((int) [DS:ESI + 36], EDX);
		}
		EAX = cmd[16];
		if (EAX != 0) {
			MUL(ECX);
			(int) [DS:ESI + 36] += EAX;
		//	(int) [DS:ESI + 40] += EDX + CF;
			ADC((int) [DS:ESI + 40], EDX);
		}
	}
	(offset) cmd += 20;
	goto nextcmd;

cmd0320:
	// set timer opt81
	// cmd, slot0, slot1, time0, time1, time2
	GUIGUI_work *cmd0320_work == ES:0xffffd000;
	PUSH((int) stack_sel);
	PUSH((int) 0x003c);
	ECX = 0;
	POP(DS); /* == 0x003c */
	POP(ES); /* == stack_sel */
	ESI = cmd[ 4];
	EDI = cmd[ 8];
	PUSH(ECX /* EOC */);
	PUSH(ECX);
	PUSH(ECX);
	PUSH(ECX);
	PUSH((int) [DS:EDI]);
	PUSH((int) [DS:ESI]);
	PUSH((int) 0x0034 /* AddTimeNode2 */);
	ECX = cmd0320_work->timer_freq; // 1193180;
	EAX = cmd[12];
	if (EAX != 0) {
		MUL(ECX);
		EAX <<= 1; // EAX‚ÌMSB‚ğCF‚ÖB
	//	(int) [SS:ESP + 12] += EDX + CF;
		ADC((int) [SS:ESP + 12], EDX);
	}
	EAX = cmd[16];
	if (EAX != 0) {
		MUL(ECX);
		(int) [SS:ESP + 12] += EAX;
	//	(int) [SS:ESP + 16] += EDX + CF;
		ADC((int) [SS:ESP + 16], EDX);
	}
	EAX = cmd[20];
	if (EAX != 0) {
		MUL(ECX);
		(int) [SS:ESP + 16] += EAX;
	//	(int) [SS:ESP + 20] += EDX + CF;
		ADC((int) [SS:ESP + 20], EDX);
	}
	EBX = ESP;
	DB(0x9a); DD(0); DW((short) timerint_sel);
//	if (CF == 1) {
//		INT(0x03);
//	}
	ESP += 28;
	(offset) cmd += 24;
	goto nextcmd;

cmd0324:
	// set timer opt82
	// cmd, slot0, slot1, time0, time1, time2
	GUIGUI_work *cmd0324_work == ES:0xffffd000;
	PUSH((int) stack_sel);
	PUSH((int) 0x003c);
	ECX = 0;
	POP(DS); /* == 0x003c */
	POP(ES); /* == stack_sel */
	ESI = cmd[ 4];
	EDI = cmd[ 8];
	PUSH(ECX /* EOC */);
	PUSH(ECX);
	PUSH(ECX);
	PUSH(ECX);
	PUSH((int) [DS:EDI]);
	PUSH((int) [DS:ESI]);
	PUSH((int) 0x0024 /* SubTimeNode */);
	EBX = ESP;
	DB(0x9a); DD(0); DW((short) timerint_sel);
	ESP += 12;
	EBX = cmd0324_work->timer_sec4;
	POP(EAX);
	MUL(EBX);
	cmd[12] = EAX;
	POP(EAX);
	cmd[16] = EDX;
	cmd[20] = ECX;
	if (EAX != 0) {
		MUL(EBX);
		cmd[16] += EAX;
		ADC(cmd[20], EDX);
	}
	POP(EAX);
	if (EAX != 0) {
		MUL(EBX);
		cmd[20] += EAX;
	}
	POP(ECX);
	(offset) cmd += 24;
	goto nextcmd;

cmd0328:
	/* getrandseed */
	/* TimerSC_SetNowTimeƒRƒ}ƒ“ƒh‚ğg‚¤‚Ì‚Åƒ^ƒCƒ}[‚Í‚¢‚ç‚È‚¢ */
	ECX = 0;
	PUSH(ECX /* EOC */);
	PUSH(ECX);
	PUSH(ECX);
	PUSH(ECX);
	PUSH((int) 0x0018 /* TimerSC_SetNowTime */);
	EBX = ESP;
	DB(0x9a); DD(0); DW((short) timerint_sel);
	POP(EBX);
	POP(EAX);
	POP(ECX);
	XCHG(AH, AL); /* ‚©‚«‰ñ‚µ */
	POP(EDX);
	EAX ^= ECX;
	POP(EBX);
	EAX ^= EDX;
	cmd[4] = EAX;
	(offset) cmd += 8;
	goto nextcmd;

cmd0400:
	// relative line & box
	GUIGUI_window_struct *cmd0400_win == DS:ESI;
	int *cmd0400_stack == SS:ESP;
	EDX = cmd[ 8];
	ESP -= 76;
	if (EDX != 0) {
		EAX = 0x003c; // slot_sel
		ECX = stack_sel;
		ES = AX;
		DS = CX;
		(offset) cmd0400_win = (int) [ES:EDX + 8];
	}
	LEA(EAX, cmd0400_stack[68]);
	cmd0400_stack[ 0] = 0x0184; // accesslock
	cmd0400_stack[ 4] = 0; // priority/handle
	cmd0400_stack[ 8] = 0; // opt(lock/bitset)
	cmd0400_stack[28] = EAX;
	EAX = cmd[ 4];
	cmd0400_stack[32] = 0x0100; // line
	cmd0400_stack[36] = EAX;
	EAX = cmd[12];
	ECX = cmd[16];
	if (EDX != 0) {
		EAX += cmd0400_win->x0;
		ECX += cmd0400_win->y0;
	}
	cmd0400_stack[40] = EAX;
	cmd0400_stack[44] = ECX;
	cmd0400_stack[12] = EAX;
	cmd0400_stack[16] = ECX;
	EAX = cmd[20];
	ECX = cmd[24];
	if (EDX != 0) {
		EAX += cmd0400_win->x0;
		ECX += cmd0400_win->y0;
	}
	cmd0400_stack[48] = EAX;
	cmd0400_stack[52] = ECX;
	EAX++;
	ECX++;
	cmd0400_stack[20] = EAX;
	cmd0400_stack[24] = ECX;
	if (EAX < cmd0400_stack[12]) {
		EDX = cmd0400_stack[12];
		cmd0400_stack[12] = EAX;
		cmd0400_stack[20] = EDX;
	}
	if (ECX < cmd0400_stack[16]) {
		EAX = cmd0400_stack[16];
		cmd0400_stack[16] = ECX;
		cmd0400_stack[24] = EAX;
	}
	EAX = cmd[28];
	(offset) cmd += 32;
	cmd0400_stack[56] = EAX;
	cmd0400_stack[60] = 0x0184; // accesslock
	cmd0400_stack[64] = 0; // priority/handle
	cmd0400_stack[68] = 1; // opt(unlock/bitmode)
	cmd0400_stack[72] = 0; // eoc
	EBX = ESP;
	DB(0x9a); DD(0); DW((short) GAPI_sel);
	ESP += 76;
	goto nextcmd;

cmd0404:
	// •¶š•\¦
	/* cmd, opt, winslot, x, y, col, bcol, charset, base, len, ofs, sel */
	/* opt: bit0-1 > through, bit8-9 > dw|by|wd|qw */ 
	GUIGUI_window_struct *cmd0404_win == ES:ESI;
	int *cmd0404_stack == SS:ESP + 8;
	PUSH((int) 0x003c); // slot_sel
	PUSH((int) stack_sel);
	ESI = cmd[36]; /* length */
	POP(ES);
	LEA(EAX, [ESI * 4 + 84]);
	POP(DS);
	EDI = ESP;
	ESP -= EAX;
	ECX = 0;
	PUSH((offset) cmd);
	PUSH(EDI); /* old ESP */
	EAX = cmd[ 4];
	cmd0404_stack[ 0] = 0x0184; // accesslock
	cmd0404_stack[ 4] = ECX; // priority/handle
	cmd0404_stack[ 8] = ECX; // opt(lock/bitset)
	cmd0404_stack[32] = 0x0101; // put fonts
	EAX &= 0x03;
	EDX = cmd[ 8];
	cmd0404_stack[36] = EAX; // opt
	EAX = cmd[12];
	ECX = cmd[16];
	if (EDX != 0) {
		PUSH(ESI);
		(offset) cmd0404_win = (int) [DS:EDX + 8];
		EAX += cmd0404_win->x0;
		ECX += cmd0404_win->y0;
		POP(ESI);
	}
	cmd0404_stack[40] = EAX; // x0
	cmd0404_stack[44] = ECX; // y0
	cmd0404_stack[12] = EAX;
	cmd0404_stack[16] = ECX;
	ECX += 16; /* ƒn[ƒtƒnƒCƒg‚È‚ç‚±‚Ì”¼•ª‚Å‚¢‚¢‚Ì‚¾‚ªA”»’è‚ª–Ê“|‚È‚Ì‚Åˆê—¥16ƒhƒbƒg */
	cmd0404_stack[24] = ECX;
	EDX = cmd[20];
	ECX = cmd[24];
	cmd0404_stack[48] = EDX; // color
	cmd0404_stack[52] = ECX; // color
//	cmd0404_stack[56] = 0; // dummy
//	cmd0404_stack[60] = ankfont_sel; // font_sel
	EDI = cmd[28]; /* charset */
//	ESI = cmd[36];
	EDX = cmd[32]; /* base */
	asmout("LES EBX,GS:[EBP+40]");
	LEA(EAX, [EAX + ESI * 8]);
	cmd0404_stack[20] = EAX;
	EAX = cmd[ 4]; /* opt */
	LEA(EBP, cmd0404_stack[68]);
	AH &= 0x30;
	cmd0404_stack[64] = ESI; // length
	if (== 0)
		goto cmd0404_dword;
	if (AH == 0x10)
		goto cmd0404_byte;
	if (AH == 0x20)
		goto cmd0404_word;

cmd0404_qword:
	do {
		/* EBX, EBP, ESI, EDI */
		EAX = (int) [ES:EBX];
		EBX += 8;
		EAX += EDX;
		/* local fontcode ‚ğ global fontaddr ‚É•ÏŠ·‚·‚é */
		PUSH(EDX);
		PUSH(EDI);
nextfont2_q:
		EAX -= [DS:EDI + 4 /* base */];
		if ((unsigned) < 0)
			goto nextfont_q;
		if ((unsigned) EAX >= [DS:EDI + 0] /* range */)
			goto nextfont_q;
		ECX = [DS:EDI + 8 /* conv */];
		EDX = ECX;
		ECX &= 0x0f;
		EDX &= 0xfffffff0;
		SHL(EAX, CL);
		POP(EDI);
		EAX += EDX;
		POP(EDX);
		(int) [SS:EBP] = EAX;
		EBP += 4;
		ESI--;
	} while (!= 0);

cmd0404_final:
	(int) [SS:EBP +  0] = 0x0184; // accesslock
	(int) [SS:EBP +  4] = /* 0 */ ESI; // priority/handle
	(int) [SS:EBP +  8] = 1; // opt(unlock/bitmode)
	(int) [SS:EBP + 12] = /* 0 */ ESI; // eoc
	EBP += 8;
	cmd0404_stack[28] = EBP;
	LEA(EBX, [SS:ESP + 8]);
	DB(0x9a); DD(0); DW((short) GAPI_sel);
	POP(EDI);
	POP((offset) cmd);
	ESP = EDI;
	(offset) cmd += 48;
	goto nextcmd;

nextfont_q:
	EAX += [DS:EDI + 4 /* base */];
	EDI += 16;
	goto nextfont2_q;


cmd0404_dword:
	do {
		/* EBX, EBP, ESI, EDI */
		EAX = (int) [ES:EBX];
		EBX += 4;
		EAX += EDX;

		/* local fontcode ‚ğ global fontaddr ‚É•ÏŠ·‚·‚é */
		PUSH(EDX);
		PUSH(EDI);
nextfont2_d:
		EAX -= [DS:EDI + 4 /* base */];
		if ((unsigned) < 0)
			goto nextfont_d;
		if ((unsigned) EAX >= [DS:EDI + 0] /* range */)
			goto nextfont_d;
		ECX = [DS:EDI + 8 /* conv */];
		EDX = ECX;
		ECX &= 0x0f;
		EDX &= 0xfffffff0;
		SHL(EAX, CL);
		POP(EDI);
		EAX += EDX;
		POP(EDX);
		(int) [SS:EBP] = EAX;
		EBP += 4;
		ESI--;
	} while (!= 0);
	goto cmd0404_final;

nextfont_d:
	EAX += [DS:EDI + 4 /* base */];
	EDI += 16;
	goto nextfont2_d;

cmd0404_word:
	do {
		/* EBX, EBP, ESI, EDI */
		EAX = (unsigned short) [ES:EBX];
		EBX += 2;
		EAX += EDX;

		/* local fontcode ‚ğ global fontaddr ‚É•ÏŠ·‚·‚é */
		PUSH(EDX);
		PUSH(EDI);
nextfont2_w:
		EAX -= [DS:EDI + 4 /* base */];
		if ((unsigned) < 0)
			goto nextfont_w;
		if ((unsigned) EAX >= [DS:EDI + 0] /* range */)
			goto nextfont_w;
		ECX = [DS:EDI + 8 /* conv */];
		EDX = ECX;
		ECX &= 0x0f;
		EDX &= 0xfffffff0;
		SHL(EAX, CL);
		POP(EDI);
		EAX += EDX;
		POP(EDX);
		(int) [SS:EBP] = EAX;
		EBP += 4;
		ESI--;
	} while (!= 0);
	goto cmd0404_final;

nextfont_w:
	EAX += [DS:EDI + 4 /* base */];
	EDI += 16;
	goto nextfont2_w;

cmd0404_byte:
	do {
		/* EBX, EBP, ESI, EDI */
		EAX = (unsigned char) [ES:EBX];
		EBX++;
		EAX += EDX;

		/* local fontcode ‚ğ global fontaddr ‚É•ÏŠ·‚·‚é */
		PUSH(EDX);
		PUSH(EDI);
nextfont2_b:
		EAX -= [DS:EDI + 4 /* base */];
		if ((unsigned) < 0)
			goto nextfont_b;
		if ((unsigned) EAX >= [DS:EDI + 0] /* range */)
			goto nextfont_b;
		ECX = [DS:EDI + 8 /* conv */];
		EDX = ECX;
		ECX &= 0x0f;
		EDX &= 0xfffffff0;
		SHL(EAX, CL);
		POP(EDI);
		EAX += EDX;
		POP(EDX);
		(int) [SS:EBP] = EAX;
		EBP += 4;
		ESI--;
	} while (!= 0);
	goto cmd0404_final;

nextfont_b:
	EAX += [DS:EDI + 4 /* base */];
	EDI += 16;
	goto nextfont2_b;

cmd0408:
	/* load font */
    /* cmd, opt(type), slot, len, from */
    /* opt‚Ìbit31‚ğ0x01‚É‚·‚é‚ÆAƒJƒXƒ^ƒ€ƒR[ƒh(80000000‚Íƒl[ƒ€)B */
	EAX = 0x003c; /* slot_sel */
	EDX = cmd[8]; /* slot */
	ES = AX;
	EAX = cmd[4]; /* opt */
	if ((signed) EAX > 0) {

		/* ƒAƒgƒŠƒrƒ…[ƒg‚ğæ“¾‚µ‚ÄAƒTƒCƒY‚ğŠm’è */
		ECX = 0;
		PUSH(ECX); /* eoc */
		PUSH(ECX);
		PUSH(ECX);
		PUSH(ECX);
		PUSH(ECX);
		PUSH(EAX); /* type */
		PUSH(ECX);
		PUSH((int) 0x0140 /* get font attr */);
		EBX = ESP;
		DB(0x9a); DD(0); DW((short) GAPI_sel);
		ECX = [SS:ESP + 12]; /* CL == bits/font */
		ESP += 32;
		PUSH(ECX);
		EAX = GAPIwork_sel;
		EBX = cmd[12]; /* len */
		ESI = 0x0e00;
		if (CL == 0x03) {
			EBX++;
			EBX &= 0xfffffffe;
		}
		[ES:EDX +  0] = EBX;

		/* —ÌˆæŠm•Û */
		SHL(EBX, CL);
		DS = AX;
		ECX = EBX;
		get_area();
		if (ZF != 0)
			INT(0x03);

if (EAX == 0)
INT(3);

		/* “]‘—ƒRƒ}ƒ“ƒhÀs */
		PUSH((int) 0);
		PUSH(cmd[20] /* from (sel) */);
		PUSH(cmd[16] /* from (ofs) */);
		PUSH(EAX /* to */);
		PUSH(cmd[12] /* len */);
		PUSH(cmd[4] /* type */);
		PUSH((int) 0 /* opt */);
		PUSH((int) 0x0104 /* load font */);
		(offset) cmd += 24;
		AL |= [SS:ESP + 32];
		(int) [ES:EDX + 12] = 0x0118; /* alloced font mark */
		[ES:EDX +  4] = EAX;
		EBX = ESP;
		DB(0x9a); DD(0); DW((short) GAPI_sel);
		ESP += 32 + 4;
		goto nextcmd;
	}

	PUSH(EAX);
	EAX &= 0x0fffffff;
	(offset) cmd += 12;

	if (EAX == 0x00ffffff)
		goto skip;
	if (EAX == 0x00000001) {
		/* 8x16dot mono ANK */
		(int) [ES:EDX +  0] = 256 /* max-range */;
		(int) [ES:EDX +  4] = 0x1004; /* conv */
	//	(int) [ES:EDX + 12] = 0x0114; /* overlink font mark */
	} else if (EAX == 0x00000002) {
		/* 8x8dot mono half-ANK */
		(int) [ES:EDX +  0] = 512 /* max-range */;
		(int) [ES:EDX +  4] = 0x1003; /* conv */
	//	(int) [ES:EDX + 12] = 0x0114; /* overlink font mark */
#if 0
	} else if (EAX == 0x00000011) {
		/* 8x16dot mono gg00jpn0 */
		(int) [ES:EDX +  0] = 0x3cf4 /* max-range (15604•¶š-”¼Šp’PˆÊ) */;
		(int) [ES:EDX +  4] = 0x2004; /* conv */
	//	(int) [ES:EDX + 12] = 0x0114; /* overlink font mark */
	} else if (EAX == 0x00000012) {
		/* 8x8dot mono half-gg00jpn0 */
		(int) [ES:EDX +  0] = 0x79e8 /* max-range (31208•¶š-”¼Šp’PˆÊ) */;
		(int) [ES:EDX +  4] = 0x2003; /* conv */
	//	(int) [ES:EDX + 12] = 0x0114; /* overlink font mark */
#endif
	} else {
		INT(0x03);
	}
	(int) [ES:EDX + 12] = 0x0114; /* overlink font mark */
skip:
	POP(EAX);
	TEST(EAX, 0x40000000);
	if (== 0)
		goto nextcmd;

	/* winman0‚ÉƒVƒOƒiƒ‹‚ğ‘—‚é */
	EBX = tapiwork_sel;
	DS = EBX;
	PUSH((int) 0);
	PUSH(cmd[4]);
	PUSH(cmd[0]);
	PUSH((int) [DS:0x000c] /* tss */);
	PUSH(EAX);
	PUSH((int) 0x0048);
	PUSH((int) 0x7f000005);
	PUSH((int) 0x3240 /* winman0 */ + 6);
	PUSH((int) 0x0128 /* ƒRƒ}ƒ“ƒhƒVƒOƒiƒ‹’¼Ú(with wait) */);
	EBX = ESP;
	CALLFAR0(tapi_sel);
	(offset) cmd += 8;
	ESP += 36;
	goto nextcmd;

cmd040c:
	/* free font */
	/* cmd, opt, slot */
	EAX = 0x003c;
	EDX = cmd[8];
	ES = AX;
	(offset) cmd += 12;
	if ((unsigned) (int) [ES:EDX + 12] == 0x0118) {
		EAX = GAPIwork_sel;
		DS = AX;
		ECX = [ES:EDX + 4] /* conv */;
		EBX = [ES:EDX + 0] /* max-range */;
		EAX = ECX;
		ECX &= 0x0f;
		EAX &= 0xfffffff0;
	//	EBX <<= CL;
		SHL(EBX, CL);
		ESI = 0x0e00;
		ECX = EBX;
		free_area();
	}
	(int) [ES:EDX + 12] = 0;
	goto nextcmd;

cmd0410:
	/* make charset */
	/* cmd, opt, slot(charset), slot(font), range, from, to */
	EAX = 0x003c;
	EDX = cmd[ 8]; /* charset */
	ES = AX;
	EBX = cmd[12]; /* font */
	ECX = cmd[16]; /* range */
	TEST(BL, 0x0f);
	if (== 0) {
		[ES:EDX + 0] = ECX;
		if (ECX != 0) {
			EAX = cmd[24]; /* to */
			ESI = cmd[20]; /* from */
			ECX = [ES:EBX + 4]; /* conv */
			[ES:EDX + 4] = EAX;
			EAX = ECX;
			ECX &= 0x0f;
			SHL(ESI, CL);
			EAX += ESI;
			[ES:EDX + 8] = EAX;
		}
		(offset) cmd += 28;
		goto nextcmd;
	}
	if (EBX == 0x0021 /* ƒtƒ‹ƒnƒCƒgE•¶šƒZƒbƒg01 */) {
		[ES:EDX +  0] = ECX;
		[ES:EDX + 16] = ECX; /* ƒ_ƒ~[ */
		[ES:EDX + 32] = ECX; /* ƒ_ƒ~[ */
		[ES:EDX + 48] = ECX; /* ƒ_ƒ~[ */
		EAX = cmd[24]; /* to */
		ESI = cmd[20]; /* from */ /* ‚±‚ê‚Í0‚Å‚ ‚é‚×‚« */
		ECX = 0x2004; /* conv */
		[ES:EDX +  4] = EAX;
		[ES:EDX + 20] = EAX;
		[ES:EDX + 36] = EAX;
		[ES:EDX + 52] = EAX;
		EAX = ECX;
	//	ECX &= 0x0f;
	//	SHL(ESI, CL);
	//	EAX += ESI;
		[ES:EDX +  8] = EAX;
	//	[ES:EDX + 24] = EAX;
	//	[ES:EDX + 40] = EAX;
	//	[ES:EDX + 56] = EAX;
		(offset) cmd += 28;
		goto nextcmd;
	}
	if (EBX == 0x0031 /* ƒn[ƒtƒnƒCƒgE•¶šƒZƒbƒg01 */) {
		[ES:EDX +  0] = ECX;
		[ES:EDX + 16] = ECX; /* ƒ_ƒ~[ */
		[ES:EDX + 32] = ECX; /* ƒ_ƒ~[ */
		[ES:EDX + 48] = ECX; /* ƒ_ƒ~[ */
		EAX = cmd[24]; /* to */
		ESI = cmd[20]; /* from */ /* ‚±‚ê‚Í0‚Å‚ ‚é‚×‚« */
		ECX = 0x2003; /* conv */
		[ES:EDX +  4] = EAX;
		[ES:EDX + 20] = EAX;
		[ES:EDX + 36] = EAX;
		[ES:EDX + 52] = EAX;
		EAX = ECX;
	//	ECX &= 0x0f;
	//	SHL(ESI, CL);
	//	EAX += ESI;
		[ES:EDX +  8] = EAX;
	//	[ES:EDX + 24] = EAX;
	//	[ES:EDX + 40] = EAX;
	//	[ES:EDX + 56] = EAX;
		(offset) cmd += 28;
		goto nextcmd;
	}

cmd0414:
	/* ƒuƒƒbƒN“]‘— */
	/* cmd, opt(1), window, x0, y0, xsize, ysize, yskip, ofs, sel */
	GUIGUI_window_struct *cmd0414_win == DS:ESI;
	int *cmd0414_stack == SS:ESP;
	EAX = 0x003c; // slot_sel
	ECX = stack_sel;
	ES = AX;
	DS = CX;
	PUSH((int) 0);
	PUSH((int) 1); // opt(unlock/bitmode)
	EBX = ESP;
	PUSH((int) 0); // priority/handle
	PUSH((int) 0x0184); // accesslock

	AL = cmd[ 4];
	TEST(AL, 0x10);
	if (!= 0)
		PUSH(cmd[40]);
	PUSH(cmd[36]);
	PUSH(cmd[32]);
	PUSH(cmd[28]);
	PUSH(cmd[24]);
	PUSH(cmd[20]);
	EDX = cmd[ 8];
	EAX = cmd[12];
	ECX = cmd[16];
	if (EDX != 0) {
		(offset) cmd0414_win = (int) [ES:EDX + 8];
		EAX += cmd0414_win->x0;
		ECX += cmd0414_win->y0;
	}
	PUSH(ECX);
	PUSH(EAX);
	PUSH(cmd[ 4]);
	PUSH((int) 0x0108);

	PUSH(EBX);
	PUSH(ECX);
	PUSH(EAX);
	PUSH(ECX);
	PUSH(EAX);
	PUSH((int) 0); // opt(lock/bitset)
	PUSH((int) 0); // priority/handle
	PUSH((int) 0x0184); // accesslock
	EAX = cmd[20];
	ECX = cmd[24];
	(int) [SS:ESP + 20] += EAX;
	(int) [SS:ESP + 24] += ECX;

	EBX = ESP;
	DB(0x9a); DD(0); DW((short) GAPI_sel);
	DL = cmd[ 4];
	TEST(DL, 0x10);
	if (!= 0) {
		(offset) cmd += 4;
		POP(EAX);
	}
	(offset) cmd += 40;
	ESP += 84;
	goto nextcmd;

cmd0418:
	// linear dots
	/* cmd, opt, window, x0, y0, xsize, ysize, lines, ofs, sel */
	GUIGUI_window_struct *cmd0418_win == DS:ESI;
	EAX = 0x003c; // slot_sel
	ECX = stack_sel;
	ES = AX;
	DS = CX;
	PUSH((int) 0);
	PUSH((int) 1); // opt(unlock/bitmode)
	EBX = ESP;
	PUSH((int) 0); // priority/handle
	PUSH((int) 0x0184); // accesslock

	PUSH(cmd[36]); /* sel */
	PUSH(cmd[32]); /* ofs */
	PUSH(cmd[28]); /* lines */
	PUSH(cmd[24]); /* ysize */
	PUSH(cmd[20]); /* xsize */
	EDX = cmd[ 8]; /* win */
	EAX = cmd[12]; /* x0 */
	ECX = cmd[16]; /* y0 */
	if (EDX != 0) {
		(offset) cmd0418_win = (int) [ES:EDX + 8];
		EAX += cmd0418_win->x0;
		ECX += cmd0418_win->y0;
	}
	PUSH(ECX);
	PUSH(EAX);
	PUSH(cmd[ 4]);
	PUSH((int) 0x010c);

	PUSH(EBX);
	PUSH(ECX);
	PUSH(EAX);
	PUSH(ECX);
	PUSH(EAX);
	PUSH((int) 0); // opt(lock/bitset)
	PUSH((int) 0); // priority/handle
	PUSH((int) 0x0184); // accesslock
	EAX = cmd[20];
	ECX = cmd[24];
	(offset) cmd += 40;
	(int) [SS:ESP + 20] += EAX;
	(int) [SS:ESP + 24] += ECX;
	EBX = ESP;
	DB(0x9a); DD(0); DW((short) GAPI_sel);
	ESP += 84;
	goto nextcmd;

cmd041c:
	// points
	/* cmd, opt, window, x0, y0, xsize, ysize, lines, ofs, sel */
	GUIGUI_window_struct *cmd041c_win == DS:ESI;
	PUSH((int) 0x003c); // slot_sel
	PUSH((int) stack_sel);
	POP(DS); /* == stack_sel */
	POP(ES); /* == 0x003c */
	PUSH((int) 0);
	PUSH((int) 1); // opt(unlock/bitmode)
	EBX = ESP;
	PUSH((int) 0); // priority/handle
	PUSH((int) 0x0184); // accesslock

	PUSH(cmd[36]); /* sel */
	PUSH(cmd[32]); /* ofs */
	PUSH(cmd[28]); /* lines */
	PUSH(cmd[24]); /* ysize */
	PUSH(cmd[20]); /* xsize */
	EDX = cmd[ 8]; /* win */
	EAX = cmd[12]; /* x0 */
	ECX = cmd[16]; /* y0 */
	if (EDX != 0) {
		(offset) cmd041c_win = (int) [ES:EDX + 8];
		EAX += cmd041c_win->x0;
		ECX += cmd041c_win->y0;
	}
	PUSH(ECX);
	PUSH(EAX);
	PUSH(cmd[ 4]);
	PUSH((int) 0x0110);

	PUSH(EBX);
	PUSH(ECX);
	PUSH(EAX);
	PUSH(ECX);
	PUSH(EAX);
	PUSH((int) 0); // opt(lock/bitset)
	PUSH((int) 0); // priority/handle
	PUSH((int) 0x0184); // accesslock
	EAX = cmd[20];
	ECX = cmd[24];
	(offset) cmd += 40;
	(int) [SS:ESP + 20] += EAX;
	(int) [SS:ESP + 24] += ECX;
	EBX = ESP;
	DB(0x9a); DD(0); DW((short) GAPI_sel);
	ESP += 84;
	goto nextcmd;

cmd0420:
	// •¶š•\¦
	/* cmd, opt, ofs, sel, linebytes, col, bcol, charset, base, len, ofs, sel */

	/* cmd, opt, winslot, x, y, col, bcol, charset, base, len, ofs, sel */
	/* opt: bit24-25 > dw|by|wd|qw */ 
	int *cmd0420_stack == SS:ESP + 8;
	PUSH((int) 0x003c); // slot_sel
	PUSH((int) stack_sel);
	ESI = cmd[36]; /* length */
	POP(ES);
	LEA(EAX, [ESI * 4 + 40]);
	POP(DS);
	EDI = ESP;
	ESP -= EAX;
	PUSH((offset) cmd);
	PUSH(EDI); /* old ESP */
	EAX = cmd[ 4]; /* opt */
	EAX &= 0x00ffcfff;
	cmd0420_stack[ 0] = 0x0101; // put fonts
	cmd0420_stack[ 4] = EAX; // opt
	EAX = cmd[ 8]; /* ofs */
	ECX = cmd[12]; /* sel */
	EDX = cmd[16]; /* linebytes */
	cmd0420_stack[ 8] = EAX;
	cmd0420_stack[12] = ECX;
	EAX = cmd[20]; /* col */
	ECX = cmd[24]; /* bcol */
	cmd0420_stack[16] = EAX;
	cmd0420_stack[20] = ECX;
	cmd0420_stack[24] = EDX;
	EDI = cmd[28]; /* charset */
//	ESI = cmd[36];
	EDX = cmd[32]; /* base */
	asmout("LES EBX,GS:[EBP+40]");
	AH = cmd[ 5]; /* opt */
	LEA(EBP, cmd0420_stack[36]);
	AH &= 0x30;
	cmd0420_stack[32] = ESI; /* len */
	if (== 0)
		goto cmd0420_dword;
	if (AH == 0x10)
		goto cmd0420_byte;
	if (AH == 0x20)
		goto cmd0420_word;

INT(0x03);

#if 0
cmd0420_qword:
	do {
		/* EBX, EBP, ESI, EDI */
		EAX = (int) [ES:EBX];
		EBX += 8;
		EAX += EDX;
		/* local fontcode ‚ğ global fontaddr ‚É•ÏŠ·‚·‚é */
		PUSH(EDX);
		PUSH(EDI);
nextfont2_q:
		EAX -= [DS:EDI + 4 /* base */];
		if ((unsigned) < 0)
			goto nextfont_q;
		if ((unsigned) EAX >= [DS:EDI + 0] /* range */)
			goto nextfont_q;
		ECX = [DS:EDI + 8 /* conv */];
		EDX = ECX;
		ECX &= 0x0f;
		EDX &= 0xfffffff0;
		SHL(EAX, CL);
		POP(EDI);
		EAX += EDX;
		POP(EDX);
		(int) [SS:EBP] = EAX;
		EBP += 4;
		ESI--;
	} while (!= 0);
	goto cmd0420_final;

nextfont_q:
	EAX += [DS:EDI + 4 /* base */];
	EDI += 16;
	goto nextfont2_q;

#endif

cmd0420_dword:
	do {
		/* EBX, EBP, ESI, EDI */
		EAX = (int) [ES:EBX];
		EBX += 4;
		EAX += EDX;

		/* local fontcode ‚ğ global fontaddr ‚É•ÏŠ·‚·‚é */
		PUSH(EDX);
		PUSH(EDI);
nextfont4_d:
		EAX -= [DS:EDI + 4 /* base */];
		if ((unsigned) < 0)
			goto nextfont3_d;
		if ((unsigned) EAX >= [DS:EDI + 0] /* range */)
			goto nextfont3_d;
		ECX = [DS:EDI + 8 /* conv */];
		EDX = ECX;
		ECX &= 0x0f;
		EDX &= 0xfffffff0;
		SHL(EAX, CL);
		POP(EDI);
		EAX += EDX;
		POP(EDX);
		(int) [SS:EBP] = EAX;
		EBP += 4;
		ESI--;
	} while (!= 0);

cmd0420_final:
	(int) [SS:EBP + 0] = /* 0 */ ESI; // eoc
	LEA(EBX, [SS:ESP + 8]);
	DB(0x9a); DD(0); DW((short) GAPI_sel);
	POP(EDI);
	POP((offset) cmd);
	ESP = EDI;
	(offset) cmd += 48;
	goto nextcmd;

nextfont3_d:
	EAX += [DS:EDI + 4 /* base */];
	EDI += 16;
	goto nextfont4_d;

cmd0420_word:
	do {
		/* EBX, EBP, ESI, EDI */
		EAX = (unsigned short) [ES:EBX];
		EBX += 2;
		EAX += EDX;

		/* local fontcode ‚ğ global fontaddr ‚É•ÏŠ·‚·‚é */
		PUSH(EDX);
		PUSH(EDI);
nextfont4_w:
		EAX -= [DS:EDI + 4 /* base */];
		if ((unsigned) < 0)
			goto nextfont3_w;
		if ((unsigned) EAX >= [DS:EDI + 0] /* range */)
			goto nextfont3_w;
		ECX = [DS:EDI + 8 /* conv */];
		EDX = ECX;
		ECX &= 0x0f;
		EDX &= 0xfffffff0;
		SHL(EAX, CL);
		POP(EDI);
		EAX += EDX;
		POP(EDX);
		(int) [SS:EBP] = EAX;
		EBP += 4;
		ESI--;
	} while (!= 0);
	goto cmd0420_final;

nextfont3_w:
	EAX += [DS:EDI + 4 /* base */];
	EDI += 16;
	goto nextfont4_w;

cmd0420_byte:
	do {
		/* EBX, EBP, ESI, EDI */
		EAX = (unsigned char) [ES:EBX];
		EBX++;
		EAX += EDX;

		/* local fontcode ‚ğ global fontaddr ‚É•ÏŠ·‚·‚é */
		PUSH(EDX);
		PUSH(EDI);
nextfont4_b:
		EAX -= [DS:EDI + 4 /* base */];
		if ((unsigned) < 0)
			goto nextfont3_b;
		if ((unsigned) EAX >= [DS:EDI + 0] /* range */)
			goto nextfont3_b;
		ECX = [DS:EDI + 8 /* conv */];
		EDX = ECX;
		ECX &= 0x0f;
		EDX &= 0xfffffff0;
		SHL(EAX, CL);
		POP(EDI);
		EAX += EDX;
		POP(EDX);
		(int) [SS:EBP] = EAX;
		EBP += 4;
		ESI--;
	} while (!= 0);
	goto cmd0420_final;

nextfont3_b:
	EAX += [DS:EDI + 4 /* base */];
	EDI += 16;
	goto nextfont4_b;

cmd0510:
	// define signal
	// cmd, opt, default[12](dev, code, win), msgbox, len, signal[8], far *purpose
	// 16 * 256 = 4KB(Å‘å3dw)
//	PUSH(SS);
	PUSH((int) 0x003c /* slot_sel */);
	EDX = cmd[16]; // win slot
	POP(DS); /* == 0x003c */
//	POP(DS); /* == SS */
	EAX = (int) [DS:EDX + 8]; // win

	if (cmd[8] == 0x0100) {
		// ƒEƒBƒ“ƒhƒE˜A“®ƒfƒoƒCƒXw’è(to winman0)
		PUSH((int) 0);
		PUSH(cmd[32]); // signal
		PUSH(cmd[28]); // signal
		PUSH(cmd[24]); // len
		PUSH(cmd[12]); // code
		PUSH(cmd[ 8]); // device
		PUSH((int) 0 /* signalbox...0‚È‚çwindow‚Æ“¯‚¶ */);
		PUSH(EAX);
		PUSH(cmd[ 4]); // opt(bit31‚ª0‚¾‚ÆApurpose‚Í‚È‚µ)
		PUSH((int) 0x002c); // signalİ’è
		PUSH((int) 0x7f000009);
		PUSH((int) 0x3240 + 10);
		PUSH((int) 0x0128 /* ƒRƒ}ƒ“ƒhƒVƒOƒiƒ‹’¼Ú(with wait) */);
		EBX = ESP;
		CALLFAR0(tapi_sel);
		ESP += 52;
	} else if (cmd[8] == 0x0200) {
		EBX = cmd[12];
		if (BL == 0x10)
			goto cmd0510_skip;
		if (BL == 0x12) {
cmd0510_skip:
			EBX = cmd[28];
			PUSH((int) 0);
			EBX += 2;
			PUSH(cmd[32]); // signal
			PUSH(EBX); // signal
			PUSH(cmd[24]); // len
			PUSH(29);
			PUSH(8);
			PUSH(cmd[12]); // code
			PUSH(cmd[ 8]); // device
			PUSH((int) 0 /* signalbox...0‚È‚çwindow‚Æ“¯‚¶ */);
			PUSH(EAX);
	//		PUSH(cmd[ 4]); // opt(bit31‚ª0‚¾‚ÆApurpose‚Í‚È‚µ)
			PUSH((int) 0x0030); // signalİ’è
			PUSH((int) 0x7f00000a);
			PUSH((int) 0x3240 + 11);
			PUSH((int) 0x0128 /* ƒRƒ}ƒ“ƒhƒVƒOƒiƒ‹’¼Ú(with wait) */);
			EBX = ESP;
			CALLFAR0(tapi_sel);
			ESP += 48 + 8;
			(offset) cmd += 44;
			goto nextcmd;
		}
		// ƒEƒBƒ“ƒhƒE˜A“®ƒfƒoƒCƒXw’è(to winman0)
		PUSH((int) 0);
		PUSH(cmd[32]); // signal
		PUSH(cmd[28]); // signal
		PUSH(cmd[24]); // len
		PUSH(cmd[12]); // code
		PUSH(cmd[ 8]); // device
		PUSH((int) 0 /* signalbox...0‚È‚çwindow‚Æ“¯‚¶ */);
		PUSH(EAX);
//		PUSH(cmd[ 4]); // opt(bit31‚ª0‚¾‚ÆApurpose‚Í‚È‚µ)
		PUSH((int) 0x0030); // signalİ’è
		PUSH((int) 0x7f000008);
		PUSH((int) 0x3240 + 9);
		PUSH((int) 0x0128 /* ƒRƒ}ƒ“ƒhƒVƒOƒiƒ‹’¼Ú(with wait) */);
		EBX = ESP;
		CALLFAR0(tapi_sel);
		ESP += 48;
	}
	(offset) cmd += 44;
	goto nextcmd;

cmd0600:
	// ƒTƒEƒ“ƒh‰Šú‰»(ƒgƒ‰ƒbƒNƒI[ƒvƒ“ƒRƒ}ƒ“ƒh‘—M)
	// opt(track-no), reserve
	// track-no‚Íslot‚É‚·‚é
	PUSH((int) 0x003c); // slot_sel
	EDX = cmd[4];
	POP(DS);
	TEST(DL, 0x01);
	if (== 0) {
		PUSH((int) tapiwork_sel);
		(int) [DS:EDX + 12] = 0x0110; /* sound track mark */
		POP(ES);
		PUSH((int) 0); // eoc
		PUSH((int) 0); // reserve1
		PUSH(cmd[8]); // reserve0
		PUSH((int) 0x00c0); // signal-base
		PUSH((int) [ES:0x000c]); // tss
		PUSH(EDX); // slot
		PUSH((int) 0x0040); // command(open sound track)
		PUSH((int) 0x7f000006);
		PUSH((int) 0x3240 /* winman0 */ + 7);
		PUSH((int) 0x0128 /* ƒRƒ}ƒ“ƒhƒVƒOƒiƒ‹’¼Ú(with wait) */);
		EBX = ESP;
		CALLFAR0(tapi_sel);
		ESP += 40;

		// ‚±‚±‚Åo‚µ‚½ƒVƒOƒiƒ‹‚Ì•Ô“š‚ğpioneer0‚Éˆ—‚³‚¹‚é‚Ì‚ÍA
		// ŠT”OãA‘å‚«‚È–â‘è‚Å‚ ‚éB‚µ‚©‚µA‚®‚¢‚®‚¢01‚Ü‚Å‰ü³‚Å‚«‚È‚¢B...‚¢‚âAƒVƒXƒeƒ€ƒVƒOƒiƒ‹‚Å‰ü³‚Å‚«‚é
	
		(offset) cmd += 12;
		goto nextcmd;
	}
	EDX &= 0xfffffff0; // pioneer0Œo—R‚Åó‚¯æ‚Á‚½winman0‚©‚ç‚ÌƒVƒOƒiƒ‹
	EAX = cmd[8];
	(offset) cmd += 12;
	ECX = 0;
	(int) [DS:EDX + 8] = EAX; // bit0‚ÍA0(disable)
	(int) [DS:EDX + 0] = ECX; // –³‰¹
	(int) [DS:EDX + 4] = ECX; // –³‰¹
	goto nextcmd;

cmd0604:
	// ƒTƒEƒ“ƒhI—¹(close sound)
	// opt(track-no)
	PUSH((int) 0x003c); // slot_sel
	EDX = cmd[4];
	POP(DS);
	EDX = [DS:EDX + 8]; /* system-ID */
	TEST(DL, 0x01);
	if (!= 0) { /* g—p’†‚¾‚Á‚½‚çAÁ‰¹‚·‚é */
		PUSHFD();
		CLI();
		#if (defined(PCAT))
			IN(AL, 0x0061);
			AL &= 0x0d;
			AL |= 0x01;
			OUT(0x0061, AL);
		#endif
		#if (defined(TOWNS))
			IN(AL, 0x0060);
			AL >>= 2;
			AL &= 0x03;
			OUT(0x0060, AL);
		#endif
		#if (defined(NEC98))
			AL = 0x07;
			OUT(0x0037, AL);
		#endif
		POPFD();
	}
	EDX &= 0xffffffe;
	PUSH((int) 0);
	PUSH(EDX); // slot
	PUSH((int) 0x0044); // command(close sound track)
	PUSH((int) 0x7f000002);
	PUSH((int) 0x3240 /* winman0 */ + 3);
	PUSH((int) 0x0128 /* ƒRƒ}ƒ“ƒhƒVƒOƒiƒ‹’¼Ú(with wait) */);
	EBX = ESP;
	CALLFAR0(tapi_sel);
	ESP += 24;
	goto nextcmd;

cmd0608:
	// enable/disable sound track
	// opt(track-no) : bit0 ‚Í enbale-bit
	// track-no‚Íslot‚É‚·‚é
	PUSH((int) 0x003c); // slot_sel
	EDX = cmd[4];
	(offset) cmd += 8;
	POP(DS);
	ECX = EDX;
	EDX &= 0xfffffff0;
	CL &= 0x01;
	if (!= 0) {
		(char) [DS:EDX + 8] |= 0x01;
		EAX = [DS:EDX + 0];
		goto cmd0608_enable;
	}
	INT(0x03); // –³‰¹‚É‚µ‚ÄAdisableó—‚ğ“`‚¦‚é

//	goto nextcmd;

cmd060c:
	/* üŠúw’è(0:‚ÅÁ‰¹) */
	/* 2e-32sec’PˆÊ */
	/* 440.000014Hz (9761289) O4A */
	/* opt(track-no), time */
	PUSH((int) 0x003c); /* slot_sel */
	EDX = cmd[4];
	POP(DS);
	EAX = cmd[8];
	CL = [DS:EDX + 8];
	(offset) cmd += 12;
	TEST(CL, 0x01);
	[DS:EDX + 0] = EAX;
	if (!= 0) {
cmd0608_enable:
		if (EAX == 0) {
			PUSHFD();
			CLI();
			#if (defined(PCAT))
				IN(AL, 0x0061);
				AL &= 0x0d;
				AL |= 0x01;
			//	AL &= 0x0e;
			//	AL |= 0x02;
				OUT(0x0061, AL);
			#endif
			#if (defined(TOWNS))
				IN(AL, 0x0060);
				AL >>= 2;
				AL &= 0x03;
				OUT(0x0060, AL);
			#endif
			#if (defined(NEC98))
				AL = 0x07;
				OUT(0x0037, AL);
			#endif
			POPFD();
			goto nextcmd;
		}
		/* ‰¹‚ğo‚· */
		#if (defined(PCAT))
			ECX = 1193180;
		#endif
		#if (defined(TOWNS))
			ECX = 307200;
		#endif
		#if (defined(NEC98))
			PUSH(EAX);
			IN(AL, 0x0042);
			ECX = 2457600; /* 5MHzŒn */
			TEST(AL, 0x20);
			if (!= 0) {
				/* 8MHzŒn */
				ECX = 1996800;
			}
			POP(EAX);
		#endif
		MUL(ECX);
		(unsigned int) EAX >>= 31; /* EAX‚ÌMSB‚ğLSB‚Ö */
	//	ECX = EAX + EDX;
		LEA(ECX, [EAX + EDX]);
		if ((unsigned) ECX >= 0x10000)
			ECX = 0; // 18.201Hz
		PUSHFD();
		CLI();
		#if (defined(PCAT))
			AL = 0xb6 /* 10110110B */;
			OUT(0x0043, AL);
			AL = CL;
			OUT(0x0042, AL);
			AL = CH;
			OUT(0x0042, AL);
			NOP();
			IN(AL, 0x0061);
			AL &= 0x0f;
			AL |= 0x03;
			OUT(0x0061, AL);
		#endif
		#if (defined(TOWNS))
			AL = 0xb6 /* 10110110B */;
			OUT(0x0046, AL);
			AL = CL;
			OUT(0x0044, AL);
			AL = CH;
			OUT(0x0044, AL);
			NOP();
			IN(AL, 0x0060);
			AL >>= 2;
			AL &= 0x07;
			AL |= 0x04;
			OUT(0x0060, AL);
		#endif
		#if (defined(NEC98))
			AL = 0xb6 /* 10110110B */;
			EDX = 0x3fdb;
			OUT(0x0077, AL);
			AL = CL;
			OUT(DX, AL);
			AL = CH;
			OUT(DX, AL);
			AL = 0x06;
			OUT(0x0037, AL);
		#endif
		POPFD();
	}
	goto nextcmd;

cmd0700:
	/* ƒtƒ@ƒCƒ‹ƒnƒ“ƒhƒ‹‰Šú‰» */
	/* cmd, opt, slot */
	PUSH((int) 0x003c); /* slot_sel */
	PUSH((int) tapiwork_sel);
	POP(DS);
	POP(ES);
	EAX = cmd[4];
	EDX = cmd[8]; /* slot */
	(offset) cmd += 12;
	if (EAX < 0x00e0) {
		/* pokon‚É [0x7f000002, 0x008c, task | slot] ‚ğ‘—‚é */
		/* 0x00e0ˆÈ~‚ÍƒLƒƒƒ“ƒZƒ‹‚ª‚ ‚è‚¤‚é‚Ì‚ÅA‚¢‚¶‚ç‚È‚¢ */
		ESI = [DS:0x000c /* tskptr */];
		ESI |= EDX;
		PUSH((int) 0);
		PUSH(ESI); // slot
		PUSH((int) 0x008c); // command(SIGNAL_FREE_FILES)
		PUSH((int) 0x7f000002);
		PUSH((int) 0x4240 /* pokon0 */ + 3);
		PUSH((int) 0x0128 /* ƒRƒ}ƒ“ƒhƒVƒOƒiƒ‹’¼Ú(with wait) */);
		EBX = ESP;
		CALLFAR0(tapi_sel);
		ESP += 24;
	}
	if (EAX == 4 /* ƒ^ƒXƒNƒfƒBƒŒƒNƒgƒŠ */) {
		ESI = [DS:0x000c /* tskptr */];
		int *cmd0700_tss_sysdat == DS:ESI + 748; /* 20ƒoƒCƒg */
		EAX = cmd0700_tss_sysdat[0]; /* tskdir */
		[ES:EDX + 0] = EAX;
		goto nextcmd;
	}
	if (EAX == 12 /* ƒ}ƒVƒ“ƒfƒBƒŒƒNƒgƒŠ */) {
cmd0700_machine:
		EAX = 0;
		EAX--;
		[ES:EDX + 0] = EAX;
		goto nextcmd;
	}
	if (EAX == 8 /* ƒ†[ƒU[ƒfƒBƒŒƒNƒgƒŠ */)
		goto cmd0700_machine;
	if (EAX == 64 /* ƒ‹[ƒg(‰¼) */) {
		(int) [ES:EDX + 0] = 1024;
		goto nextcmd;
	}
	if ((unsigned) EAX >= 0x00e0 /* ƒ_ƒCƒAƒƒO“™‚ğo‚µ‚Ä‘I‘ğ‚³‚¹‚é */) {
		/* ƒTƒuƒRƒ}ƒ“ƒh‚ªŒp‘±‚µ‚Ä‚¢‚é */
		/* ƒTƒuƒRƒ}ƒ“ƒh‚É‚ÍA×‚©‚¢‘®«‚ª‘‚©‚ê‚Ä‚¢‚é */
		/* Š®—¹‚·‚é‚ÆAƒVƒOƒiƒ‹‚ª—ˆ‚é */
		/* pokon0‚ÉƒVƒOƒiƒ‹‚ğ‘—‚é */
		/* 0x7f000006, sig, task, slot, bytes, ofs, sel */
		PUSH((int) 0);
		PUSH(cmd[8] /* sel */);
		PUSH(cmd[4] /* ofs */);
		PUSH(cmd[0] /* bytes */);
		PUSH(EDX /* slot */);
		PUSH((int) [DS:0x000c /* tskptr */]);
		PUSH((int) 0x0084 /* fileselect */);
		PUSH((int) 0x7f000006);
		PUSH((int) 0x4240 /* pokon0 */ + 7);
		PUSH((int) 0x0128 /* ƒRƒ}ƒ“ƒhƒVƒOƒiƒ‹’¼Ú(with wait) */);
		(offset) cmd += 12;
		EBX = ESP;
		CALLFAR0(tapi_sel);
		ESP += 40;
		goto nextcmd;
	}
	INT(0x03);

cmd0708:
	/* ƒRƒs[ƒnƒ“ƒhƒ‹ */
	/* cmd, opt, slot(dest), slot(src) */
	PUSH((int) 0x003c); /* slot_sel */
	POP(DS);
	ECX = cmd[12];
	EDX = cmd[ 8]; /* slot */
	(offset) cmd += 16;
	EAX = [DS:ECX + 0];
	[DS:EDX + 0] = EAX;
	goto nextcmd;

cmd070c:
	/* ƒfƒBƒŒƒNƒgƒŠˆÚ“® */
	/* cmd, opt, slot, bytes, ofs, sel */
	/* Š®—¹‚µ‚½ê‡‚àŒ©•t‚©‚ç‚È‚¢ê‡‚àAƒVƒOƒiƒ‹‚Å’m‚ç‚¹‚é */
	/* opt‚Ìbit0‚Í‹­§ˆÚ“®ƒrƒbƒg */

	PUSH((int) tapiwork_sel);
	POP(DS);

	EAX = cmd[12]; /* bytes */
	TEST((char) cmd[4], 0x01);
	if (!= 0)
		EAX |= 0x80000000;
	/* 0x7f000006, sig, task, slot, bytes, ofs, sel */
	PUSH((int) 0);
	PUSH(cmd[20] /* sel */);
	PUSH(cmd[16] /* ofs */);
	PUSH(EAX /* bytes */);
	PUSH(cmd[ 8] /* slot */);
	PUSH((int) [DS:0x000c /* tskptr */]);
	PUSH((int) 0x0088 /* steppath */);
	PUSH((int) 0x7f000006);
	PUSH((int) 0x4240 /* pokon0 */ + 7);
	PUSH((int) 0x0128 /* ƒRƒ}ƒ“ƒhƒVƒOƒiƒ‹’¼Ú(with wait) */);
	(offset) cmd += 24;
	EBX = ESP;
	CALLFAR0(tapi_sel);
	ESP += 40;
	goto nextcmd;

#if 0

cmd070c:
	/* ƒfƒBƒŒƒNƒgƒŠˆÚ“® */
	/* cmd, opt, slot, tag0, tag1, ..., -1 */
	/* Œ©•t‚©‚ç‚È‚¢ê‡Aopt‚Ìbit0‚ª1‚È‚çAbit0‚ªƒNƒŠƒA‚³‚ê‚é
		opt‚Ìbit0‚ªÅ‰‚©‚ç0‚¾‚Á‚½‚çAƒGƒ‰[ */
	EAX = 0x003c; /* slot_sel */
	ECX = root_sel;
	EDX = cmd[8];
	ES = AX;
	DS = CX;
	ESI = [ES:EDX + 0];
	PUSH(EDX);
	EAX = 0xffe00040;
	ESI += 16;
	search_tag_EAX();
	EBX = [DS:ESI + 16];
	EBX += 16;
	ESI = [DS:EBX];
	(offset) cmd += 12;
	if (ESI != 0xffffffff) {
		PUSH((offset) cmd);
		do {
			ESI += 16;
			(offset) cmd = [SS:ESP];
			PUSH(ESI);
			EAX = cmd[0];
			do {
				ESI = [SS:ESP];
				search_tag_EAX();
				ECX = cmd[4];
				if (ZF == 0) /* ‚»‚Ìƒ^ƒO‚·‚çŒ©•t‚©‚ç‚È‚¢ */
					goto cmd070c_next;
				if (ECX != [DS:ESI + 4])
					goto cmd070c_next; /* ’·‚³‚ªˆá‚¤ */
				(offset) cmd += 8;
				ESI += 8;
				ECX -= 8;
				if (!= 0) {
					do {
						EAX = *cmd;
						cmd += 4;
						if (EAX != [DS:ESI])
							goto cmd070c_next;
						ESI += 4;
						ECX -= 4;
					} while (!= 0);
				}
				EAX = cmd[0];
			} while (EAX != 0xffffffff);

			/* Œ©‚Â‚¯‚½ */
			EAX = [DS:EBX];
			POP(ESI); /* ESP += 4;‚Ì‘ã‚í‚è */
			POP(EBX /* old cmd + 12 */);
			POP(EDX);
			(offset) cmd += 4;
			asmout("TEST BYTE PTR GS:[EBX-8],02H");
			if (!= 0)
				goto nextcmd;
			[ES:EDX + 0] = EAX;
			goto nextcmd;

cmd070c_next:
			EBX += 4;
			POP(EAX); /* old ESI */
			ESI = [DS:EBX];
		} while (ESI != 0xffffffff);
	}
	/* Œ©•t‚©‚ç‚È‚©‚Á‚½ */
	POP((offset) cmd) /* old cmd + 12 */;
	EAX = cmd[-8];
	POP(ECX); /* old EDX */
	TEST(AL, 0x01);
	if (== 0) {
		INT(0x03); /* Œ©•t‚©‚ç‚È‚©‚Á‚½ */
	}
	EAX &= 0xfffffffe;
	cmd[-8] = EAX;
	do {
		(offset) cmd += cmd[4];
	} while (cmd[0] != 0xffffffff);
	(offset) cmd += 4;
	goto nextcmd;

#endif

cmd0710:
	/* create new module */
	/* cmd, opt, slot(dir), slot(module), tag-dir alloc-size, tag0, tag1, ..., -1 */
	ESP -= 512;
	PUSH((int) 0x003c); /* slot_sel */
	POP(ES);
	EAX = cmd[ 8]; /* slot(dir) */
	ECX = cmd[12]; /* slot(module) */
	EDX = cmd[16]; /* tagdir allocsize */
	TEST(ECX, ECX);
	EAX = [ES:EAX + 0];
	[SS:ESP + 496] = EAX;
	MOV(EAX, GS);
	[SS:ESP + 500] = ECX;
	[SS:ESP + 504] = EDX;
	[SS:ESP + 508] = EAX;
	DS = AX;
	LEA(ESI, [SS:EBP + 20]);
	EBP = ESP;
	EAX = [DS:ESI];
	do {
		ECX = [DS:ESI + 4];
		[SS:EBP] = EAX;
		[SS:EBP + 4] = ECX;
		if (EAX == 0xffe00003)
			goto cmd0710_ffe00003;
		ESI += 8;
		EBP += 8;
		ECX -= 8;
		if (!= 0) {
			do {
				EAX = [DS:ESI];
				ESI += 4;
				[SS:EBP] = EAX;
				EBP += 4;
				ECX -= 4;
			} while (!= 0);
		}
cmd0710_next:
		EAX = [DS:ESI];
	} while (EAX != 0xffffffff);
	PUSH((int) root_sel);
	[SS:EBP] = EAX;
	POP(DS);
	[SS:EBP + 4] = EAX;
	ECX = [SS:ESP + 504];
	LEA(EBP, [ESI + 4]);
	ESI = 512;
	alloc_tagdir();
	EBX = ESP;
	PUSH(SS);
	POP(GS);
	add_tags();
	GS = [SS:ESP + 508];
	EDX = [SS:ESP + 500];
	EBX = [SS:ESP + 496];
	if (EDX != 0)
		[ES:EDX + 0] = EDI;
	regist_module();
	ESP += 512;
	goto nextcmd;

cmd0710_ffe00003:
	ECX = [DS:ESI + 16]; /* allocsize */
	get_memory(); /* EAX‚ğ•Ô‚· */
	if (ZF == 1)
		INT(0x03);
	[SS:EBP + 16] = ECX;
	[SS:EBP + 24] = EAX;
	EAX = [DS:ESI +  8]; /* usedsize */
	ESI += 32;
	[SS:EBP +  8] = EAX;
	EBP += 32;
	goto cmd0710_next;

cmd0720:
	/* map module */
	PUSH((int) tapiwork_sel);
	ECX = cmd[20]; /* opt(sel) */
	POP(DS);
	ECX &= 0x0000fff8;
	ESI = [DS:0x000c] /* tskptr */;
	EAX = cmd[8]; /* slot */
	int *cmd0710_tss_ldt == DS:ESI + 2048;
	asmout("LEA ECX,[ECX+ESI+2048]");
	DL = [DS:ECX + 4];
	DH = [DS:ECX + 7];
	EDX <<= 16;
	DX = [DS:ECX + 2];
	PUSH((int) 0x003c /* slot_sel */);
	POP(DS);

if (ESI == 0x5000) {
	ESI = [DS:EAX + 0];
	PUSH((int) root_sel);
	ESI += 16;
	POP(DS);
	EAX = 0xffe00003;
	search_tag_EAX();
	EAX = [DS:ESI + 24 /* æ“ª•¨—ƒAƒhƒŒƒX */];
	EDI = [DS:ESI + 28];

//	[DS:ESI + 16 /* ƒ‚ƒWƒ…[ƒ‹ƒTƒCƒY */];
	EAX += cmd[24] /* ofs & attr */;
	ADC(EDI, 0);
	EDX += cmd[16] /* linear addr ofs */;
	ECX = EAX;
	EAX &= 0xfffff000;
	ECX &= 0x00001fff;
	ECX |= 0x00001000;

	EBX = 0;
//	if (EBX != [DS:ESI + 16] /* ƒ‚ƒWƒ…[ƒ‹ƒTƒCƒY */) {
		PUSH((int) EBX /* eoc */);
		PUSH((int) EDI /* addr64(high) */);
		PUSH((int) EAX /* addr64(low) */);
		PUSH((int) EBX /* offset64(high) */);
		PUSH((int) EBX /* offset64(low) */);
		PUSH((int) EBX /* pageset */);
		PUSH((int) EDX /* linear */);

EDI = cmd[24]; /* ofs */
EAX = cmd[12];
EDI &= 0xfffff000;
EBX = [DS:ESI + 16 /* ƒ‚ƒWƒ…[ƒ‹ƒTƒCƒY */];
EBX -= EDI;
if ((unsigned) < 0)
	EBX = 0;
if ((unsigned) EAX > EBX)
	EAX = EBX;
EAX += 0xfff;
EAX &= 0xfffff000;
if (== 0) {
	ESP += 28;
	(offset) cmd += 28;
	goto nextcmd;
}
PUSH(EAX);

	//	PUSH((int) cmd[12] /* size */);
		PUSH((int) ECX /* opt(over-mapping, present, R/W, user) */);
		PUSH((int) 0x0108 /* cmd(mapping) */);
		EBX = ESP;
		CALLFAR0(papi_sel);
		ESP += 40;
//	}

	(offset) cmd += 28;
	goto nextcmd;



}


	ESI = [DS:EAX + 0];
	PUSH((int) root_sel);
	ESI += 16;
	POP(DS);
	EAX = 0xffe00003;
	search_tag_EAX();
	EAX = [DS:ESI + 24 /* æ“ª•¨—ƒAƒhƒŒƒX */];
	EDI = [DS:ESI + 28];

//	[DS:ESI + 16 /* ƒ‚ƒWƒ…[ƒ‹ƒTƒCƒY */];
	EAX += cmd[24] /* ofs & attr */;
	ADC(EDI, 0);
	EDX += cmd[16] /* linear addr ofs */;
	ECX = EAX;
	EAX &= 0xfffff000;
	ECX &= 0x00001fff;
	ECX |= 0x00001000;

	EBX = 0;
//	if (EBX != [DS:ESI + 16] /* ƒ‚ƒWƒ…[ƒ‹ƒTƒCƒY */) {
		PUSH((int) EBX /* eoc */);
		PUSH((int) EDI /* addr64(high) */);
		PUSH((int) EAX /* addr64(low) */);
		PUSH((int) EBX /* offset64(high) */);
		PUSH((int) EBX /* offset64(low) */);
		PUSH((int) EBX /* pageset */);
		PUSH((int) EDX /* linear */);

EDI = cmd[24]; /* ofs */
EAX = cmd[12];
EDI &= 0xfffff000;
EBX = [DS:ESI + 16 /* ƒ‚ƒWƒ…[ƒ‹ƒTƒCƒY */];
EBX -= EDI;
if ((unsigned) < 0)
	EBX = 0;
if ((unsigned) EAX > EBX)
	EAX = EBX;
EAX += 0xfff;
EAX &= 0xfffff000;
if (== 0) {
	ESP += 28;
	(offset) cmd += 28;
	goto nextcmd;
}
PUSH(EAX);

	//	PUSH((int) cmd[12] /* size */);
		PUSH((int) ECX /* opt(over-mapping, present, R/W, user) */);
		PUSH((int) 0x0108 /* cmd(mapping) */);
		EBX = ESP;
		CALLFAR0(papi_sel);
		ESP += 40;
//	}

	(offset) cmd += 28;
	goto nextcmd;

cmd0728:
	/* read tag */
	/* cmd, opt, slot(not dir), bufsize, bufptr(far) */
	/* opt‚ª 0xffffff00‚æ‚è‘å‚«‚¯‚ê‚ÎAƒJƒXƒ^ƒ€ƒtƒH[ƒ}ƒbƒg */
	/* 02:ƒ‚ƒWƒ…[ƒ‹ƒ^ƒCƒvƒR[ƒh(8ƒoƒCƒg)‚Ì‚İ */
	/* 03:ƒ‚ƒWƒ…[ƒ‹ƒTƒCƒY(16ƒoƒCƒg)‚Ì‚İ */
	EAX = 0x003c; /* slot_sel */
	ECX = root_sel;
	EDX = cmd[8];
	EBX = cmd[4];
	ES = AX;
	DS = CX;
	ESI = [ES:EDX + 0];
	asmout("LES EDI,DWORD GS:[EBP+16]");
	ESI += 16;
	(offset) cmd += 24;
	if (EBX == 0xffffff03) {
		EAX = 0xffe00003;
		search_tag_EAX();
		if (ZF == 0)
			INT(0x03);
		EAX = [DS:ESI +  8];
		ECX = [DS:ESI + 12];
		EDX = [DS:ESI + 16];
		EBX = [DS:ESI + 20];
		[ES:EDI +  0] = EAX;
		[ES:EDI +  4] = ECX;
		[ES:EDI +  8] = EDX;
		[ES:EDI + 12] = EBX;
		goto nextcmd;
	}
	if (EBX == 0xffffff02) {
		EAX = 0xffe00002;
		search_tag_EAX();
		if (ZF == 0)
			INT(0x03);
		EAX = [DS:ESI +  8];
		ECX = [DS:ESI + 12];
		[ES:EDI +  0] = EAX;
		[ES:EDI +  4] = ECX;
		goto nextcmd;
	}
	INT(0x03);

cmd0730:
	/* tag listing */
	/* cmd, opt, slot(dir), bufsize, bufptr(far) */
	/* opt‚ª 0xffffff00‚æ‚è‘å‚«‚¯‚ê‚ÎAƒJƒXƒ^ƒ€ƒtƒH[ƒ}ƒbƒg */
	/* 00:ƒ‚ƒWƒ…[ƒ‹ƒl[ƒ€‚Ì‚İ */
	EAX = 0x003c; /* slot_sel */
	ECX = root_sel;
	EDX = cmd[8];
	ES = AX;
	DS = CX;
	ESI = [ES:EDX + 0];
	EAX = 0xffe00040;
	ESI += 16;
	search_tag_EAX();
	EBX = [DS:ESI + 16];
	EBX += 16;
	ESI = [DS:EBX];
	asmout("LES EDI,DWORD GS:[EBP+16]");
	(offset) cmd += 24;
	if (ESI != 0xffffffff) {
		do {
			EBX += 4;
			ESI += 16;
			EAX = 0xffe00000 /* name */;
			search_tag_EAX();
			ECX = [DS:ESI + 4];
			if (ZF == 0) /* ‚»‚Ìƒ^ƒO‚·‚çŒ©•t‚©‚ç‚È‚¢ */
				INT(0x03);
			ECX -= 4;
			ESI += 8;
			[ES:EDI] = ECX;
			EDI += 4;
			ECX -= 4;
			if (!= 0) {
				do {
					EAX = [DS:ESI];
					ESI += 4;
					[ES:EDI] = EAX;
					EDI += 4;
					ECX -= 4;
				} while ((unsigned) > 0);
			}
			ESI = [DS:EBX];
		} while (ESI != 0xffffffff);
	}
	(int) [ES:EDI] = 0;
	goto nextcmd;

cmd0740:
	/* resize file */
	/* cmd, opt, slot, new-size(bytes), siglen(1), sig */

	PUSH((int) tapiwork_sel);
	POP(DS);
	EDX = cmd[ 8];

	/* 0x7f000006, cmd, virtualmodule, new-size, task, sig, slot */
	PUSH((int) 0);
	PUSH(EDX);
	PUSH(cmd[20] /* sig */);
	PUSH((int) [DS:0x000c /* tskptr */]);

	PUSH((int) 0x003c /* slot_sel */);
	POP(DS);

	PUSH(cmd[12] /* new-size */);
	PUSH((int) [DS:EDX]);
	PUSH((int) 0x008d);
	PUSH((int) 0x7f000006);
	PUSH((int) 0x4240 /* pokon0 */ + 7);
	PUSH((int) 0x0128 /* ƒRƒ}ƒ“ƒhƒVƒOƒiƒ‹’¼Ú(with wait) */);
	(offset) cmd += 24;
	EBX = ESP;
	CALLFAR0(tapi_sel);
	ESP += 40;
	goto nextcmd;


cmd0ffffffff:
	// magic command

	ESP -= 512;
	(int) [SS:ESP     ] = 0x0101;
	EAX = cmd[ 4];
	EAX *= 16;
	EAX += 4096;
	(int) [SS:ESP +  4] = 0;
	(int) [SS:ESP +  8] = 0;
	(int) [SS:ESP + 12] = 0;
	(int) [SS:ESP + 16] = 15;
	(int) [SS:ESP + 20] = 0;
	(int) [SS:ESP + 24] = 0;
//	(int) [SS:ESP + 28] = ankfont_sel;
	(int) [SS:ESP + 32] = 1;
	(int) [SS:ESP + 36] = EAX;
	(int) [SS:ESP + 40] = 0x0000;

	EBX = ESP;
	DB(0x9a); DD(0); DW((short) GAPI_sel);
	ESP += 512;

#if 0
	/*	ƒVƒXƒeƒ€ƒ^ƒCƒ}[ƒm[ƒh‚Ìó‹µŠm”F */
	EAX = 0x003c; /* slot_sel */
	DS = AX;
	ECX = (int) [DS:0x01c0];
	EAX = timerdata_sel;
	DS = AX;
	EAX = (int) [DS:ECX + 56];
	INT(0x03);
#endif

	(offset) cmd += 20;
	goto nextcmd;
}

void far GUIGUI_shellcall2()
{
	unsigned int                         all_sel       ==  1 * 8;
	unsigned int init_sel     ==  2 * 8, syswork_sel   ==  3 * 8;
	unsigned int GAPI_sel     ==  4 * 8, GAPIwork_sel  ==  5 * 8;
	unsigned int stack_sel    ==  6 * 8, ankfont_sel   ==  7 * 8;
	unsigned int keyint_sel   ==  8 * 8, keydata_sel   ==  9 * 8;
	unsigned int timerint_sel == 10 * 8, timerdata_sel == 11 * 8;
	unsigned int tapi_sel     == 12 * 8, tapiwork_sel  == 13 * 8;
	unsigned int tss386_0_sel == 14 * 8, idtgdt_sel    == 15 * 8;
	unsigned int root_sel     == 16 * 8, tmp_sel       == 17 * 8;
	unsigned int papi_sel     == 18 * 8, papiwork_sel  == 19 * 8;
	unsigned int decode_sel   == 22 * 8, decowork_sel  == 23 * 8;
	unsigned int fdcdrive_sel == 28 * 8, fdcwork_sel   == 29 * 8;
	unsigned int diskbuf_sel  == 30 * 8, textbuf_sel   == 31 * 8;
	unsigned int freegdt_sel  == 32 * 8;

	int *cmd == FS:EBX;

	/* lv3‚©‚ç‚Ìi“ü‚Ì‰Â”\«‚ª‚ ‚é‚Ì‚ÅAƒJƒEƒ“ƒg‚ğ‘‚â‚·B */
	(char) [SS:0xffffffe0]++;

	PUSH(DS);
	PUSH(ES);
	PUSHAD();

nextcmd:
	EAX = cmd[0];
	if (EAX == 0)
		goto cmd0000;
	if (EAX == 0x0010)
		goto cmd0010; /* ƒVƒXƒeƒ€ƒI[ƒvƒ“ */
	if (EAX == 0x0020)
		goto cmd0020; /* send signal */
	if (EAX == 0x0028)
		goto cmd0028; /* get window param(b’èƒRƒ}ƒ“ƒh) */
	if (EAX == 0x002c)
		goto cmd002c; /* put window param(b’èƒRƒ}ƒ“ƒh) */
//	if (EAX == 0x0030)
//		goto cmd0030; /* define signal direct */
	if (EAX == 0x0034)
		goto cmd0034; /* report memory status */
	if (EAX == 0x0040)
		goto cmd0040; /* ƒtƒ@ƒCƒ‹ƒŠƒXƒg‚Ì“]‘—Fíœ‚³‚ê‚½‚à‚Ì‚Í‘—‚ç‚È‚¢ */
	if (EAX == 0x0050)
		goto cmd0050; /* GAPI‚Ö‚Ìƒ_ƒCƒŒƒNƒgƒRƒ}ƒ“ƒh */
	if (EAX == 0x0054)
		goto cmd0054; /* setvideomode */
	if (EAX == 0x0058)
		goto cmd0058; /* control v86flag */
	if (EAX == 0x0060)
		goto cmd0060; /* keymos‚Ö‚Ìƒ_ƒCƒŒƒNƒgƒRƒ}ƒ“ƒh */
	if (EAX == 0x0064)
		goto cmd0064; /* timer‚Ö‚Ìƒ_ƒCƒŒƒNƒgƒRƒ}ƒ“ƒh */
	if (EAX == 0x0068)
		goto cmd0068; /* decode‚Ö‚Ìƒ_ƒCƒŒƒNƒgƒRƒ}ƒ“ƒh */
	if (EAX == 0x006c)
		goto cmd006c; /* TAPI‚Ö‚Ìƒ_ƒCƒŒƒNƒgƒRƒ}ƒ“ƒh */
	if (EAX == 0x0070)
		goto cmd0070; /* ‰¼‘zƒ‚ƒWƒ…[ƒ‹¶¬ */
	if (EAX == 0x0074)
		goto cmd0074; /* ‰¼‘zƒ‚ƒWƒ…[ƒ‹íœ */
	if (EAX == 0x0078)
		goto cmd0078; /* ‘¼ƒ^ƒXƒN‘‚«‚İ */
	if (EAX == 0x007c)
		goto cmd007c; /* gapidata‚Ìƒnƒ“ƒhƒ‹æ“¾ */
	if (EAX == 0x0080)
		goto cmd0080; /* slot‚ğg‚í‚È‚¢mapping */
	if (EAX == 0x0084)
		goto cmd0084; /* ƒƒ‚ƒŠŠl“¾ */
	#if (defined(PCAT)) || (defined(TOWNS) && defined(CLGD543X))
		if (EAX == 0x0088)
			goto cmd0088;	/* ATê—pƒrƒfƒIƒhƒ‰ƒCƒo•ÏX */
							/* TOWNSê—pVRAM&CRTo—ÍØ‚è‘Ö‚¦ */
	#endif
	#if (defined(PCAT)) || (defined(TOWNS))
		if (EAX == 0x008c)
			goto cmd008c; /* AT/TOWNS—p “ú•t“Ç‚İo‚µ(KIYOTO, I.Tak.) */
	#endif
	#if (defined(PCAT))
		if (EAX == 0x0090)
			goto cmd0090; /* ATê—p VESA call */
		if (EAX == 0x0094)
			goto cmd0094; /* ATê—p VESAî•ñ•ñ */
		if (EAX == 0x0098)
			goto cmd0098; /* ATê—p PCIƒfƒoƒCƒX’²¸ */
	#endif
	if (EAX == 0x009c)
		goto cmd009c; /* change drive */
	#if (defined(TOWNS)) && (defined(CLGD543X))
		if (EAX == 0x00a0)
			goto cmd00a0; /* CLGD‘¶İŠm”F&‰Šú‰» */
	#endif
	if (EAX == 0x00b0)
		goto cmd00b0; /* set info */
	#if (defined(KROM))
		if (EAX == 0x0100)
			goto cmd0100; // decode TOWNS KanjiROM
	#endif

	if (EAX == 0x8010)
		goto cmd8010;
	INT(0x03);

cmd0000:
	EDI = (int) [SS:ESP +  0];
	ESI = (int) [SS:ESP +  4];
	EBP = (int) [SS:ESP +  8];
	EDX = (int) [SS:ESP + 20];
	ECX = (int) [SS:ESP + 24];
	EAX = (int) [SS:ESP + 28];
	ES = (short) [SS:ESP + 32];
	DS = (short) [SS:ESP + 36];
	ESP += 40;
dec_lv0cnt_ret:
	CLI();
	(char) [SS:0xffffffe0]--;
	if (!= 0) {
		STI();
		return; // CF = 0, ZF = 0
	}
	TEST(ESP, ESP); // ZF = 0
	PUSHFD();
	(int) [SS:ESP] |= 0x0200; // IF = 1, ZF == 0
	jmp_system_count0();

cmd0010:
	// ƒVƒXƒeƒ€ƒI[ƒvƒ“
	// ‚Æ‚è‚ ‚¦‚¸A‚È‚É‚à‚µ‚È‚¢
	// ƒpƒ‰ƒ[ƒ^[‚Rdw
	(offset) cmd += 16;
	goto nextcmd;

cmd0020:
	// send signal
	// cmd, opt(length), data...
	// opt‚ÌÅãˆÊbit‚ğ1‚É‚·‚é‚ÆAdata‚ğ‚»‚Ì‚Ü‚Üo—Í
	(offset) cmd += 8;
	PUSH((int) 0);
	PUSH(FS);
	PUSH((offset) cmd);
	PUSH((int) 0x0118 /* ƒRƒ}ƒ“ƒhƒVƒOƒiƒ‹ŠÔÚ */);
	MOV(EAX, SS);
	EBX = ESP;
	FS = AX;
	CALLFAR0(tapi_sel);
//	asmout("LFS EBX,DWORD SS:[ESP+4]");
	LFS(EBX, [SS:ESP + 4]);
	ESP += 16;
	ECX = cmd[-4];
	ECX &= 0x0f;
	LEA(EBX, [EBX + ECX * 4]);
	goto nextcmd;

cmd0028:
	// get window param(b’èƒRƒ}ƒ“ƒh)
	// cmd, opt, winhandle, offset, selector
	GUIGUI_window_struct *cmd0028_win == ES:EDX;
	EAX = stack_sel;
	(offset) cmd0028_win = cmd[8]; // winhandle
	ES = AX;
//	DS:ESI = cmd[12];
	LDS(ESI, [FS:EBX + 12]);
	ECX = 8;
	do {
		EAX = [ES:EDX];
		EDX += 4;
		[DS:ESI] = EAX;
		ESI += 4;
		ECX--;
	} while (!= 0);
	(offset) cmd += 20;
	goto nextcmd;

cmd002c:
	// put window param(b’èƒRƒ}ƒ“ƒh)
	// cmd, opt, winhandle, offset, selector

	GUIGUI_window_struct *cmd002c_win == ES:EDX;
	EAX = stack_sel;
	(offset) cmd002c_win = cmd[8]; // winhandle
	ES = AX;
//	DS:ESI = cmd[12];
	LDS(ESI, [FS:EBX + 12]);
	ECX = 8;
	do {
		EAX = [DS:ESI];
		ESI += 4;
		[ES:EDX] = EAX;
		EDX += 4;
		ECX--;
	} while (!= 0);
	(offset) cmd += 20;
	goto nextcmd;

cmd0034:
	/* report memory status */
	/*	+04 : opt
		+08 : mem20(all, free, max, blocks)
		+18 : mem24(all, free, max, blocks)
		+28 : mem32(all, free, max, blocks) */
	ECX = 0;
	PUSH((int) ECX);
	ESP -= 16 * 3;
	PUSH((int) 0x800000ff);
	PUSH(ECX);
	PUSH(ECX);
	PUSH((int) 0x0114);
	PUSH(FS);
	PUSH((offset) cmd);
	LEA(EBX, [SS:ESP + 8]);
	PUSH(SS);
	POP(FS);
	CALLFAR0(papi_sel);
	POP((offset) cmd);
	POP(FS);
	(offset) cmd += 8;
	ESP += 16;
//	ECX = 4 * 3;
	ECX += 4 * 3;
	do {
		POP(*cmd);
		(offset) cmd += 4;
		ECX--;
	} while (!= 0);
	POP(EAX);
	goto nextcmd;

cmd0040:
	/* ƒtƒ@ƒCƒ‹ƒŠƒXƒg‚Ì“]‘—Fíœ‚³‚ê‚½‚à‚Ì‚Í‘—‚ç‚È‚¢ */
	ECX = cmd[4];
	PUSH((int) all_sel);
	ECX -= 2; // Å‰‚Ì1‚Â‚ÍƒŠƒU[ƒuAÅŒã‚Ìˆê‚Â‚ÍNULLê—p
	LES(EDI, [FS:EBX + 8]);
	POP(DS);
	#if (defined(PCAT))
		ESI = 0x102600;
	#endif
	#if (defined(TOWNS) || defined(NEC98))
		ESI = 0x101400;
	#endif
	(offset) cmd += 32;
	EDI += 20;
	do {
		EAX = [DS:ESI + 0];
		#if (defined(PCAT))
			if (ESI == 0x104200)
				break;
		#endif
		#if (defined(TOWNS) || defined(NEC98))
			if (ESI == 0x102c00)
				break;
		#endif
		if (AL == 0)
			break;
		if (AL == 0xe5) {
			ESI += 32;
			continue;
		}
		EDX = [DS:ESI + 4];
		[ES:EDI +  0] = ESI;
		[ES:EDI +  4] = EAX;
		EAX = [DS:ESI + 8];
		[ES:EDI +  8] = EDX;
		EDX = [DS:ESI + 28]; /* size */
		[ES:EDI + 12] = EAX;
		[ES:EDI + 16] = EDX;
		ESI += 32;
		EDI += 20;
		ECX--;
	} while (!= 0);
	EAX = 0;
	[ES:EDI +  0] = EAX;
	[ES:EDI +  4] = EAX;
	[ES:EDI +  8] = EAX;
	[ES:EDI + 12] = EAX;
	[ES:EDI + 16] = EAX;
	goto nextcmd;

cmd0050:
	// GAPI‚Ö‚Ìƒ_ƒCƒŒƒNƒgƒRƒ}ƒ“ƒh
	PUSH((offset) cmd);
	(offset) cmd += 8;
	DB(0x9a); DD(0); DW((short) GAPI_sel);
	POP((offset) cmd);
	(offset) cmd += cmd[4];
	goto nextcmd;

cmd0054:
	// setvideomode
	// opt, mode, sig0(‘—‚èæ‚Æ’·‚³), sig1, sig2
	#if (defined(PCAT))
		/* V86ƒ^ƒXƒN */
		PUSH(syswork_sel);
		POP(DS);
		PUSH(all_sel);
		POP(ES);
		EAX = 0x9f800;
	//	asmout("CMP BYTE [DS:DiskCacheReady],3");
	//	if (==)
	//		EAX = 0x0800;
		(int) [ES:EAX] = 0x00cc10cd;
		#if (defined(V86LOG))
			(int) [ES:0x108000] = 0x108010;
		#endif
		PUSH(tapiwork_sel);
		POP(DS);
		PUSH(stack_sel);
		POP(ES);
		GUIGUI_work *cmd0054_work == ES:0xffffd000;
		TAPI_TSS *cmd0054_tss == DS:ESI;
		(offset) cmd0054_tss = TSS_V86 /* cmd0054_work->tasklist[128].tskptr */;
		(unsigned int) EAX >>= 4;
		cmd0054_tss->tss386.EIP = 0;
		cmd0054_tss->tss386.ESP = 2048;
		cmd0054_tss->tss386.SS = EAX;
		cmd0054_tss->tss386.CS = EAX;
		EAX = cmd[8]; // mode
		cmd0054_tss->tss386.EFLAGS = 0x00020202; /* STI&VM=1 */
		if (AH == 0)
			cmd0054_tss->tss386.EAX = EAX;
		else {
			cmd0054_tss->tss386.EAX = 0x4f02;
			cmd0054_tss->tss386.EBX = EAX;
		}
		// signal‚ğstack_sel(== ES)‚É•Û‘¶
		cmd0054_work->setvideomode_mode = EAX;
		EAX = cmd[12];
		ECX = cmd[16];
		EDX = cmd[20];
		cmd0054_work->setvideomode_sig[0] = EAX;
		cmd0054_work->setvideomode_sig[4] = ECX;
		cmd0054_work->setvideomode_sig[8] = EDX;

		(offset) cmd += 24;

		PUSH(FS);
		PUSH((offset) cmd);
		PUSH((int) 0);
		PUSH((int) 1 /* Llv */);
		PUSH((offset) cmd0054_tss);
		PUSH((int) 0x0100 /* TAPI_ChangeLlv */);
		EBX = ESP;
		PUSH(SS);
		POP(FS);
		CALLFAR0(tapi_sel);
		ESP += 16;
		POP((offset) cmd);
		POP(FS);
		goto nextcmd;
	#else
		INT(0x03);
	#endif

cmd0058:
	/* control v86flag */
	#if (defined(PCAT))
		PUSH(stack_sel);
		POP(DS);
		GUIGUI_work *cmd0058_work == DS:0xffffd000;
		EAX = cmd[4];
		if (EAX == 0) {
			/* ƒZƒ}ƒtƒHŠJ•ú */
			cmd0058_work->v86flag = AL;
			(offset) cmd += 8;
			goto nextcmd;
		}
		if (EAX == 1) {
			/* ƒZƒ}ƒtƒHæ“¾ */
			XCHG(AL, cmd0058_work->v86flag);
			cmd[12] = EAX;
			(offset) cmd += 8;
			goto nextcmd;
		}
	#endif
	INT(0x03);

cmd0060:
	/* keymos‚Ö‚Ìƒ_ƒCƒŒƒNƒgƒRƒ}ƒ“ƒh */
	PUSH((offset) cmd);
	(offset) cmd += 8;
	DB(0x9a); DD(0); DW((short) keyint_sel);
	POP((offset) cmd);
	(offset) cmd += cmd[4];
	goto nextcmd;

cmd0064:
	/* timer‚Ö‚Ìƒ_ƒCƒŒƒNƒgƒRƒ}ƒ“ƒh */
	PUSH((offset) cmd);
	(offset) cmd += 8;
	DB(0x9a); DD(0); DW((short) timerint_sel);
	POP((offset) cmd);
	(offset) cmd += cmd[4];
	goto nextcmd;

cmd0068:
	/* decode‚Ö‚Ìƒ_ƒCƒŒƒNƒgƒRƒ}ƒ“ƒh */
	PUSH((offset) cmd);
	(offset) cmd += 8;
	DB(0x9a); DD(0); DW((short) decode_sel);
	POP((offset) cmd);
	(offset) cmd += cmd[4];
	#if (defined(NEC98))
		IN(AL, 0x0002);
		AL &= 0xfd; /* keyboard enable */
		OUT(0x0002, AL);
	#endif
	goto nextcmd;

cmd006c:
	/* TAPI‚Ö‚Ìƒ_ƒCƒŒƒNƒgƒRƒ}ƒ“ƒh */
	PUSH((offset) cmd);
	(offset) cmd += 8;
	DB(0x9a); DD(0); DW((short) tapi_sel);
	POP((offset) cmd);
	(offset) cmd += cmd[4];
	goto nextcmd;

cmd0070:
	/* ‰¼‘zƒ‚ƒWƒ…[ƒ‹¶¬ */
	PUSH((int) root_sel);
	ESI = 512;
	POP(DS);
	ECX = 512; /* 0.5KB */
	alloc_tagdir();
	ECX = cmd[ 8];
	LEA(EAX, [ECX + 0xfff]);
	EAX &= 0xfffff000;
	EDX = 0;
	(int) [DS:EDI +  0] = 64;
	(int) [DS:EDI + 16] = 0xffe00003; /* standard link-to */
	(int) [DS:EDI + 20] = 32;
	(int) [DS:EDI + 24] = ECX; /* used */
	(int) [DS:EDI + 28] = EDX;
	(int) [DS:EDI + 32] = EAX; /* allocated */
	(int) [DS:EDI + 36] = EDX;
	EAX = cmd[16];
	ECX = cmd[20];
	cmd[12] = EDI;
	(offset) cmd += 24;
	(int) [DS:EDI + 40] = EAX;
	(int) [DS:EDI + 44] = ECX;
	(int) [DS:EDI + 48] = 0xfff00000;
	(int) [DS:EDI + 52] = 0xffffffff;
	(int) [DS:EDI + 56] = EDX;
	(int) [DS:EDI + 60] = EDX;
	goto nextcmd;

cmd0074:
	/* ‰¼‘zƒ‚ƒWƒ…[ƒ‹íœ */
	/* cmd, opt, addr(cmd0070‚Å[12]‚É•Ô‚³‚ê‚½’l) */
	PUSH((int) root_sel);
	ESI = 512;
	POP(DS);
	EAX = cmd[8];
	(offset) cmd += 12;
	ECX = [DS:EAX + 4]; /* tag-dir allcated size */
	free_area();
	goto nextcmd;

cmd0078:
	/* ƒfƒoƒbƒO—pƒRƒ}ƒ“ƒh‚Ì“]‘—æ‚ª‹tƒo[ƒWƒ‡ƒ“ */
	ECX = cmd[8]; // bytes
	LES(EDI, [FS:EBX + 24]);
	CLI();
	SLDT(DX);
	LLDT((short) [FS:EBX + 22]);
	LDS(ESI, [FS:EBX + 16]);
	LLDT(DX);
	(offset) cmd += 32;
	do {
		AL = [ES:EDI];
		EDI++;
		[DS:ESI] = AL;
		ESI++;
		ECX--;
	} while (!= 0);
	STI();
	goto nextcmd;

cmd007c:
	/* gapidata‚Ö‚Ìƒnƒ“ƒhƒ‹Šl“¾ */
	/* opt, slot */
	PUSH((int) root_sel);
	PUSH((int) 0x003c); /* slot_sel */
	EDX = cmd[8];
	POP(ES);
	POP(DS);
	ESI = 1024 /* rootdir */ + 16;
	EAX = 0xffe00040;
//	ESI += 16;
	search_tag_EAX();
	PUSH((offset) cmd);
	EBX = [DS:ESI + 16];
	EBX += 16;
	for (;;) {
		ESI = [DS:EBX];
		if (ESI == 0xffffffff)
			INT(0x03); /* Œ©•t‚©‚ç‚È‚¢I(terminatorŒŸo) */
		ESI += 16;
		EAX = 0xffe00000; /* nameƒ^ƒO */
		search_tag_EAX();
	//	if (ZF == 0) /* nameƒ^ƒO‚ªŒ©•t‚©‚ç‚È‚¢ */
	//		INT(0x03);
		if ((unsigned) (int) [DS:ESI +  4] == 16) {
			if ((unsigned) (int) [DS:ESI +  8] == 0x69706167) {
				if ((unsigned) (int) [DS:ESI + 12] == 0x61746164)
					break;
			}
		}
		EBX += 4;
	}
	EAX = [DS:EBX];
	[ES:EDX + 0] = EAX;
	POP((offset) cmd);
	(offset) cmd += 12;
	goto nextcmd;

cmd0080:
	/* slot‚ğg‚í‚È‚¢mapping */
	/* size, addr, ofs  */
	PUSH((int) tapiwork_sel);
	POP(DS);
	EAX = [DS:0x000c] /* tskptr */;
	EAX += 2048 + 0x0008; /* sel:0x000c */
//	int *cmd0080_tss_ldt == DS:ESI + 2048;
//	asmout("LEA ECX,[ECX+ESI+2048]");
	DL = [DS:EAX + 4];
	DH = [DS:EAX + 7];
	EDX <<= 16;
	DX = [DS:EAX + 2];

	EDX += cmd[12]; /* ofs */
	ECX = cmd[ 4]; /* size */
	EAX = 0;
	ECX += 0x00000fff;
	PUSH(FS);
	PUSH((offset) cmd);
	ECX &= 0xfffff000;
	PUSH((int) EAX /* eoc */);
	PUSH((int) EAX /* addr64(high) */);
	PUSH((int) cmd[ 8] /* addr64(low) */);
	PUSH((int) EAX /* offset64(high) */);
	PUSH((int) EAX /* offset64(low) */);
	PUSH((int) EAX /* pageset */);
	PUSH((int) EDX /* linear */);
	PUSH((int) ECX /* size */);
	PUSH((int) 0x1007 /* opt(over-mapping, present, R/W, user) */);
	PUSH((int) 0x0108 /* cmd(mapping) */);
	EBX = ESP;
	PUSH(SS);
	POP(FS);
	CALLFAR0(papi_sel);
	ESP += 40;
	POP((offset) cmd);
	POP(FS);
	(offset) cmd += 16;
	goto nextcmd;

cmd0084:
	/* ƒƒ‚ƒŠŠl“¾ */
	/* cmd, size, [addr] */
	/* –{“–‚Í”r‘¼§Œä‚ğ‚µ‚È‚¯‚ê‚Î‚¢‚¯‚È‚¢‚Ì‚ÉA–Ê“|‚È‚Ì‚Å‚â‚Á‚Ä‚¢‚È‚¢ */
	ECX = cmd[4];
	ECX += 0x00000fff;
	ECX &= 0xfffff000;
	get_memory(); /* EAX‚ğ•Ô‚· */
	if (ZF != 0)
		EAX = 0xffffffff;
	cmd[8] = EAX;
	(offset) cmd += 12;
	goto nextcmd;

	#if (defined(PCAT))
cmd0088:
		EAX = cmd[4];
		if (EAX == 0) {
			/* ƒrƒfƒIƒhƒ‰ƒCƒo•ÏX */
			/* cmd, opt, drv */
			STR_SYSWORK *cmd0088_swork == DS:0;
			EAX = cmd[8];
			PUSH(syswork_sel);
			POP(DS);
			EDX = 0x040;
			if (EAX == 1)
				EDX = 0x00d0;
			if (EAX == 2)
				EDX = 0x0100;
			if (EAX == 3)
				EDX = 0x0110;
			ECX = [DS:EDX +  8];
			EDX = [DS:EDX + 12];
			EDX -= cmd0088_swork->bmodule_paddr;
			EDX += cmd0088_swork->bmodule_laddr;
			PUSH(idtgdt_sel);
			POP(DS);
			EAX = 4 * 8 + 384;
			(short) [DS:EAX + 0] = CX; /* limit */
			(short) [DS:EAX + 2] = DX; /* base */
			(unsigned int) EDX >>= 16;
			(char) [DS:EAX + 4] = DL;
			(char) [DS:EAX + 7] = DH;
			(offset) cmd += 12;
			goto nextcmd;
		}
		if (EAX == 1) {
			/* VRAM_sel‚Ì€”õ */
			/* cmd, opt, addr */
			EAX = cmd[8];
			if (EAX == 0) {
				EAX = 0x000a0000;
				ECX = 64 - 1;
			} else {
				PUSH(syswork_sel);
				POP(DS);
				DL = [DS:0x001c + 2 /* eflags[2] */];
				ECX = 0x1007 /* present, R/W, user, override */;
				TEST(DL, 0x04);
				if (!= 0)
					CL = 0x1f /* VRAM‚ÍƒLƒƒƒbƒVƒ…‚µ‚È‚¢(PCD=1) */;
				PUSH(FS);
				PUSH(EBX);
				PUSH(0);
				PUSH(0 /* addr64(high) */);
				PUSH(EAX /* addr64(low) */);
				PUSH(0 /* offset64(high) */);
				PUSH(0 /* offset64(low) */);
				PUSH(0 /* pageset */);
				PUSH((int) 0xe0000000 /* linear */);
				PUSH((int) 16 * 1024 * 1024 /* size */);
				PUSH(ECX /* opt */);
				PUSH((int) 0x0108 /* cmd(mapping) */);
				PUSH(SS);
				POP(FS);
				EBX = ESP;
				CALLFAR0(papi_sel);
				ESP += 40;
				POP(EBX);
				POP(FS);
				EAX = 0xe0000000;
				ECX = 16 * 1024 - 1;
			}
			PUSH(idtgdt_sel);
			POP(DS);
			EDX = 20 * 8 + 384;
			[DS:EDX + 0] = CX;
			[DS:EDX + 2] = AX;
			(unsigned int) EAX >>= 16;
			(unsigned int) ECX >>= 16;
			[DS:EDX + 4] = AL;
			CL |= 0xc0;
			[DS:EDX + 7] = AH;
			[DS:EDX + 6] = CL;
			(offset) cmd += 12;
			goto nextcmd;
		}
		INT(0x03);

	#elif (defined(TOWNS))
cmd0088:	/* opt=1:CRTC/CLGDØ‚è‘Ö‚¦ opt=0:GAPIselØ‚è‘Ö‚¦ */
			/* cmd, opt, drv */
		EAX = cmd[4];
		if (EAX == 0) {/* ƒrƒfƒIƒhƒ‰ƒCƒo•ÏX, AL=0:4bpp,1:8bpp,2:16bpp, AH=0:FM,1:CL5430,2:CL5434 */
			STR_SYSWORK *cmd0088_swork == DS:0;
			EAX = cmd[8];
			PUSH(syswork_sel);
			POP(DS);
			EDX = 0x040;
			/* base.nas:SysWorkMdl+0x0d0‚Étowns15‚Ìî•ñ‚ª‚ ‚é */
			if (EAX == 2) {
				/* vesa16.ask‚É“ü‚ê‚é‚Æ–Ê“|‚È‚Ì‚Å‚±‚±‚É“Ë‚Á‚Ş */
				ECX = 0;
				EDX = 0x440;
				do {
					EAX = ECX;
					OUT(DX, AX);
					asmout("mov AX, [CS:towns15crtc+ECX*2]");
					DL = 0x42;
					OUT(DX, AX);
					DL = 0x40;
					CMP(ECX, 31);
					ECX++;
				} while (CF != 0);
				/* ƒvƒ‰ƒCƒIƒŠƒeƒB[ƒŒƒWƒXƒ^ */
				DL = 0x48;
				AL = 0x00;
				OUT(DX, AL);
				DL = 0x4a;
				AL = 0x0f;
				OUT(DX, AL);
				DL = 0x48;
				AL = 0x01;
				OUT(DX, AL);
				DL = 0x4a;
				AL = 0x08;
				OUT(DX, AL);
				/* CRTo—ÍƒRƒ“ƒgƒ[ƒ‹ƒŒƒWƒXƒ^ */
				EDX = 0xfda0;
				AL = 0x0c;
				OUT(DX, AL);

				EDX = 0x00d0;
			}
		  #if (defined(CLGD543X))
			/* base.nas:SysWorkMdl+0x100‚Évesa16‚Ìî•ñ‚ª‚ ‚é */
			else if (AH != 0)
				EDX = 0x0100;
		  #endif
			ECX = [DS:EDX +  8];
			EDX = [DS:EDX + 12];
			EDX -= cmd0088_swork->bmodule_paddr;
			EDX += cmd0088_swork->bmodule_laddr;
			PUSH(idtgdt_sel);
			POP(DS);
			EAX = 4 * 8 + 384;
			(short) [DS:EAX + 0] = CX; /* limit */
			(short) [DS:EAX + 2] = DX; /* base */
			EDX >>= 16;
			(char) [DS:EAX + 4] = DL;
			(char) [DS:EAX + 7] = DH;
		} else if (EAX == 1) {
			/* VRAM_sel‚Ì€”õ */
			PUSH(syswork_sel);
			EAX = cmd[8]; /* drv */
			POP(DS);
			EBP = 512 * 1024;
			CMP(AH, 1);
			if ((unsigned) <) {	/* TOWNS”Ä—pŒ^ */
				ESI = 0x80100000;
				IN(AX, 0x0030); /* CPU¯•ÊƒŒƒWƒXƒ^ */
				AL &= 0x07;
				CMP(AL, 0x03);
				if (==) /* i386SX */
					ESI = 0x00b00000;
				DX = 0x055c;
				AL = 0;
				OUT(DX, AL);
			} else {
				ESI = 0x89400000; /* CLGD543X */
				if (!=)
					EBP *= 2;
				clgd543XSetup(); /* AL=1:8bpp, 2:16bpp */
				EBP *= 2;
			}
			DL = [DS:0x001c + 2 /* eflags[2] */];
			ECX = 0x1007 /* present, R/W, user, override */;
			TEST(DL, 0x04);
			if (!= 0)
				CL = 0x1f /* VRAM‚ÍƒLƒƒƒbƒVƒ…‚µ‚È‚¢(PCD=1) */;
			PUSH(FS);
			PUSH(EBX);
			PUSH(0);
			PUSH(0 /* addr64(high) */);
			PUSH(ESI /* addr64(low) */);
			PUSH(0 /* offset64(high) */);
			PUSH(0 /* offset64(low) */);
			PUSH(0 /* pageset */);
			PUSH((int) 0xe0000000 /* linear */);
			PUSH(EBP /* size */);
			PUSH(ECX /* opt */);
			PUSH((int) 0x0108 /* cmd(mapping) */);
			PUSH(SS);
			POP(FS);
			EBX = ESP;
			CALLFAR0(papi_sel);
			ESP += 40;
			POP(EBX);
			POP(FS);
		}
		(offset) cmd += 12;
		goto nextcmd;
	#endif

	#if (defined(PCAT))
cmd008c:
		/* KIYOTO‚³‚ñ‰ü‘¢, [OSASK 5504] */
		/* (‚³‚ç‚Éì‡‚ª‰ü—Ç) */
		/* cmd, opt, [ss][mm][hh][dd][mm][yy][yy][dmy] */
		EAX = 0;
		PUSH(EBP);
		PUSH(EAX);
		PUSH(EAX);
		PUSH(EAX);
		PUSH(EAX);
cmd008c_retry:
		/* ‚Æ‚è‚ ‚¦‚¸k‚ß‚Ä‚İ‚Ü‚µ‚½ by I.Tak. */
		PUSH(0x00320908); PUSH(0x07040200);
		LEA(EBP, [SS:ESP + 16]);
		do {
			ECX = 0;
			do {
				AL = [SS:ESP+ECX]; /* 0x00, 0x02, 0x04,... */
				OUT(0x70, AL);	/* ‘¦’l‚É‚Å‚«‚é‚Ì‚Íbyte‚¾‚¯ */
				NOP();
				IN(AL, 0x71);
				[SS:EBP + ECX] = AL;
				CMP(ECX,6);
				ECX++;
			} while (CF != 0);	/* ‚Â‚Ü‚è ECX++<6 */
			EBP -= 8;
		} while (EBP != ESP); /* ‚Â‚Ü‚èA2‰ñÀs‚³‚ê‚é */
		POP(EAX); POP(EAX);
		EAX = (int) [SS:ESP +  0];
		EDX = (int) [SS:ESP +  4];
		if (EAX != (int) [SS:ESP +  8])
			goto cmd008c_retry;
		if (EDX != (int) [SS:ESP + 12])
			goto cmd008c_retry;
		/* ‚È‚º2‰ñ“Ç‚ñ‚Å”äŠr‚·‚é‚© ... ŒJ‚èã‚ª‚è’†‚Ì•Ï‚È’l‚ğÌ‚Ä‚Ä‚â‚è’¼‚·‚½‚ß */
		POP(cmd[ 8]);
		POP(cmd[12]);
		POP(EAX);
		POP(EAX);
		POP(EBP);
		(offset) cmd += 16;
		goto nextcmd;

	#elif (defined(TOWNS))
cmd008c:
		/* TOWNS—p’Ç‰Á by I.Tak. */
		EBP = 0; ECX = 0;
		ESP -= 16;
		do {
			/* 6 ‚Í—j“úcc³‚µ‚¢’l‚Í“¾‚ç‚ê‚é‚ª–³‹ */
			if (EBP == 6) EBP++;

			/* linux/arch/i386-TOWNS/kernel/time.c ‚Ì read_rtc ‚æ‚è */
			do {	/* while(!(inb(0x70)&0x80)) */
				IN(AL, 0x70);
				AL &= 0x80;
			} while (== 0);
			OUT(0x80, AL);	/* out 0x80, 0x80 */
			EAX = EBP;
			OUT(0x70, AL);	/* out 0x70, ?? */
			AL = 0x81;
			OUT(0x80, AL);	/* out 0x80, 0x81 */
			EAX--;
			OUT(0x80, AL);	/* out 0x80, 0x80 */
			AL = 0x84;
			OUT(0x80, AL);	/* out 0x80, 0x84 */
			EAX = 0;
			OUT(0x6c, AL);	/* out 0x6c, 0x00 */
			OUT(0x6c, AL);	/* 1ƒÊ•bƒEƒFƒCƒg‚¾‚Á‚¯H */
			OUT(0x6c, AL);
			OUT(0x6c, AL);
			OUT(0x6c, AL);
			IN(AL, 0x70);
			[SS:ESP + ECX] = AL;	/* [n]‚Æ[n+8]‚ÉŒğŒİ‚ÉU‚è•ª‚¯‚é */
			CMP(CL, 8);
			SBB(CL, -1);	/* CL -= CL<8 ? 1-1 : 0-1 */
			EBP++;
			CL ^= 0x08;
			AL = 0x80;
			OUT(0x80, AL);	/* out 0x80, 0x80 */
		} while (EBP < 13);

		POP(EAX);          POP(EDX);
		POP(ECX);          POP(EBP);
		ECX <<= 4;         EAX &= 0x0f0f0f0f;
		EBP <<= 4;         EDX &= 0x0f0f0f0f;
		ECX &= 0x30307070; EBP &= 0xf0f0f010;
		EAX |= ECX;        EDX |= EBP;
		cmd[8] = EAX;      cmd[12] = EDX;
		AL = 0x19;
		if ((unsigned) DH < 0x89)	/* ‰‘ãFMTOWNS‚Í1989”N»‚¾‚©‚çcc‚Á‚Ä‚±‚Æ‚ÅOK? */
			AL = 0x20;
		if ((unsigned) DH > 0x99) {	/* 2003”N=0xa3”N‚Æ‚¢‚¤‚±‚Æ‚à‚ ‚é‚æ‚¤‚¾B*/
			AL = 0x20;
			(char)cmd[13] -= 0xa0;
		}
		(char)cmd[14] = AL;
		(offset) cmd += 16;
		goto nextcmd;
	#endif

cmd0090:
	// get videomode info
	//	opt, EAX, ECX, sig0(‘—‚èæ‚Æ’·‚³), sig1, sig2
	#if (defined(PCAT))
		/* V86ƒ^ƒXƒN */
		PUSH(syswork_sel);
		POP(DS);
		PUSH(all_sel);
		POP(ES);
		EAX = 0x9f800;
	//	asmout("CMP BYTE [DS:DiskCacheReady],3");
	//	if (==)
	//		EAX = 0x0800;
		(int) [ES:EAX] = 0x00cc10cd;
		(int) [ES:0x9f000] = 0x32454256 /* 'VBE2' */;
		#if (defined(V86LOG))
			(int) [ES:0x108000] = 0x108010;
		#endif
		PUSH(tapiwork_sel);
		POP(DS);
		PUSH(stack_sel);
		POP(ES);
		GUIGUI_work *cmd0090_work == ES:0xffffd000;
		TAPI_TSS *cmd0090_tss == DS:ESI;
		(offset) cmd0090_tss = TSS_V86 /* cmd0090_work->tasklist[128].tskptr */;
		(unsigned int) EAX >>= 4;
		EDX = cmd[8]; /* EAX */
		ECX = cmd[12]; /* ECX */
		cmd0090_tss->tss386.EIP = 0;
		cmd0090_tss->tss386.EAX = EDX;
		cmd0090_tss->tss386.ECX = ECX;
		cmd0090_tss->tss386.ESP = 2048;
		cmd0090_tss->tss386.EDI = 0;
		cmd0090_tss->tss386.SS = EAX;
		cmd0090_tss->tss386.CS = EAX;
		cmd0090_tss->tss386.ES = 0x9f00;
		cmd0090_tss->tss386.EFLAGS = 0x00020202; /* STI&VM=1 */
		// signal‚ğstack_sel(== ES)‚É•Û‘¶
		cmd0090_work->setvideomode_mode = EAX;
		EAX = cmd[16];
		ECX = cmd[20];
		EDX = cmd[24];
		cmd0090_work->setvideomode_sig[0] = EAX;
		cmd0090_work->setvideomode_sig[4] = ECX;
		cmd0090_work->setvideomode_sig[8] = EDX;
		(offset) cmd += 28;

		PUSH(FS);
		PUSH((offset) cmd);
		PUSH((int) 0);
		PUSH((int) 1 /* Llv */);
		PUSH((offset) cmd0090_tss);
		PUSH((int) 0x0100 /* TAPI_ChangeLlv */);
		EBX = ESP;
		PUSH(SS);
		POP(FS);
		CALLFAR0(tapi_sel);
		ESP += 16;
		POP((offset) cmd);
		POP(FS);
		goto nextcmd;
	#else
		INT(0x03);
	#endif

cmd0094:
	// get videomode info summary
	#if (defined(PCAT))
		EAX = cmd[4];
		if (EAX == 1) {
			/* opt, len, dest */
			PUSH(all_sel);
			ESI = 0x9f000;
			POP(DS);
			LES(EDI, cmd[12]);
			EAX = [DS:ESI];
			[ES:EDI] = EAX;
			EAX = [DS:ESI + 4];
			[ES:EDI + 4] = EAX;
			EDI += 8;
			EAX = (unsigned short) [DS:ESI + 16];
			ESI = (unsigned short) [DS:ESI + 14]; /* video mode ptr */
			EAX *= 16;
		//	ECX = cmd[8];
			ESI += EAX;
			do {
				AX = [DS:ESI];
				ESI += 2;
				[ES:EDI] = AX;
				EDI += 2;
			} while (AX != 0xffff);
			(offset) cmd += 20;
			goto nextcmd;
		}
		if (EAX == 2) {
			/* opt, len, dest (40ƒoƒCƒg) */
			PUSH(all_sel);
			ESI = 0x9f000;
			POP(DS);
			LES(EDI, cmd[12]);
			EAX = (unsigned short) [DS:ESI + 0];
			[ES:EDI +  0] = EAX; /* mode attributes(bit0, 3, 4‚ª1‚Å‚ ‚é•K—v‚ ‚è, bit7‚Ílinear‰Â”\bitH) */
			EAX = (unsigned short) [DS:ESI + 16];
			[ES:EDI +  4] = EAX; /* bytes per scan-line */
			EAX = (unsigned short) [DS:ESI + 18];
			[ES:EDI +  8] = EAX; /* X reso. */
			EAX = (unsigned short) [DS:ESI + 20];
			[ES:EDI + 12] = EAX; /* Y reso. */
			EAX = (unsigned char)  [DS:ESI + 25];
			[ES:EDI + 16] = EAX; /* bit per pixel */
			EAX = (unsigned char)  [DS:ESI + 27];
			[ES:EDI + 20] = EAX; /* memory model(4 = 256, 6 = 32KˆÈã) */
			EAX = (int) [DS:ESI + 32];
			EAX <<= 8;
			AL = [DS:ESI + 31];
			[ES:EDI + 24] = EAX;
			EAX = (int) [DS:ESI + 36];
			EAX <<= 8;
			AL = [DS:ESI + 35];
			[ES:EDI + 28] = EAX;
			EAX = [DS:ESI + 40];
			[ES:EDI + 32] = EAX; /* VRAM base. */
			EAX = [DS:ESI + 44];
			[ES:EDI + 36] = EAX; /* VRAM ofs (off-screen ?) */
			(offset) cmd += 20;
			goto nextcmd;
			/* mem-model == 6 ‚Ì‚Æ‚«A
				+24 : 05 0b 06 05 05 00 00 00 : 64K,
				+24 : 08 10 08 08 08 00 08 18 : 16M(32bit)
			*/
		}
	#else
		INT(0x03);
	#endif

	#if (defined(PCAT))
cmd0098:
		if (cmd[4] == 0) {
			/* [opt:0], [bus:dev:func], [ofs], [sel] */
			/* 16ƒoƒCƒg‚ğƒŠ[ƒh‚·‚é */
			EDI = cmd[8];
			LDS(ESI, cmd[12]);
			EDI |= 0x80000000;
			EDX = 0x0cf8;
			EAX = EDI; /* VendorID, DeviceID */
			CLI();
			OUT(DX, EAX);
			DL = 0xfc; /* EDX = 0x0cfc */
			IN(EAX, DX);
			(int) [DS:ESI +  0] = EAX;

			DL = 0xf8;
			LEA(EAX, [EDI + 0x08]); /* Revision, ClassCode  */
			OUT(DX, EAX);
			DL = 0xfc;
			IN(EAX, DX);
			(int) [DS:ESI +  4] = EAX;

			DL = 0xf8;
			LEA(EAX, [EDI + 0x0c]); /* CacheLineSize, MasterLatencyTimer, HeaderType, BIST */
			OUT(DX, EAX);
			DL = 0xfc;
			IN(EAX, DX);
			(int) [DS:ESI +  8] = EAX;
			EAX >>= 16;

			DL = 0xf8;
			AL &= 0x7f;
			if (AL == 0) {
				LEA(EAX, [EDI + 0x2c]);
			} else if (AL == 2) {
				LEA(EAX, [EDI + 0x40]);
			} else {
				EAX = 0;
				goto skip_PCI_subven;
			}
			OUT(DX, EAX);
			DL = 0xfc;
			IN(EAX, DX);
skip_PCI_subven:
			(int) [DS:ESI + 12] = EAX;

			DL = 0xf8;
			EAX = 0;
			OUT(DX, EAX);
			STI();
			(offset) cmd += 20;
			goto nextcmd;
		}
	//	if (cmd[4] == 1) {
			/* 6–{*8ƒoƒCƒg‚ğ“Ç‚Ş */
			EDI = cmd[8];
			LDS(ESI, cmd[12]);
			EDI |= 0x80000010;
			EDX = 0x0cf8;
			CL = 6;
			CLI();
			do {
				EAX = EDI;
				EDI += 4;
				OUT(DX, EAX);
				DL = 0xfc;
				IN(EAX, DX);
				(int) [DS:ESI + 0] = EAX;
				EAX = 0;
				EAX--;
				OUT(DX, EAX);
				NOP();
				IN(EAX, DX);
				(int) [DS:ESI + 4] = EAX;
				EAX = (int) [DS:ESI + 0];
				ESI += 8;
				OUT(DX, EAX);
				DL = 0xf8;
				CL--;
			} while (!= 0);
			EAX = 0;
			OUT(DX, EAX);
			STI();
			(offset) cmd += 20;
			goto nextcmd;
	//	}
	#endif

cmd009c:
	/* change drive */
	/* cmd, opt(0-9) */
	PUSH(FS);
	PUSH((offset) cmd);
	PUSH((int) 0);
	PUSH((int) cmd[8]);
	PUSH((int) cmd[4] /* change drive */);
	EBX = ESP;
	PUSH(SS);
	POP(FS);
	CALLFAR0(fdcdrive_sel);
	ESP += 12;
	POP((offset) cmd);
	POP(FS);
	(offset) cmd += 12;
	goto nextcmd;

	#if (defined(TOWNS) && defined(CLGD543X))
cmd00a0:	/* CLGD detect & setup*/
			/* cmd, ret-buf */
		clgd543XDetect();
		EAX <<= 8;
		cmd[4] = EAX;
		(offset) cmd += 8;
		goto nextcmd;
	#endif

cmd00b0:
	/* set info : cmd, opt, len, ofs, far-ptr */
	/* ƒ^ƒXƒN•Ê‚Éİ’è‚Å‚«‚é‚æ‚¤‚Èd‘g‚İ‚ÉŠg’£‚·‚é‚Ì‚Í‚Ü‚½¡“x */
	ECX = cmd[ 8];
	LES(EDI, cmd[16]);
	GUIGUI_work *cmd00b0_work == DS:0xffffd000;
	PUSH(stack_sel);
	LEA(EDX, cmd00b0_work->infobuf[0]);
	POP(DS);
	EDX += cmd[12];
	do {
		EAX = [ES:EDI];
		EDI += 4;
		[DS:EDX] = EAX;
		EDX += 4;
		ECX--;
	} while (!= 0);
	(offset) cmd += 24;
	goto nextcmd;

	#if (defined(KROM))
cmd0100: // TOWNS KanjiROM decoder. cmd, offset, selector
		LDS(EDI, cmd[4]);		/* JISX0213—p‚¾‚ªJISX0208-1983‚ğ“Ë‚Á‚±‚Ş */
		CH = 0x21;
		do {
			CL = 0x21;
			do {
				AL = CH;
				EDX = 0xff94;
				OUT(DX, AL);
				AL = CL;
				EDX++;
				OUT(DX, AL);
				EDX++;
				AH = 16;
				do {
					IN(AL, DX);
					EDX++;
					[DS:EDI] = AL;
					IN(AL, DX);
					[DS:EDI + 16] = AL;
					EDX--;
					EDI++;
					AH--;
				} while (!= 0);
				EDI += 16;
				CMP(CL, 0x7e);
				CL++;
			} while (CF != 0);
			CMP(CH, 0x7e);
			CH++;
		} while (CF != 0);

		EDI += 0x4a000 - 94*94*2*16;

		CH = 0x76;
		do {
			CL = 0x00;
			do {
				AL = CH;
				EDX = 0xff94;
				OUT(DX, AL);
				AL = CL;
				EDX++;
				OUT(DX, AL);
				EDX++;
				AH = 16;
				do {
				IN(AL, DX);
				[DS:EDI] = AL;
				EDI++;
				EDX++;
				IN(AL, DX);
				[DS:EDI] = AL;
				EDI++;
				EDX--;
				AH--;
			} while (!= 0);
			CMP(CL, 0x1f);
			CL++;
		} while (CF != 0);
		CMP(CH, 0x79);
		CH++;
	} while (CF != 0);

	(offset)cmd += 12;
	goto nextcmd;
#endif

cmd8010:
	// ƒfƒoƒbƒO—pƒRƒ}ƒ“ƒh
	ECX = cmd[8]; // bytes
	LES(EDI, [FS:EBX + 24]);
	CLI();
	SLDT(DX);
	LLDT((short) [FS:EBX + 22]);
	LDS(ESI, [FS:EBX + 16]);
	LLDT(DX);
	(offset) cmd += 32;
	EAX = ECX;
	EAX |= EDI;
	EAX |= ESI;
	TEST(AL, 0x03);
	if (!= 0) {
		do {
			AL = [DS:ESI];
			ESI++;
			[ES:EDI] = AL;
			EDI++;
			ECX--;
		} while (!= 0);
		STI();
		goto nextcmd;
	}
	do {
		EAX = [DS:ESI];
		ESI += 4;
		[ES:EDI] = EAX;
		EDI += 4;
		ECX -= 4;
	} while (!= 0);
	STI();
	goto nextcmd;
}

void output_string()
/* 512ƒoƒCƒg‚­‚ç‚¢ƒXƒ^ƒbƒN—Ìˆæ‚É‚Æ‚Á‚Ä‚¨‚¯‚ÎA•K‚¸‘«‚è‚éB */
/* Å‚‚Å‚à100•¶š‚µ‚©‚È‚¢‚©‚ç */
/* GS:ESI‚ÉƒXƒgƒŠƒ“ƒO('\0'‚ªƒ^[ƒ~ƒl[ƒ^) */
/* (EAX, ECX), color(DL, DH) */
{
	struct GAPI_FONT_WRITE_CMD {
		unsigned int cmd_no /* 0x0101 */;
		unsigned int option /* 0x00:ƒ‚ƒmƒNƒƒtƒHƒ“ƒg, BGC‚ ‚è, 0x10:ƒ‚ƒmƒNƒƒtƒHƒ“ƒg, BGC‚È‚µ, pset */;
		unsigned int x, y, color, bgcolor;
		void near *fnt;
		unsigned short fntsel, [2];
		unsigned int length, string[0]; // ƒLƒƒƒ‰ƒNƒ^[ƒIƒtƒZƒbƒg—ñ 
	};
	unsigned int ankfont_sel == 7 * 8;
	unsigned int GAPI_sel     ==  4 * 8, GAPIwork_sel  ==  5 * 8;

	PUSH(FS);
	PUSHAD();
	ESP -= 512;
	EBX = ESP;
	GAPI_FONT_WRITE_CMD *cmd == SS:ESP;
	cmd->cmd_no = 0x0101;
	cmd->option = 0x0000;
	cmd->x = EAX;
	cmd->y = ECX;
	// EAX = (unsigned char) DL; // MOVZX
	MOVZX(EAX,DL);
	// ECX = (unsigned char) DH; // MOVZX
	MOVZX(ECX,DH);
	cmd->color   = EAX;
	cmd->bgcolor = ECX;
//	cmd->fnt = 0;
//	(int) cmd->fntsel = ankfont_sel;
	unsigned char *s == GS:ESI;
	unsigned int *t == SS:EBP, len == ECX, chr == EAX;
	// (offset) t = (offset) cmd->string;
	LEA(EBP, [SS:ESP + 36]); 
	len = 0;

	chr = *s; /* MOVZX */
	(offset) s++;
	chr *= 16;
	do {
		chr += 4096;
		len++;
		*t = chr;
		(offset) t += 4;
		chr = *s; /* MOVZX */
		(offset) s++;
		chr *= 16;
	} while (!= 0);

	cmd->length = len;
	// (int) [cmd->string + len * 4] = 0x0000;
//	asmout("MOV DWORD PTR SS:[ESP+36+ECX*4],0");
	*t = chr;

	PUSH(SS);
	POP(FS);
	DB(0x9a); DD(0); DW((short) GAPI_sel);
	ESP += 512;
	POPAD();
	POP(FS);
	return;
}

void near ui8toa()
/*  AL‚ğ[DS:ESI]‚Ö */
{
	unsigned char *s == DS:ESI;
	PUSH(EAX);
	AH = AL;
	AL >>= 4;
	EAX &= 0x0f0f;
	if ((unsigned) AL > 9)
		AL += /* 'A' - '0' - 0x0a */ 0x41 - 0x30 - 0x0a;
	if ((unsigned) AH > 9)
		AH += /* 'A' - '0' - 0x0a */ 0x41 - 0x30 - 0x0a;
	EAX += /* '00' */ 0x3030;
	s[0] = AL;
	s[1] = AH;
	POP(EAX);
	return;
}


void near ui16toa()
/*  AX‚ğ[DS:ESI]‚Ö */
{
	XCHG(AH, AL);
	ui8toa();
	ESI += 2;
	XCHG(AH, AL);
	ui8toa();
	ESI -= 2;
	return;
}

void near ui32toa()
/* EAX‚ğ[DS:ESI]‚Ö */
{
	ROR(EAX, 16); /* ãˆÊ‚Æ‰ºˆÊ‚ğŒğŠ· */
	ui16toa();
	ESI += 4;
	ROL(EAX, 16); /* ãˆÊ‚Æ‰ºˆÊ‚ğŒğŠ· */
	ui16toa();
	ESI -= 4;
	return;
}

void far int08()
{
	PUSHAD();
	ESI = CODE::"INT 0x08 Double Fault\0";
	goto put_int_status_ec;
}

void far int10()
{
	PUSHAD();
	ESI = CODE::"INT 0x0A Invalid TSS\0";
	goto put_int_status_ec;
}

void far int12()
{
	PUSHAD();
	ESI = CODE::"INT 0x0C Stack Protect\0";
	goto put_int_status_ec;
}

void far int02()
{
	PUSH(EAX); // ƒ_ƒ~[‚ÌƒGƒ‰[ƒR[ƒh
	PUSHAD();
	ESI = CODE::"INT 0x02 Non Maskable Interrupt\0";
	#if (defined(TOWNS))
		EDX = 0x0602;
		AL = 0xb2; /* NMI ACK */
		OUT(DX, AL);	
	#endif
	goto put_int_status;
}

void far int13()
{
	unsigned int                         all_sel       ==  1 * 8;

	PUSHAD();
	EAX = [SS:ESP + 32 + 4 + 8] /* EFLAGS */;
	TEST(EAX, 0x00020000);
	if (== 0) {
		ESI = CODE::"INT 0x0D General Protect\0";
		goto put_int_status_ec;
	}

	#if (defined(PCAT))
		ECX = (unsigned short) [SS:ESP + 32 + 8]; // CS
		EAX = (unsigned short) [SS:ESP + 32 + 4]; // IP
	//	PUSH(DS);
		ECX *= 16;
		PUSH(SEL_ALL);
		EAX += ECX;
		POP(DS);
		CL = [DS:EAX]; // –½—ßƒtƒFƒbƒ`

		// ‚Æ‚è‚ ‚¦‚¸ASTI‚âCLI‚Í‘S‚Ä–³‹B
	//	if (CL == 0x67)
	//		goto op_adrsiz;
		if (CL == 0x66)
			goto op_opsiz;
		if (CL == 0xfa)
			goto skip1byte;
		if (CL == 0xfb)
			goto skip1byte;
		if (CL == 0xcd)	// INT(n)
			goto op_int_n;
	//	if (CL == 0xcc)
	//		goto op_int_3;
		if (CL == 0xcf)
			goto op_iret;
		if (CL == 0xec)
			goto op_inbDX;
		if (CL == 0xed)
			goto op_inwDX;
		if (CL == 0xee)
			goto op_outbDX;
		if (CL == 0xef)
			goto op_outwDX;
		if (CL == 0xe4)
			goto op_inbIb;
		if (CL == 0xe5)
			goto op_inwIb;
		if (CL == 0xe6)
			goto op_outbIb;
		if (CL == 0xe7)
			goto op_outwIb;
		if (CL == 0x9c)
			goto op_pushf;
		if (CL == 0x9d)
			goto op_popf;
	//	if (CL == 0x6c)
	//		goto op_insb;
	//	if (CL == 0x6d)
	//		goto op_insw;
		if (CL == 0x6e)
			goto op_outsb;
		if (CL == 0x6f)
			goto op_outsw;
		if (CL == 0xf3)
			goto op_rep;
		if (CL == 0x2e)
			goto op_CS;
		if (CL == 0x36)
			goto op_SS;
	//	if (CL == 0x3e)
	//		goto op_DS;
		if (CL == 0x26)
			goto op_ES;
	#endif
	INT(0x03);

#if (defined(PCAT))
op_adrsiz:
	CL = [DS:EAX + 1]; // –½—ßƒtƒFƒbƒ`
/*	if (CL == 0x66)
		goto op_adrsiz_opsiz;
	if (CL == 0x6c)
		goto op_adrsiz_insb;
	if (CL == 0x6d)
		goto op_adrsiz_insw;
	if (CL == 0x6e)
		goto op_adrsiz_outsb;
	if (CL == 0x6f)
		goto op_adrsiz_outsw;
*/	INT(0x03);

op_opsiz:
	CL = [DS:EAX + 1]; // –½—ßƒtƒFƒbƒ`
	if (CL == 0xed)
		goto op_indDX;
	if (CL == 0xef)
		goto op_outdDX;
	if (CL == 0xe5)
		goto op_indIb;
	if (CL == 0xe7)
		goto op_outdIb;
	if (CL == 0x9c)
		goto op_pushfd;
	if (CL == 0x9d)
		goto op_popfd;
//	if (CL == 0x6d)
//		goto op_insd;
//	if (CL == 0x6f)
//		goto op_outsd;
	INT(0x03);

op_rep:
	CL = [DS:EAX + 1]; // –½—ßƒtƒFƒbƒ`
/*	if (CL == 0x67)
		goto op_rep_adrsiz;
	if (CL == 0x66)
		goto op_rep_opsiz;
	if (CL == 0x6c)
		goto op_rep_insb;
	if (CL == 0x6d)
		goto op_rep_insw;
*/	if (CL == 0x6e)
		goto op_rep_outsb;
	if (CL == 0x6f)
		goto op_rep_outsw;
	if (CL == 0x2e)
		goto op_rep_CS;
	if (CL == 0x36)
		goto op_rep_SS;
//	if (CL == 0x3e)
//		goto op_rep_DS;
	if (CL == 0x26)
		goto op_rep_ES;
	INT(0x03);

op_CS:
	CL = [DS:EAX + 1]; // –½—ßƒtƒFƒbƒ`
	if (CL == 0x6e)
		goto op_CS_outsb;
	if (CL == 0x6f)
		goto op_CS_outsw;
	INT(0x03);

op_ES:
	CL = [DS:EAX + 1]; // –½—ßƒtƒFƒbƒ`
	if (CL == 0x6e)
		goto op_ES_outsb;
	if (CL == 0x6f)
		goto op_ES_outsw;
	INT(0x03);

op_SS:
	CL = [DS:EAX + 1]; // –½—ßƒtƒFƒbƒ`
	if (CL == 0x6e)
		goto op_SS_outsb;
	if (CL == 0x6f)
		goto op_SS_outsw;
	INT(0x03);

op_rep_adrsiz:
	CL = [DS:EAX + 2]; // –½—ßƒtƒFƒbƒ`
/*	if (CL == 0x66)
		goto op_rep_adrsiz_opsiz;
	if (CL == 0x6c)
		goto op_rep_adrsiz_insb;
	if (CL == 0x6d)
		goto op_rep_adrsiz_insw;
	if (CL == 0x6e)
		goto op_rep_adrsiz_outsb;
	if (CL == 0x6f)
		goto op_rep_adrsiz_outsw;
*/	INT(0x03);

op_adrsiz_opsiz:
	CL = [DS:EAX + 2]; // –½—ßƒtƒFƒbƒ`
/*	if (CL == 0x6d)
		goto op_adrsiz_insd;
	if (CL == 0x6f)
		goto op_adrsiz_outsd;
*/	INT(0x03);

op_rep_adrsiz_opsiz:
	CL = [DS:EAX + 3]; // –½—ßƒtƒFƒbƒ`
/*	if (CL == 0x6d)
		goto op_rep_adrsiz_insd;
	if (CL == 0x6f)
		goto op_rep_adrsiz_outsd;
*/	INT(0x03);

op_rep_CS:
	CL = [DS:EAX + 2]; // –½—ßƒtƒFƒbƒ`
	if (CL == 0x6e)
		goto op_rep_CS_outsb;
	if (CL == 0x6f)
		goto op_rep_CS_outsw;
	INT(0x03);

op_rep_SS:
	CL = [DS:EAX + 2]; // –½—ßƒtƒFƒbƒ`
	if (CL == 0x6e)
		goto op_rep_SS_outsb;
	if (CL == 0x6f)
		goto op_rep_SS_outsw;
	INT(0x03);

op_rep_ES:
	CL = [DS:EAX + 2]; // –½—ßƒtƒFƒbƒ`
	if (CL == 0x6e)
		goto op_rep_ES_outsb;
	if (CL == 0x6f)
		goto op_rep_ES_outsw;
	INT(0x03);

skip1byte:
	(int) [SS:ESP + 32 + 4]++; // EIP
//	POP(EAX); // skip old DS
	POPAD();
	ESP += 4; // skip EC
	IRETD();

op_int_n:
	EBX = (unsigned char) [DS:EAX + 1]; // fetch n
	EDI = (unsigned short) [SS:ESP + 32 + 20]; // SS
	ESI = (unsigned short) [SS:ESP + 32 + 16]; // SP
	EDI *= 16;
	AX = [SS:ESP + 32 + 4]; // IP
	ESI += EDI;
	AX += 2;
	CX = [SS:ESP + 32 + 8]; // CS
	(short) [DS:ESI - 6] = AX;
	asmout("MOV EAX,DS:[EBX*4]");
	BX = [SS:ESP + 32 + 12]; // FLAGS
	(short) [DS:ESI - 4] = CX;
	(short) [SS:ESP + 32 + 4] /* IP */ = AX;
	(short) [DS:ESI - 2] = BX;
	(unsigned int) EAX >>= 16;
	(short) [SS:ESP + 32 + 16] -= 6; // SP
	[SS:ESP + 32 + 8] /* CS */ = EAX;
//	POP(EAX); // skip old DS
	POPAD();
	ESP += 4; // skip EC
	IRETD();

op_inbDX:
	EDX = (short) [SS:ESP + 20 /* EDX */];
	IN(AL, DX);
	[SS:ESP + 28 /* EAX */] = AL;
	// •K—v‚È‚çA‚±‚±‚Ålog‚ğ‚Æ‚é

#if (defined(V86LOG))
PUSHAD();
EBX = [DS:0x108000];
if ((unsigned) EBX < 0x200000) {
(char) [DS:EBX + 0] = 0x01;
[DS:EBX + 2] = DX;
[DS:EBX + 4] = EAX;
EBX += 8;
[DS:0x108000] = EBX;
}
POPAD();
#endif

#if 0
	if (EDX == 0x03da) {
		(char) [SS:ESP + 28 /* EAX */] ^= 0x09;
	}

	ESP -= 80;
	MOV(EAX, SS);
	DS = AX;
	GS = AX;
	ESI = ESP;
	EAX = (unsigned short) [SS:ESP + 32 + 8 + 80]; // CS
	ui16toa();
	(char) [SS:ESP + 4] = 0x3a /* ':' */;
	LEA(ESI, [SS:ESP + 5]);
	EAX = (unsigned short) [SS:ESP + 32 + 4 + 80]; // IP
	(int) [SS:ESP + 12] = 0x20202020 /* '    ' */;
	ui32toa();
	(int) [SS:ESP + 16] = 0x44626e69 /* 'inbD' */;
	(int) [SS:ESP + 20] = 0x20202058 /* 'X   ' */;
	(int) [SS:ESP + 24] = 0x3d584145 /* 'EAX=' */;
	LEA(ESI, [SS:ESP + 28]);
	EAX = [SS:ESP + 28 /* EAX */ + 80];
	ui32toa();
	(int) [SS:ESP + 32] = 0x3d584420 /* ' DX=' */;
	LEA(ESI, [SS:ESP + 36]);
	EAX = [SS:ESP + 20 /* EDX */ + 80];
	ui16toa();
	(char) [SS:ESP + 40] = 0;
	ESI = ESP;
	EAX = 0;
	ECX = 0;
	EDX = 0x000f;
	output_string();
	ESP += 80;
#endif
	(int) [SS:ESP + 32 + 4]++; // EIP
	POPAD();
	ESP += 4; // skip EC
	IRETD();

op_inwDX:
	EDX = [SS:ESP + 20 /* EDX */];
	IN(AX, DX);
	[SS:ESP + 28 /* EAX */] = AX;
	// •K—v‚È‚çA‚±‚±‚Ålog‚ğ‚Æ‚é

#if (defined(V86LOG))
PUSHAD();
EBX = [DS:0x108000];
if ((unsigned) EBX < 0x200000) {
(char) [DS:EBX + 0] = 0x02;
[DS:EBX + 2] = DX;
[DS:EBX + 4] = EAX;
EBX += 8;
[DS:0x108000] = EBX;
}
POPAD();
#endif

#if 0
	ESP -= 80;
	MOV(EAX, SS);
	DS = AX;
	GS = AX;
	ESI = ESP;
	EAX = (unsigned short) [SS:ESP + 32 + 8 + 80]; // CS
	ui16toa();
	(char) [SS:ESP + 4] = 0x3a /* ':' */;
	LEA(ESI, [SS:ESP + 5]);
	EAX = (unsigned short) [SS:ESP + 32 + 4 + 80]; // IP
	(int) [SS:ESP + 12] = 0x20202020 /* '    ' */;
	ui32toa();
	(int) [SS:ESP + 16] = 0x44776e69 /* 'inwD' */;
	(int) [SS:ESP + 20] = 0x20202058 /* 'X   ' */;
	(int) [SS:ESP + 24] = 0x3d584145 /* 'EAX=' */;
	LEA(ESI, [SS:ESP + 28]);
	EAX = [SS:ESP + 28 /* EAX */ + 80];
	ui32toa();
	(int) [SS:ESP + 32] = 0x3d584420 /* ' DX=' */;
	LEA(ESI, [SS:ESP + 36]);
	EAX = [SS:ESP + 20 /* EDX */ + 80];
	ui16toa();
	(char) [SS:ESP + 40] = 0;
	ESI = ESP;
	EAX = 0;
	ECX = 0;
	EDX = 0x000f;
	output_string();
	ESP += 80;
#endif
	(int) [SS:ESP + 32 + 4]++; // EIP
	POPAD();
	ESP += 4; // skip EC
	IRETD();

op_indDX:
	EDX = [SS:ESP + 20 /* EDX */];
	IN(EAX, DX);
	[SS:ESP + 28 /* EAX */] = EAX;
	// •K—v‚È‚çA‚±‚±‚Ålog‚ğ‚Æ‚é

#if (defined(V86LOG))
PUSHAD();
EBX = [DS:0x108000];
if ((unsigned) EBX < 0x200000) {
(char) [DS:EBX + 0] = 0x04;
[DS:EBX + 2] = DX;
[DS:EBX + 4] = EAX;
EBX += 8;
[DS:0x108000] = EBX;
}
POPAD();
#endif

#if 0
	ESP -= 80;
	MOV(EAX, SS);
	DS = AX;
	GS = AX;
	ESI = ESP;
	EAX = (unsigned short) [SS:ESP + 32 + 8 + 80]; // CS
	ui16toa();
	(char) [SS:ESP + 4] = 0x3a /* ':' */;
	LEA(ESI, [SS:ESP + 5]);
	EAX = (unsigned short) [SS:ESP + 32 + 4 + 80]; // IP
	(int) [SS:ESP + 12] = 0x20202020 /* '    ' */;
	ui32toa();
	(int) [SS:ESP + 16] = 0x44646e69 /* 'indD' */;
	(int) [SS:ESP + 20] = 0x20202058 /* 'X   ' */;
	(int) [SS:ESP + 24] = 0x3d584145 /* 'EAX=' */;
	LEA(ESI, [SS:ESP + 28]);
	EAX = [SS:ESP + 28 /* EAX */ + 80];
	ui32toa();
	(int) [SS:ESP + 32] = 0x3d584420 /* ' DX=' */;
	LEA(ESI, [SS:ESP + 36]);
	EAX = [SS:ESP + 20 /* EDX */ + 80];
	ui16toa();
	(char) [SS:ESP + 40] = 0;
	ESI = ESP;
	EAX = 0;
	ECX = 0;
	EDX = 0x000f;
	output_string();
	ESP += 80;
#endif
	(int) [SS:ESP + 32 + 4] += 2; // EIP
	POPAD();
	ESP += 4; // skip EC
	IRETD();

op_outbDX:
	EAX = [SS:ESP + 28 /* EAX */];
	EDX = [SS:ESP + 20 /* EDX */];
	OUT(DX, AL);
	// •K—v‚È‚çA‚±‚±‚Ålog‚ğ‚Æ‚é

#if (defined(V86LOG))
PUSHAD();
EBX = [DS:0x108000];
if ((unsigned) EBX < 0x200000) {
(char) [DS:EBX + 0] = 0x11;
[DS:EBX + 2] = DX;
[DS:EBX + 4] = EAX;
EBX += 8;
[DS:0x108000] = EBX;
}
POPAD();
#endif

	(int) [SS:ESP + 32 + 4]++; // EIP
	POPAD();
	ESP += 4; // skip EC
	IRETD();

op_outwDX:
	EAX = [SS:ESP + 28 /* EAX */];
	EDX = [SS:ESP + 20 /* EDX */];
	OUT(DX, AX);
	// •K—v‚È‚çA‚±‚±‚Ålog‚ğ‚Æ‚é

#if (defined(V86LOG))
PUSHAD();
EBX = [DS:0x108000];
if ((unsigned) EBX < 0x200000) {
(char) [DS:EBX + 0] = 0x12;
[DS:EBX + 2] = DX;
[DS:EBX + 4] = EAX;
EBX += 8;
[DS:0x108000] = EBX;
}
POPAD();
#endif

	(int) [SS:ESP + 32 + 4]++; // EIP
	POPAD();
	ESP += 4; // skip EC
	IRETD();

op_outdDX:
	EAX = [SS:ESP + 28 /* EAX */];
	EDX = [SS:ESP + 20 /* EDX */];
	OUT(DX, EAX);

#if (defined(V86LOG))
PUSHAD();
EBX = [DS:0x108000];
if ((unsigned) EBX < 0x200000) {
(char) [DS:EBX + 0] = 0x14;
[DS:EBX + 2] = DX;
[DS:EBX + 4] = EAX;
EBX += 8;
[DS:0x108000] = EBX;
}
POPAD();
#endif

	// •K—v‚È‚çA‚±‚±‚Ålog‚ğ‚Æ‚é
	(int) [SS:ESP + 32 + 4] += 2; // EIP
	POPAD();
	ESP += 4; // skip EC
	IRETD();

op_pushf:
	EDI = (unsigned short) [SS:ESP + 32 + 20]; // SS
	ESI = (unsigned short) [SS:ESP + 32 + 16]; // SP
	EDI *= 16;
	AX = [SS:ESP + 32 + 12]; // FLAGS
	(short) [DS:ESI + EDI - 2] = AX;
	(short) [SS:ESP + 32 + 16] -= 2; // SP
	(int) [SS:ESP + 32 + 4]++; // EIP
	POPAD();
	ESP += 4; // skip EC
	IRETD();

op_popf:
	EDI = (unsigned short) [SS:ESP + 32 + 20]; // SS
	ESI = (unsigned short) [SS:ESP + 32 + 16]; // SP
	EDI *= 16;
	AX = (short) [DS:ESI + EDI];
	(short) [SS:ESP + 32 + 16] += 2; // SP
	AX &= 0x8fff;
	[SS:ESP + 32 + 12] = AX; // FLAGS
	(int) [SS:ESP + 32 + 4]++; // EIP
	POPAD();
	ESP += 4; // skip EC
	IRETD();

op_inbIb:
	EDX = (unsigned char) [DS:EAX + 1]; // fetch Ib
	IN(AL, DX);
	[SS:ESP + 28 /* EAX */] = AL;
	// •K—v‚È‚çA‚±‚±‚Ålog‚ğ‚Æ‚é

#if (defined(V86LOG))
PUSHAD();
EBX = [DS:0x108000];
if ((unsigned) EBX < 0x200000) {
(char) [DS:EBX + 0] = 0x01;
[DS:EBX + 2] = DX;
[DS:EBX + 4] = EAX;
EBX += 8;
[DS:0x108000] = EBX;
}
POPAD();
#endif

#if 0
	PUSH(EDX);
	ESP -= 80;
	MOV(EAX, SS);
	DS = AX;
	GS = AX;
	ESI = ESP;
	EAX = (unsigned short) [SS:ESP + 32 + 8 + 80]; // CS
	ui16toa();
	(char) [SS:ESP + 4] = 0x3a /* ':' */;
	LEA(ESI, [SS:ESP + 5]);
	EAX = (unsigned short) [SS:ESP + 32 + 4 + 80]; // IP
	(int) [SS:ESP + 12] = 0x20202020 /* '    ' */;
	ui32toa();
	(int) [SS:ESP + 16] = 0x49626e69 /* 'inbI' */;
	(int) [SS:ESP + 20] = 0x20202062 /* 'b   ' */;
	(int) [SS:ESP + 24] = 0x3d584145 /* 'EAX=' */;
	LEA(ESI, [SS:ESP + 28]);
	EAX = [SS:ESP + 28 /* EAX */ + 80];
	ui32toa();
	(int) [SS:ESP + 32] = 0x3d624920 /* ' Ib=' */;
	LEA(ESI, [SS:ESP + 36]);
	EAX = [SS:ESP + 80 /* Ib */];
	ui16toa();
	(char) [SS:ESP + 40] = 0;
	ESI = ESP;
	EAX = 0;
	ECX = 0;
	EDX = 0x000f;
	output_string();
	ESP += 84;
#endif
	(int) [SS:ESP + 32 + 4] += 2; // EIP
	POPAD();
	ESP += 4; // skip EC
	IRETD();

op_inwIb:
	EDX = (unsigned char) [DS:EAX + 1]; // fetch Ib
	IN(AX, DX);
	[SS:ESP + 28 /* EAX */] = AX;
	// •K—v‚È‚çA‚±‚±‚Ålog‚ğ‚Æ‚é
#if (defined(V86LOG))
PUSHAD();
EBX = [DS:0x108000];
if ((unsigned) EBX < 0x200000) {
(char) [DS:EBX + 0] = 0x02;
[DS:EBX + 2] = DX;
[DS:EBX + 4] = EAX;
EBX += 8;
[DS:0x108000] = EBX;
}
POPAD();
#endif

#if 0
	PUSH(EDX);
	ESP -= 80;
	MOV(EAX, SS);
	DS = AX;
	GS = AX;
	ESI = ESP;
	EAX = (unsigned short) [SS:ESP + 32 + 8 + 80]; // CS
	ui16toa();
	(char) [SS:ESP + 4] = 0x3a /* ':' */;
	LEA(ESI, [SS:ESP + 5]);
	EAX = (unsigned short) [SS:ESP + 32 + 4 + 80]; // IP
	(int) [SS:ESP + 12] = 0x20202020 /* '    ' */;
	ui32toa();
	(int) [SS:ESP + 16] = 0x49776e69 /* 'inwI' */;
	(int) [SS:ESP + 20] = 0x20202062 /* 'b   ' */;
	(int) [SS:ESP + 24] = 0x3d584145 /* 'EAX=' */;
	LEA(ESI, [SS:ESP + 28]);
	EAX = [SS:ESP + 28 /* EAX */ + 80];
	ui32toa();
	(int) [SS:ESP + 32] = 0x3d624920 /* ' Ib=' */;
	LEA(ESI, [SS:ESP + 36]);
	EAX = [SS:ESP + 80 /* Ib */];
	ui16toa();
	(char) [SS:ESP + 40] = 0;
	ESI = ESP;
	EAX = 0;
	ECX = 0;
	EDX = 0x000f;
	output_string();
	ESP += 84;
#endif
	(int) [SS:ESP + 32 + 4] += 2; // EIP
	POPAD();
	ESP += 4; // skip EC
	IRETD();

op_indIb:
	EDX = (unsigned char) [DS:EAX + 1]; // fetch Ib
	IN(EAX, DX);
	[SS:ESP + 28 /* EAX */] = EAX;
	// •K—v‚È‚çA‚±‚±‚Ålog‚ğ‚Æ‚é

#if (defined(V86LOG))
PUSHAD();
EBX = [DS:0x108000];
if ((unsigned) EBX < 0x200000) {
(char) [DS:EBX + 0] = 0x04;
[DS:EBX + 2] = DX;
[DS:EBX + 4] = EAX;
EBX += 8;
[DS:0x108000] = EBX;
}
POPAD();
#endif

#if 0
	PUSH(EDX);
	ESP -= 80;
	MOV(EAX, SS);
	DS = AX;
	GS = AX;
	ESI = ESP;
	EAX = (unsigned short) [SS:ESP + 32 + 8 + 80]; // CS
	ui16toa();
	(char) [SS:ESP + 4] = 0x3a /* ':' */;
	LEA(ESI, [SS:ESP + 5]);
	EAX = (unsigned short) [SS:ESP + 32 + 4 + 80]; // IP
	(int) [SS:ESP + 12] = 0x20202020 /* '    ' */;
	ui32toa();
	(int) [SS:ESP + 16] = 0x49646e69 /* 'indI' */;
	(int) [SS:ESP + 20] = 0x20202062 /* 'b   ' */;
	(int) [SS:ESP + 24] = 0x3d584145 /* 'EAX=' */;
	LEA(ESI, [SS:ESP + 28]);
	EAX = [SS:ESP + 28 /* EAX */ + 80];
	ui32toa();
	(int) [SS:ESP + 32] = 0x3d624920 /* ' Ib=' */;
	LEA(ESI, [SS:ESP + 36]);
	EAX = [SS:ESP + 80 /* Ib */];
	ui16toa();
	(char) [SS:ESP + 40] = 0;
	ESI = ESP;
	EAX = 0;
	ECX = 0;
	EDX = 0x000f;
	output_string();
	ESP += 84;
#endif
	(int) [SS:ESP + 32 + 4] += 3; // EIP
	POPAD();
	ESP += 4; // skip EC
	IRETD();

op_iret:
	EDI = (unsigned short) [SS:ESP + 32 + 20]; // SS
	ESI = (unsigned short) [SS:ESP + 32 + 16]; // SP
	EDI *= 16;
	ESI += EDI;
	AX = (short) [DS:ESI    ]; // IP
	ECX = (unsigned short) [DS:ESI + 2]; // CS
	DX = (short) [DS:ESI + 4]; // FLAGS
	(short) [SS:ESP + 32 + 16] += 6; // SP
	DX &= 0x8fff;
	(short) [SS:ESP + 32 + 4] = AX; // IP
	[SS:ESP + 32 + 8] = ECX; // CS
	[SS:ESP + 32 + 12] = DX; // FLAGS
	POPAD();
	ESP += 4; // skip EC
	IRETD();

op_outbIb:
	EDX = (unsigned char) [DS:EAX + 1]; // fetch Ib
	EAX = [SS:ESP + 28 /* EAX */];
	OUT(DX, AL);
	// •K—v‚È‚çA‚±‚±‚Ålog‚ğ‚Æ‚é
#if (defined(V86LOG))
PUSHAD();
EBX = [DS:0x108000];
if ((unsigned) EBX < 0x200000) {
(char) [DS:EBX + 0] = 0x11;
[DS:EBX + 2] = DX;
[DS:EBX + 4] = EAX;
EBX += 8;
[DS:0x108000] = EBX;
}
POPAD();
#endif

	(int) [SS:ESP + 32 + 4] += 2; // EIP
	POPAD();
	ESP += 4; // skip EC
	IRETD();

op_outwIb:
	EDX = (unsigned char) [DS:EAX + 1]; // fetch Ib
	EAX = [SS:ESP + 28 /* EAX */];
	OUT(DX, AX);
	// •K—v‚È‚çA‚±‚±‚Ålog‚ğ‚Æ‚é
#if (defined(V86LOG))
PUSHAD();
EBX = [DS:0x108000];
if ((unsigned) EBX < 0x200000) {
(char) [DS:EBX + 0] = 0x12;
[DS:EBX + 2] = DX;
[DS:EBX + 4] = EAX;
EBX += 8;
[DS:0x108000] = EBX;
}
POPAD();
#endif

	(int) [SS:ESP + 32 + 4] += 2; // EIP
	POPAD();
	ESP += 4; // skip EC
	IRETD();

op_outdIb:
	EDX = (unsigned char) [DS:EAX + 1]; // fetch Ib
	EAX = [SS:ESP + 28 /* EAX */];
	OUT(DX, EAX);
	// •K—v‚È‚çA‚±‚±‚Ålog‚ğ‚Æ‚é
#if (defined(V86LOG))
PUSHAD();
EBX = [DS:0x108000];
if ((unsigned) EBX < 0x200000) {
(char) [DS:EBX + 0] = 0x14;
[DS:EBX + 2] = DX;
[DS:EBX + 4] = EAX;
EBX += 8;
[DS:0x108000] = EBX;
}
POPAD();
#endif

	(int) [SS:ESP + 32 + 4] += 3; // EIP
	POPAD();
	ESP += 4; // skip EC
	IRETD();

op_pushfd:
	EDI = (unsigned short) [SS:ESP + 32 + 20]; // SS
	ESI = (unsigned short) [SS:ESP + 32 + 16]; // SP
	EDI *= 16;
	EAX = [SS:ESP + 32 + 12]; // EFLAGS
	(int) [DS:ESI + EDI - 4] = EAX;
	(short) [SS:ESP + 32 + 16] -= 4; // SP
	(int) [SS:ESP + 32 + 4] += 2; // EIP
	POPAD();
	ESP += 4; // skip EC
	IRETD();

op_popfd:
	EDI = (unsigned short) [SS:ESP + 32 + 20]; // SS
	ESI = (unsigned short) [SS:ESP + 32 + 16]; // SP
	EDI *= 16;
	EAX = (int) [DS:ESI + EDI];
	(short) [SS:ESP + 32 + 16] += 4; // SP
	[SS:ESP + 32 + 12] = AX; // FLAGS
	(int) [SS:ESP + 32 + 4] += 2; // EIP
	POPAD();
	ESP += 4; // skip EC
	IRETD();

op_outsb:
	EDI = (unsigned short) [SS:ESP + 32 + 28]; // DS
op_seg_outsb:
	ESI = (unsigned short) [SS:ESP + 4]; // SI
	EDI *= 16;
	asmout("TEST BYTE PTR SS:[ESP+32+13],04H");
	EDX = (int) [SS:ESP + 20 /* EDX */];
	AL  = (char) [DS:ESI + EDI];
	ECX = 1;
	OUT(DX, AL);
	// •K—v‚È‚çA‚±‚±‚Ålog‚ğ‚Æ‚é
	if (!= 0)
		ECX =- ECX;

#if (defined(V86LOG))
PUSHAD();
EBX = [DS:0x108000];
if ((unsigned) EBX < 0x200000) {
(char) [DS:EBX + 0] = 0x11;
[DS:EBX + 2] = DX;
[DS:EBX + 4] = EAX;
EBX += 8;
[DS:0x108000] = EBX;
}
POPAD();
#endif

	(unsigned short) [SS:ESP + 4 /* SI */] += CX;
	(int) [SS:ESP + 32 + 4]++; // EIP
	POPAD();
	ESP += 4; // skip EC
	IRETD();

op_outsw:
	EDI = (unsigned short) [SS:ESP + 32 + 28]; // DS
op_seg_outsw:
	ESI = (unsigned short) [SS:ESP + 4]; // SI
	EDI *= 16;
	asmout("TEST BYTE PTR SS:[ESP+32+13],04H");
	EDX = (int) [SS:ESP + 20 /* EDX */];
	AX  = (short) [DS:ESI + EDI];
	ECX = 2;
	OUT(DX, AX);
	// •K—v‚È‚çA‚±‚±‚Ålog‚ğ‚Æ‚é
	if (!= 0)
		ECX =- ECX;

#if (defined(V86LOG))
PUSHAD();
EBX = [DS:0x108000];
if ((unsigned) EBX < 0x200000) {
(char) [DS:EBX + 0] = 0x12;
[DS:EBX + 2] = DX;
[DS:EBX + 4] = EAX;
EBX += 8;
[DS:0x108000] = EBX;
}
POPAD();
#endif

	(unsigned short) [SS:ESP + 4 /* SI */] += CX;
	(int) [SS:ESP + 32 + 4]++; // EIP
	POPAD();
	ESP += 4; // skip EC
	IRETD();

op_CS_outsb:
	EDI = (unsigned short) [SS:ESP + 32 +  8]; // CS
	(int) [SS:ESP + 32 + 4]++; // EIP
	goto op_seg_outsb;

op_SS_outsb:
	EDI = (unsigned short) [SS:ESP + 32 + 20]; // ES
	(int) [SS:ESP + 32 + 4]++; // EIP
	goto op_seg_outsb;

op_ES_outsb:
	EDI = (unsigned short) [SS:ESP + 32 + 24]; // ES
	(int) [SS:ESP + 32 + 4]++; // EIP
	goto op_seg_outsb;

op_CS_outsw:
	EDI = (unsigned short) [SS:ESP + 32 +  8]; // CS
	(int) [SS:ESP + 32 + 4]++; // EIP
	goto op_seg_outsw;

op_SS_outsw:
	EDI = (unsigned short) [SS:ESP + 32 + 20]; // ES
	(int) [SS:ESP + 32 + 4]++; // EIP
	goto op_seg_outsw;

op_ES_outsw:
	EDI = (unsigned short) [SS:ESP + 32 + 24]; // ES
	(int) [SS:ESP + 32 + 4]++; // EIP
	goto op_seg_outsw;

op_rep_outsb:
	EDI = (unsigned short) [SS:ESP + 32 + 28]; // DS
op_rep_seg_outsb:
	ESI = (unsigned short) [SS:ESP + 4]; // SI
	EDI *= 16;
	ECX = (unsigned short) [SS:ESP + 24]; // CX
	asmout("TEST BYTE PTR SS:[ESP+32+13],04H");
	EDX = (int) [SS:ESP + 20 /* EDX */];
	if (== 0) {
		do {
			AL  = (char) [DS:ESI + EDI];
			ESI++;
			OUT(DX, AL);

#if (defined(V86LOG))
PUSHAD();
EBX = [DS:0x108000];
if ((unsigned) EBX < 0x200000) {
(char) [DS:EBX + 0] = 0x11;
[DS:EBX + 2] = DX;
[DS:EBX + 4] = EAX;
EBX += 8;
[DS:0x108000] = EBX;
}
POPAD();
#endif


			ESI &= 0xffff;
			ECX--;
		} while (!= 0);
	} else {
		do {
			AL  = (char) [DS:ESI + EDI];
			ESI--;
			OUT(DX, AL);

#if (defined(V86LOG))
PUSHAD();
EBX = [DS:0x108000];
if ((unsigned) EBX < 0x200000) {
(char) [DS:EBX + 0] = 0x11;
[DS:EBX + 2] = DX;
[DS:EBX + 4] = EAX;
EBX += 8;
[DS:0x108000] = EBX;
}
POPAD();
#endif

			ESI &= 0xffff;
			ECX--;
		} while (!= 0);
	}
	(unsigned short) [SS:ESP + 4 /* SI */] = SI;
	(unsigned short) [SS:ESP + 24 /* CX */] = CX;
	(int) [SS:ESP + 32 + 4] += 2; // EIP
	POPAD();
	ESP += 4; // skip EC
	IRETD();

op_rep_outsw:
	EDI = (unsigned short) [SS:ESP + 32 + 28]; // DS
op_rep_seg_outsw:
	ESI = (unsigned short) [SS:ESP + 4]; // SI
	EDI *= 16;
	ECX = (unsigned short) [SS:ESP + 24]; // CX
	asmout("TEST BYTE PTR SS:[ESP+32+13],04H");
	EDX = (int) [SS:ESP + 20 /* EDX */];
	if (== 0) {
		do {
			AX  = (short) [DS:ESI + EDI];
			ESI += 2;
			OUT(DX, AX);
#if (defined(V86LOG))
PUSHAD();
EBX = [DS:0x108000];
if ((unsigned) EBX < 0x200000) {
(char) [DS:EBX + 0] = 0x12;
[DS:EBX + 2] = DX;
[DS:EBX + 4] = EAX;
EBX += 8;
[DS:0x108000] = EBX;
}
POPAD();
#endif

			ESI &= 0xffff;
			ECX--;
		} while (!= 0);
	} else {
		do {
			AX  = (short) [DS:ESI + EDI];
			ESI -= 2;
			OUT(DX, AX);
#if (defined(V86LOG))
PUSHAD();
EBX = [DS:0x108000];
if ((unsigned) EBX < 0x200000) {
(char) [DS:EBX + 0] = 0x12;
[DS:EBX + 2] = DX;
[DS:EBX + 4] = EAX;
EBX += 8;
[DS:0x108000] = EBX;
}
POPAD();
#endif

			ESI &= 0xffff;
			ECX--;
		} while (!= 0);
	}
	(unsigned short) [SS:ESP + 4 /* SI */] = SI;
	(unsigned short) [SS:ESP + 24 /* CX */] = CX;
	(int) [SS:ESP + 32 + 4] += 2; // EIP
	POPAD();
	ESP += 4; // skip EC
	IRETD();

op_rep_CS_outsb:
	EDI = (unsigned short) [SS:ESP + 32 +  8]; // CS
	(int) [SS:ESP + 32 + 4]++; // EIP
	goto op_rep_seg_outsb;

op_rep_SS_outsb:
	EDI = (unsigned short) [SS:ESP + 32 + 20]; // ES
	(int) [SS:ESP + 32 + 4]++; // EIP
	goto op_rep_seg_outsb;

op_rep_ES_outsb:
	EDI = (unsigned short) [SS:ESP + 32 + 24]; // ES
	(int) [SS:ESP + 32 + 4]++; // EIP
	goto op_rep_seg_outsb;

op_rep_CS_outsw:
	EDI = (unsigned short) [SS:ESP + 32 +  8]; // CS
	(int) [SS:ESP + 32 + 4]++; // EIP
	goto op_rep_seg_outsw;

op_rep_SS_outsw:
	EDI = (unsigned short) [SS:ESP + 32 + 20]; // ES
	(int) [SS:ESP + 32 + 4]++; // EIP
	goto op_rep_seg_outsw;

op_rep_ES_outsw:
	EDI = (unsigned short) [SS:ESP + 32 + 24]; // ES
	(int) [SS:ESP + 32 + 4]++; // EIP
	goto op_rep_seg_outsw;

#endif

//op_int_3:
//	INT(0x03);
}

#if (defined(PCAT))

void v86irq()
/* EAX‚ÉƒxƒNƒ^ */
{
	/* v86irq‚Ìƒ‹[ƒ‹FƒXƒ^ƒbƒN‚Ì‚Â‚İ•û */
	/* ESP0 = 0xffffffc0 */
	/* 0xffffffb0 : ES, DS, FS, GS */
	/* 0xffffffa0 : CS, EFLAGS, ESP, SS */
	/* 0xffffff90 : ECX, EAX, (ec), EIP */
	/* 0xffffff80 : EBP, ESP, EBX, EDX */
	/* 0xffffff78 : EDI, ESI */

	/* INT(0x03);‚Ì‚ ‚Æ‚ÉIRQ‚Í‹N‚«‚È‚¢‚Æ‰¼’è */
	/* INT13H‚ÌŠ®—¹‚ÌŠÔ‚É‚Ì‚İ‹N‚±‚é */

INT(3);
	PUSH(DS);
	PUSHAD();
	STR(CX);
	if (CX != 0x140)
		INT(0x03);	/* è”²‚« */

	PUSH(SEL_ALL);
	POP(DS);
	LEA(EBX, [EAX + 8]);
	if (AL >= 8)
		EBX += 0x60;
	EBP = 0;
	EDI = (unsigned short) [SS:EBP + 0xffffffac]; // SS
	ESI = (unsigned short) [SS:EBP + 0xffffffa8]; // SP
	EDI *= 16;
	EAX = (unsigned short) [SS:EBP + 0xffffff9c]; // IP
	ECX = [SS:EBP + 0xffffffa0]; // CS
	(short) [DS:ESI - 6] = AX;
	asmout("MOV EAX,[DS:EBX*4]");
	EBX = [SS:EBP + 0xffffffa4]; // EFLAGS
	(short) [DS:ESI - 4] = CX;
	(short) [SS:EBP + 0xffffff9c] /* IP */ = AX;
	(short) [DS:ESI - 2] = BX;
	(unsigned int) EAX >>= 16;
	(short) [SS:EBP + 0xffffffa8] -= 6; // SP
	[SS:EBP + 0xffffffa0] /* CS */ = EAX;

	POPAD();
	POP(DS);
	RETF();
}

#endif

/*
void far int14()
{
	PUSHAD();
	ESI = CODE::"INT 0x0E Page Protect\0";
}
*/

#if (defined(PCAT) & 0)

void far int35()
{
	PUSH(EAX);
	PUSHAD();
	EAX = 3;
	PUSH(CS);
	v86irq();
	POPAD();
	POP(EAX);
	IRETD();
}

void far int36()
{
	PUSH(EAX);
	PUSHAD();
	EAX = 4;
	PUSH(CS);
	v86irq();
	POPAD();
	POP(EAX);
	IRETD();
}

void far int37()
{
	PUSH(EAX);
	PUSHAD();
	EAX = 5;
	PUSH(CS);
	v86irq();
	POPAD();
	POP(EAX);
	IRETD();
}

#if 0
void far int39()
{
	PUSH(EAX);
	PUSHAD();
	EAX = 7;
	PUSH(CS);
	v86irq();
	POPAD();
	POP(EAX);
	IRETD();
}
#endif

void far int40()
{
	PUSH(EAX);
	PUSHAD();
	EAX = 8;
	PUSH(CS);
	v86irq();
	POPAD();
	POP(EAX);
	IRETD();
}

void far int41()
{
	PUSH(EAX);
	PUSHAD();
	EAX = 9;
	PUSH(CS);
	v86irq();
	POPAD();
	POP(EAX);
	IRETD();
}

void far int42()
{
	PUSH(EAX);
	PUSHAD();
	EAX = 10;
	PUSH(CS);
	v86irq();
	POPAD();
	POP(EAX);
	IRETD();
}

void far int43()
{
	PUSH(EAX);
	PUSHAD();
	EAX = 11;
	PUSH(CS);
	v86irq();
	POPAD();
	POP(EAX);
	IRETD();
}

#if 0
void far int44()
{
	PUSH(EAX);
	PUSHAD();
	EAX = 12;
	PUSH(CS);
	v86irq();
	POPAD();
	POP(EAX);
	IRETD();
}
#endif

void far int45()
{
	PUSH(EAX);
	PUSHAD();
	EAX = 13;
	PUSH(CS);
	v86irq();
	POPAD();
	POP(EAX);
	IRETD();
}

void far int46()
{
	PUSH(EAX);
	PUSHAD();
	EAX = 14;
	PUSH(CS);
	v86irq();
	POPAD();
	POP(EAX);
	IRETD();
}

void far int47()
{
	PUSH(EAX);
	PUSHAD();
	EAX = 15;
	PUSH(CS);
	v86irq();
	POPAD();
	POP(EAX);
	IRETD();
}

#endif

void near put_int_status_ec()
// ƒGƒ‰[ƒR[ƒh‚ ‚è(ƒtƒ‰ƒO‚ğ•\¦‚µ‚Ä‚¢‚È‚¢)
{
	PUSH(DS);
	PUSH(GS);
	PUSH(CS);
	POP(GS);
	EAX = 0;
	ECX = 0;
	EDX = 0x000f;
	output_string();

	// 12345678901234567890123456789012345678901
	// CS:EIP = 1234:56789ABC     EC = 12345678
	PUSH(SS);
	PUSH(SS);
	POP(DS);
	POP(GS);
	ESP -= 84;
	EBP = ESP;
	asmout("MOV DWORD PTR SS:[EBP+00],'C'+'S'*100h+':'*10000h+'E'*1000000h");
	asmout("MOV DWORD PTR SS:[EBP+04],'I'+'P'*100h+' '*10000h+'='*1000000h");
	asmout("MOV BYTE PTR SS:[EBP+08],' '");
	EAX = /* (int) */ [SS:EBP + 84 + 8 + 32 + 4 + 4];
	// ESI = EBP + 9;
	LEA(ESI, [EBP + 9]);
	ui16toa();
	asmout("MOV BYTE PTR SS:[EBP+13],':'");
	EAX = /* (int) */ [SS:EBP + 84 + 8 + 32 + 4];
	// ESI = EBP + 14;
	LEA(ESI, [EBP+14]);
	ui32toa();
	asmout("MOV WORD PTR SS:[EBP+22],' '+' '*100h");
	asmout("MOV DWORD PTR SS:[EBP+24],' '+' '*100h+' '*10000h+'E'*1000000h");
	asmout("MOV DWORD PTR SS:[EBP+28],'C'+' '*100h+'='*10000h+' '*1000000h");
	EAX = /* (int) */ [SS:EBP + 84 + 8 + 32];
	// ESI = EBP + 32;
	LEA(ESI,[EBP+32]);
	ui32toa();
	asmout("MOV BYTE PTR SS:[EBP+40],0");
	// CS:EIP, EC‚ğ•\¦‚µ‚½‚ ‚Æ‚Éput_int_status2‚Ö
}

void put_int_status2()
{
	unsigned int tapiwork_sel  == 13 * 8;

//	EBP = ESP;
	ESI = EBP;
	EAX = 0;
	ECX = 16;
	EDX = 0x000f;
	output_string();

	asmout("MOV DWORD PTR SS:[EBP+00],'E'+'A'*100h+'X'*10000h+' '*1000000h");
	asmout("MOV DWORD PTR SS:[EBP+04],'='+' '*100h+'0'*10000h+'1'*1000000h");
//	asmout("MOV DWORD PTR SS:[EBP+08],'2'+'3'*100h+'4'*10000h+'5'*1000000h");
	asmout("MOV DWORD PTR SS:[EBP+12],'6'+'7'*100h+' '*10000h+' '*1000000h");
	asmout("MOV DWORD PTR SS:[EBP+16],' '+' '*100h+' '*10000h+'E'*1000000h");
	asmout("MOV DWORD PTR SS:[EBP+20],'C'+'X'*100h+' '*10000h+'='*1000000h");
	asmout("MOV DWORD PTR SS:[EBP+24],' '+'0'*100h+'1'*10000h+'2'*1000000h");
//	asmout("MOV DWORD PTR SS:[EBP+28],'3'+'4'*100h+'5'*10000h+'6'*1000000h");
	asmout("MOV DWORD PTR SS:[EBP+32],'7'+' '*100h+' '*10000h+' '*1000000h");
	asmout("MOV DWORD PTR SS:[EBP+36],' '+' '*100h+'E'*10000h+'D'*1000000h");
	asmout("MOV DWORD PTR SS:[EBP+40],'X'+' '*100h+'='*10000h+' '*1000000h");
//	asmout("MOV DWORD PTR SS:[EBP+44],'0'+'1'*100h+'2'*10000h+'3'*1000000h");
//	asmout("MOV DWORD PTR SS:[EBP+48],'4'+'5'*100h+'6'*10000h+'7'*1000000h");
	asmout("MOV DWORD PTR SS:[EBP+52],' '+' '*100h+' '*10000h+' '*1000000h");
	asmout("MOV DWORD PTR SS:[EBP+56],' '+'E'*100h+'B'*10000h+'X'*1000000h");
	asmout("MOV DWORD PTR SS:[EBP+60],' '+'='*100h+' '*10000h+'0'*1000000h");
//	asmout("MOV DWORD PTR SS:[EBP+64],'1'+'2'*100h+'3'*10000h+'4'*1000000h");
	asmout("MOV DWORD PTR SS:[EBP+68],'5'+'6'*100h+'7'*10000h+000*1000000h");
	EAX = /* (int) */ [SS:EBP + 84 + 8 + 28];
	// ESI = EBP +  6;
	asmout("LEA ESI,[EBP+6]");
	ui32toa();
	EAX = /* (int) */ [SS:EBP + 84 + 8 + 24];
	// ESI = EBP + 25;
	asmout("LEA ESI,[EBP+25]");
	ui32toa();
	EAX = /* (int) */ [SS:EBP + 84 + 8 + 20];
	// ESI = EBP + 44;
	asmout("LEA ESI,[EBP+44]");
	ui32toa();
	EAX = /* (int) */ [SS:EBP + 84 + 8 + 16];
	// ESI = EBP + 63;
	asmout("LEA ESI,[EBP+63]");
	ui32toa();
	ESI = EBP;
	EAX = 0;
	ECX = 16 * 2;
	EDX = 0x000f;
	output_string();

	asmout("MOV DWORD PTR SS:[EBP+00],'E'+'S'*100h+'P'*10000h+' '*1000000h");
//	asmout("MOV DWORD PTR SS:[EBP+04],'='+' '*100h+'0'*10000h+'1'*1000000h");
//	asmout("MOV DWORD PTR SS:[EBP+08],'2'+'3'*100h+'4'*10000h+'5'*1000000h");
//	asmout("MOV DWORD PTR SS:[EBP+12],'6'+'7'*100h+' '*10000h+' '*1000000h");
//	asmout("MOV DWORD PTR SS:[EBP+16],' '+' '*100h+' '*10000h+'E'*1000000h");
	asmout("MOV DWORD PTR SS:[EBP+20],'B'+'P'*100h+' '*10000h+'='*1000000h");
//	asmout("MOV DWORD PTR SS:[EBP+24],' '+'0'*100h+'1'*10000h+'2'*1000000h");
//	asmout("MOV DWORD PTR SS:[EBP+28],'3'+'4'*100h+'5'*10000h+'6'*1000000h");
//	asmout("MOV DWORD PTR SS:[EBP+32],'7'+' '*100h+' '*10000h+' '*1000000h");
	asmout("MOV DWORD PTR SS:[EBP+36],' '+' '*100h+'E'*10000h+'S'*1000000h");
	asmout("MOV DWORD PTR SS:[EBP+40],'I'+' '*100h+'='*10000h+' '*1000000h");
//	asmout("MOV DWORD PTR SS:[EBP+44],'0'+'1'*100h+'2'*10000h+'3'*1000000h");
//	asmout("MOV DWORD PTR SS:[EBP+48],'4'+'5'*100h+'6'*10000h+'7'*1000000h");
//	asmout("MOV DWORD PTR SS:[EBP+52],' '+' '*100h+' '*10000h+' '*1000000h");
	asmout("MOV DWORD PTR SS:[EBP+56],' '+'E'*100h+'D'*10000h+'I'*1000000h");
//	asmout("MOV DWORD PTR SS:[EBP+60],' '+'='*100h+' '*10000h+'0'*1000000h");
//	asmout("MOV DWORD PTR SS:[EBP+64],'1'+'2'*100h+'3'*10000h+'4'*1000000h");
//	asmout("MOV DWORD PTR SS:[EBP+68],'5'+'6'*100h+'7'*10000h+000*1000000h");
	// EAX = EBP + 84 + 8 + 32 + 16;
	asmout("LEA EAX,[EBP+84+8+32+16]");
	// ESI = EBP +  6;
	asmout("LEA ESI,[EBP+6]");
	ui32toa();
	EAX = /* (int) */ [SS:EBP + 84 + 8 +  8];
	// ESI = EBP + 25;
	asmout("LEA ESI,[EBP+25]");
	ui32toa();
	EAX = /* (int) */ [SS:EBP + 84 + 8 +  4];
	// ESI = EBP + 44;
	asmout("LEA ESI,[EBP+44]");
	ui32toa();
	EAX = /* (int) */ [SS:EBP + 84 + 8 +  0];
	// ESI = EBP + 63;
	asmout("LEA ESI,[EBP+63]");
	ui32toa();
	ESI = EBP;
	EAX = 0;
	ECX = 16 * 3;
	EDX = 0x000f;
	output_string();

	asmout("MOV DWORD PTR SS:[EBP+00],'t'+'s'*100h+'s'*10000h+' '*1000000h");
//	asmout("MOV DWORD PTR SS:[EBP+04],'='+' '*100h+'0'*10000h+'1'*1000000h");
//	asmout("MOV DWORD PTR SS:[EBP+08],'2'+'3'*100h+'4'*10000h+'5'*1000000h");
//	asmout("MOV DWORD PTR SS:[EBP+12],'6'+'7'*100h+' '*10000h+' '*1000000h");
	asmout("MOV DWORD PTR SS:[EBP+16],' '+' '*100h+' '*10000h+'T'*1000000h");
	asmout("MOV DWORD PTR SS:[EBP+20],'R'+' '*100h+' '*10000h+'='*1000000h");
//	asmout("MOV DWORD PTR SS:[EBP+24],' '+'0'*100h+'1'*10000h+'2'*1000000h");
//	asmout("MOV DWORD PTR SS:[EBP+28],'3'+'4'*100h+'5'*10000h+'6'*1000000h");
//	asmout("MOV DWORD PTR SS:[EBP+32],'7'+' '*100h+' '*10000h+' '*1000000h");
	asmout("MOV DWORD PTR SS:[EBP+36],' '+' '*100h+'E'*10000h+'S'*1000000h");
	asmout("MOV DWORD PTR SS:[EBP+40],'I'+' '*100h+'='*10000h+' '*1000000h");
//	asmout("MOV DWORD PTR SS:[EBP+44],'0'+'1'*100h+'2'*10000h+'3'*1000000h");
//	asmout("MOV DWORD PTR SS:[EBP+48],'4'+'5'*100h+'6'*10000h+'7'*1000000h");
//	asmout("MOV DWORD PTR SS:[EBP+52],' '+' '*100h+' '*10000h+' '*1000000h");
	asmout("MOV DWORD PTR SS:[EBP+56],' '+'E'*100h+'D'*10000h+'I'*1000000h");
//	asmout("MOV DWORD PTR SS:[EBP+60],' '+'='*100h+' '*10000h+'0'*1000000h");
//	asmout("MOV DWORD PTR SS:[EBP+64],'1'+'2'*100h+'3'*10000h+'4'*1000000h");
//	asmout("MOV DWORD PTR SS:[EBP+68],'5'+'6'*100h+'7'*10000h+000*1000000h");
	#if 1
		PUSH(DS);
		EAX = SEL_TAPIWORK;
		DS = AX;
		EAX = (int) [DS:0x000c];
		POP(DS);
	#endif
	// ESI = EBP +  6;
	asmout("LEA ESI,[EBP+6]");
	ui32toa();
	EAX = 0;
	STR(AX);
	// ESI = EBP + 25;
	asmout("LEA ESI,[EBP+25]");
	ui32toa();
	(char) [SS:EBP + 33] = 0;

//	EAX = /* (int) */ [SS:ESP + 84 + 8 +  4];
//	// ESI = ESP + 44;
//	asmout("LEA ESI,[ESP+44]");
//	ui32toa();
//	EAX = /* (int) */ [SS:ESP + 84 + 8 +  0];
//	// ESI = ESP + 63;
//	asmout("LEA ESI,[ESP+63]");
//	ui32toa();
	ESI = EBP;
	EAX = 0;
	ECX = 16 * 4;
	EDX = 0x000f;
	output_string();

	#if (!defined(NOHLT))
		for (;;)
			HLT(); // ‚à‚µƒ}ƒ‹ƒ`ƒ^ƒXƒN‚É‘Î‰‚µ‚½‚çA‚±‚ê‚Í‚â‚ß‚ÄAŠY“–ƒ^ƒXƒN‚ğƒXƒŠ[ƒv‚É‚·‚é‚¾‚¯‚É‚·‚é
	#else
		for (;;)
			NOP();
	#endif
}

void far int01()
{
	unsigned int tapiwork_sel  == 13 * 8;

	PUSH(EAX); // ƒ_ƒ~[‚ÌƒGƒ‰[ƒR[ƒh
	PUSHAD();
/*	PUSH(DS);
	EAX = 0x0058;
	DS = AX;
	EAX = [DS:4];
	POP(DS);
	if (EAX != 0)
		goto no_trap;
*/	CX = [SS:ESP + 32 + 4 + 4]; // CS
	EAX = [SS:ESP + 32 + 4]; // EIP
	#if (defined(CHECK_TSKPTR))
		PUSH(DS);
		PUSH(EAX);
		EAX = tapiwork_sel;
		DS = AX;
		EAX = [DS:0x000c];
		TEST(EAX, 0xfff);
		POP(EAX);
		POP(DS);
		if (!= 0)
			goto trap;
		goto no_trap;
	#endif
	#if 0
		PUSH(DS);
		PUSH(EAX);
		EAX = tapiwork_sel;
		DS = AX;
		EAX = [DS:28];
		TEST(EAX, 0xfffff03f);
		POP(EAX);
		POP(DS);
		if (!= 0)
			goto trap;
		goto no_trap;
	#endif
	#if 0
		PUSH(DS);
		PUSH(ECX);
		PUSH(EAX);
		SLDT(CX);
		EAX = 0x118;
		LLDT(AX);
		EAX = 0x001c;
		DS = AX;
		EAX = [DS:0xfffffffc];
		LLDT(CX);
		CMP(EAX, 0x0060);
		POP(EAX);
		POP(ECX);
		POP(DS);
		if (!=)
			goto trap;
		goto no_trap;
	#endif

	#if 0
	if (CX == 0x0010) {
		if (EAX == 0x11a7)
			goto no_trap;
	//	if (EAX == 0x0404)
	//		goto no_trap;
	} else if (CX == 0x0060) {
		if (EAX == 0x08b2)
			goto no_trap;
		if (EAX == 0x09f0) {
			if ((unsigned) ESI < 512)
				goto no_trap;
		}
	}
	#endif
	#if 0
		if (CX == 0x00c7) {
			if (EAX == 0x026e)
				goto no_trap;
			if (EAX == 0x1335) {
				if (ESI <= 0x002c)
					goto no_trap;
			}
		}
	#endif
trap:
	ESI = CODE::"INT 0x01 Debug Fault\0";
	asmout("JMP put_int_status");
no_trap:
	POPAD();
	POP(EAX);
	IRETD();
}


void far int03()
{
	unsigned int syswork_sel  ==  3 * 8;
	unsigned int stack_sel    ==  6 * 8;
	unsigned int tapi_sel     == 12 * 8, tapiwork_sel  == 13 * 8;

	PUSH(EAX); // ƒ_ƒ~[‚ÌƒGƒ‰[ƒR[ƒh
	PUSHAD();
	EAX = [SS:ESP + 32 + 4 + 8] /* EFLAGS */;
	TEST(EAX, 0x00020000);
	if (== 0) {
	//	PUSH(FS);
	//	EAX = syswork_sel; FS = AX;
	//	// 640x480x4bit ƒ‚[ƒh‚É‚·‚é
	//	asmout("MOV EBX, offset mode0x12_800"); // ASKA‚ÍƒAƒZƒ“ƒuƒ‰ƒ‰ƒxƒ‹‚Æ‚Ì˜AŒg‚ª‚Æ‚ê‚È‚¢‚Ì‚Åasmout‚É‚µ‚Ä‚¢‚éB
	//	asmout("fcall 4*8, 0");
	//	asmout("MOV EBX, offset mode0x12_800"); // ASKA‚ÍƒAƒZƒ“ƒuƒ‰ƒ‰ƒxƒ‹‚Æ‚Ì˜AŒg‚ª‚Æ‚ê‚È‚¢‚Ì‚Åasmout‚É‚µ‚Ä‚¢‚éB
	//	(char) [FS:EBX] = 0xff;
	//	asmout("fcall 4*8, 0");
	//	POP(FS);
#if 0
PUSH(DS);
EAX = 14 * 8;
DS = AX;
asmout("MOV EAX,DR0");
EAX >>= 20;
EAX &= 0xffc;
EBX = [DS:EAX];
asmout("MOV EAX,DR0");
EAX >>= 10;
EAX &= 0xffc;
EBX += EAX; /* ‚±‚ê‚Í³‚µ‚¢ƒAƒhƒŒƒX */
EDX = [DS:EBX];
ESI = 0x2000;
EDX &= 0xfffff001;
ECX = 16 * 1024;
do {
	EAX = [DS:ESI];
	EAX &= 0xfffff001;
	if (EAX == EDX) {
		if (ESI != EBX)
			break;
	}
	ESI += 4;
	ECX--;
} while (!= 0);
POP(DS);
asmout("MOV EDX,DR0");
[SS:ESP + 28] = ESI;
[SS:ESP + 24] = EDX;
#endif
		ESI = CODE::"INT 0x03 Break Point\0";
		goto put_int_status;
	}

	#if (defined(PCAT))
		// from V86ƒ‚[ƒh
		PUSH(FS);
		PUSH(SEL_ALL);
		POP(FS);
		ECX = [FS:0x9f800];
		if (ECX == 0x00cc10cd) {
			/* VESAŒÄ‚Ño‚µŒã‚ÌƒVƒOƒiƒ‹ */
			GUIGUI_work *work == FS:0xffffd000;
			PUSH(SEL_STACK);
			POP(FS);
			EAX = 0;
			EBX = [SS:ESP + 4 + 28 /* EAX */];
			PUSH(EAX /* eoc */);
			PUSH(EAX /* Llv(0) */);
			PUSH((int) TSS_V86 /* work->tasklist[128].tskptr */);
			PUSH((int) 0x0100 /* TAPI_ChangeLlv */); // ©g‚ÌƒXƒŠ[ƒv
			if ((unsigned) work->setvideomode_mode > 0xff) {
				if (BX != 0x004f)
					EAX++;
			}
			PUSH(EAX /* error-code */);
			PUSH(work->setvideomode_sig[8]);
			PUSH(work->setvideomode_sig[4]);
			PUSH(work->setvideomode_sig[0]);
			PUSH((int) 0x0128 /* ƒRƒ}ƒ“ƒhƒVƒOƒiƒ‹’¼Ú(with wait) */); // ƒVƒOƒiƒ‹”­¶
			EBX = ESP;
			PUSH(SS);
			POP(FS);
			CALLFAR0(SEL_TAPI);
			INT(0x03); /* ‚±‚±‚É‚Í—ˆ‚È‚¢ */
		}
		if (ECX == 0x00cc13cd) {
			/* ƒfƒBƒXƒNBIOS */
			TAPI_TSS *v86tss == FS:EDI;
			PUSH(SEL_TAPIWORK);
			POP(FS);
			(offset) v86tss = TSS_V86;
			ECX = [SS:ESP + 4 + 32 + 4 + 0];
			v86tss->tss386.EFLAGS = EAX;
			v86tss->tss386.EIP = ECX;
			EAX = [SS:ESP + 4 + 28];
			ECX = [SS:ESP + 4 + 24];
			EDX = [SS:ESP + 4 + 20];
			EBX = [SS:ESP + 4 + 16];
			v86tss->tss386.EAX = EAX;
			v86tss->tss386.ECX = ECX;
			v86tss->tss386.EDX = EDX;
			v86tss->tss386.EBX = EBX;
		//	EAX = [SS:ESP + 4 + 12];
			ECX = [SS:ESP + 4 +  8];
			EDX = [SS:ESP + 4 +  4];
			EBX = [SS:ESP + 4 +  0];
		//	v86tss->tss386.ESP = EAX;
			v86tss->tss386.EBP = ECX;
			v86tss->tss386.ESI = EDX;
			v86tss->tss386.EDI = EBX;

			PUSH(SS);
			POP(FS);
			PUSH(0 /* eoc */);
			PUSH((int) 0x019c /* INT13Hƒnƒ“ƒhƒ‰ŒÄ‚Ño‚µ */);
			EBX = ESP;
			CALLFAR0(SEL_FDCDRIVE);

			PUSH(SEL_TAPIWORK);
			POP(FS);
			(offset) v86tss = TSS_V86;
			EAX = v86tss->tss386.EIP;
			if (AL == 0) {
				/* Ä“Ë“üŒˆ’è */
				ESP += 12;
				ECX = v86tss->tss386.CS;
				EDX = v86tss->tss386.EFLAGS;
				EBX = v86tss->tss386.ESP;
				EBP = v86tss->tss386.SS;
				[SS:ESP + 32 + 4 +  0] = EAX;
				[SS:ESP + 32 + 4 +  4] = ECX;
				[SS:ESP + 32 + 4 +  8] = EDX;
				[SS:ESP + 32 + 4 + 12] = EBX;
				[SS:ESP + 32 + 4 + 16] = EBP;
				EAX = v86tss->tss386.ES;
				ECX = v86tss->tss386.DS;
				EDX = v86tss->tss386.FS;
				EBX = v86tss->tss386.GS;
				[SS:ESP + 32 + 4 + 20] = EAX;
				[SS:ESP + 32 + 4 + 24] = ECX;
				[SS:ESP + 32 + 4 + 28] = EDX;
				[SS:ESP + 32 + 4 + 32] = EBX;
				EAX = v86tss->tss386.EAX;
				ECX = v86tss->tss386.ECX;
				EDX = v86tss->tss386.EDX;
				EBX = v86tss->tss386.EBX;
				[SS:ESP + 28] = EAX;
				[SS:ESP + 24] = ECX;
				[SS:ESP + 20] = EDX;
				[SS:ESP + 16] = EBX;
			//	EAX = v86tss->tss386.ESP;
				ECX = v86tss->tss386.EBP;
				EDX = v86tss->tss386.ESI;
				EBX = v86tss->tss386.EDI;
			//	[SS:ESP + 12] = EAX;
				[SS:ESP +  8] = ECX;
				[SS:ESP +  4] = EDX;
				[SS:ESP +  0] = EBX;
				POPAD();
				ESP += 4;
				IRETD();
			}
			PUSH(SS);
			POP(FS);
			POP(EAX);
			PUSH(0 /* Llv(0) */);
			PUSH((int) TSS_V86 /* work->tasklist[128].tskptr */);
			PUSH((int) 0x0100 /* TAPI_ChangeLlv */); // ©g‚ÌƒXƒŠ[ƒv
			EBX = ESP;
			CALLFAR0(SEL_TAPI);
			INT(0x03); /* ‚±‚±‚É‚Í—ˆ‚È‚¢ */
		}
	#endif
	INT(0x03);
}

void far int06()
{
	PUSH(EAX); // ƒ_ƒ~[‚ÌƒGƒ‰[ƒR[ƒh
	PUSHAD();
	ESI = CODE::"INT 0x06 Invalid Opecode\0";
}

void near put_int_status()
// ƒGƒ‰[ƒR[ƒh‚È‚µ(ƒtƒ‰ƒO‚ğ•\¦‚µ‚Ä‚¢‚È‚¢)
{
	PUSH(DS);
	PUSH(GS);
	PUSH(CS);
	POP(GS);
	EAX = 0;
	ECX = 0;
	EDX = 0x000f;
	output_string();

	// 12345678901234567890123
	// CS:EIP = 1234:56789ABC
	ESP -= 84;
	MOV(EAX, SS);
	EBP = ESP;
	DS = AX;
	GS = AX;
	asmout("MOV DWORD PTR SS:[EBP+00],'CS:E'");
	asmout("MOV DWORD PTR SS:[EBP+04],'IP ='");
	asmout("MOV BYTE PTR SS:[EBP+08],' '");
	EAX = /* (int) */ [SS:EBP + 84 + 8 + 32 + 4 + 4];
	// ESI = EBP + 9;
	asmout("LEA ESI,[EBP+9]");
	ui16toa();
	asmout("MOV BYTE PTR SS:[EBP+13],':'");
	EAX = /* (int) */ [SS:EBP + 84 + 8 + 32 + 4];
	// ESI = EBP + 14;
	asmout("LEA ESI,[EBP+14]");
	ui32toa();
	asmout("MOV BYTE PTR SS:[EBP+22],0");
//	ESI = EBP;
//	EAX = 0;
//	ECX = 16;
//	EDX = 0x000f;
//	output_string();
	// CS:EIP, EC‚ğ•\¦‚µ‚½‚ ‚Æ‚Éput_int_status2‚Ö
	// goto put_int_status2;
	asmout("JMP put_int_status2");
}

#if (defined(PCAT))

void far int39()
{
	/* ƒmƒCƒY‚É‚æ‚è•sŠ®‘SŠ„‚è‚İ‚ª”­¶‚µ‚½‚Æ”»’f */
	/* IRR‚ğƒNƒŠƒA‚·‚é‚½‚ß‚ÉAPIC‚ğÄ‰Šú‰» */
	PUSH(EAX);
	IN(AL, 0x21); /* master IMR */
	PUSH(EAX);
	AL = 0x11; /* ICW1 (edge trigger) */
	OUT(0x20, AL); /* master */
	AL = 0x20; /* ICW2(int-no.) */
	OUT(0x21, AL); /* master */
	AL = 0x04; /* ICW3 slave‚ª‚Â‚È‚ª‚Á‚Ä‚¢‚éIRQ‚Ìbit‚ğ1‚É‚·‚é(bit2 = 1) */
	OUT(0x21, AL); /* master */
	AL = 0x01; /* ICW4(non-buf. mode) */
	OUT(0x21, AL); /* master */
	POP(EAX);
	OUT(0x21, AL); /* OCW1 (IMR•œ‹A) */
	AL = 0x4a; /* OCW3 IRR“Ç‚İ‚İ “Áêƒ}ƒXƒNƒ‚[ƒhƒŠƒZƒbƒg 01001010 */
	OUT(0x20, AL); /* master */
	POP(EAX);
	IRETD();

#if 0
	PUSH(EAX); /* ƒ_ƒ~[‚ÌƒGƒ‰[ƒR[ƒh */
	PUSHAD();
	EAX = 0;
	ESI = CODE::"INT 0x27 IRQ7\0";
	IN(AL, 0x0020);
	(int) [SS:ESP + 32] = EAX;
	asmout("JMP put_int_status_ec");
#endif
}

#elif (defined(NEC98))

void far int39()
{
	/* ƒmƒCƒY‚É‚æ‚è•sŠ®‘SŠ„‚è‚İ‚ª”­¶‚µ‚½‚Æ”»’f */
	/* ‚¢‚â‘½•ªGAPI‚ÌCLIŠúŠÔ‚ª’·‚·‚¬‚½ */
	/* IRR‚ğƒNƒŠƒA‚·‚é‚½‚ß‚ÉAPIC‚ğÄ‰Šú‰» */
	PUSH(EAX);
	IN(AL, 0x02); /* master IMR */
	PUSH(EAX);
	AL = 0x11; /* ICW1 (edge trigger) */
	OUT(0x00, AL); /* master */
	AL = 0x20; /* ICW2(int-no.) */
	OUT(0x02, AL); /* master */
	AL = 0x04; /* ICW3 slave‚ª‚Â‚È‚ª‚Á‚Ä‚¢‚éIRQ‚Ìbit‚ğ1‚É‚·‚é(bit2 = 1) */
	OUT(0x02, AL); /* master */
	AL = 0x01; /* ICW4(non-buf. mode) */
	OUT(0x02, AL); /* master */
	POP(EAX);
	OUT(0x02, AL); /* OCW1 (IMR•œ‹A) */
	AL = 0x4a; /* OCW3 IRR“Ç‚İ‚İ “Áêƒ}ƒXƒNƒ‚[ƒhƒŠƒZƒbƒg 01001010 */
	OUT(0x00, AL); /* master */
	POP(EAX);
	IRETD();

#if 0
	PUSH(EAX); /* ƒ_ƒ~[‚ÌƒGƒ‰[ƒR[ƒh */
	PUSHAD();
	EAX = 0;
	ESI = CODE::"INT 0x27 IRQ7\0";
	IN(AL, 0x0020);
	(int) [SS:ESP + 32] = EAX;
	asmout("JMP put_int_status_ec");
#endif
}

#endif

void far int_other()
{
	PUSH(EAX); /* ƒ_ƒ~[‚ÌƒGƒ‰[ƒR[ƒh */

	PUSHAD();
	ESI = CODE::"INT 0x?? Other Exception\0";
	goto put_int_status;
}

void far int_other_ec()
{
	PUSHAD();
	ESI = CODE::"INT 0x?? Other Exception (EC)\0";
	goto put_int_status_ec;
}




#if (defined(NEC98) && 0)

void far int39()
{
#if 0
	/* ƒmƒCƒY‚É‚æ‚è•sŠ®‘SŠ„‚è‚İ‚ª”­¶‚µ‚½‚Æ”»’f */
	/* IRR‚ğƒNƒŠƒA‚·‚é‚½‚ß‚ÉAPIC‚ğÄ‰Šú‰» */
	PUSH(EAX);
	IN(AL, 0x21); /* master IMR */
	PUSH(EAX);
	AL = 0x11; /* ICW1 (edge trigger) */
	OUT(0x20, AL); /* master */
	AL = 0x20; /* ICW2(int-no.) */
	OUT(0x21, AL); /* master */
	AL = 0x04; /* ICW3 slave‚ª‚Â‚È‚ª‚Á‚Ä‚¢‚éIRQ‚Ìbit‚ğ1‚É‚·‚é(bit2 = 1) */
	OUT(0x21, AL); /* master */
	AL = 0x01; /* ICW4(non-buf. mode) */
	OUT(0x21, AL); /* master */
	POP(EAX);
	OUT(0x21, AL); /* OCW1 (IMR•œ‹A) */
	AL = 0x4a; /* OCW3 IRR“Ç‚İ‚İ “Áêƒ}ƒXƒNƒ‚[ƒhƒŠƒZƒbƒg 01001010 */
	OUT(0x20, AL); /* master */
	POP(EAX);
	IRETD();
#endif
#if 1
	PUSH(EAX); /* ƒ_ƒ~[‚ÌƒGƒ‰[ƒR[ƒh */
	PUSHAD();
	EAX = 0;
	ESI = CODE::"INT 0x27 IRQ7\0";
	IN(AL, 0x0020);
	(int) [SS:ESP + 32] = EAX;
	asmout("JMP put_int_status_ec");
#endif
}

#endif

#if 0
void near initmalloc()
// DS == SysWork_sel, ECX‚ÉƒoƒCƒg” ¨ EAX‚É•¨—ƒAƒhƒŒƒX
{
	// unsigned int addr0 == [DS:0x04], free0 == [DS:0x08];
	// unsigned int addr1 == [DS:0x0c], free1 == [DS:0x10];

	// free1 -= ECX;
	asmout("SUB DWORD PTR DS:[bootmalloc_fre1],ECX");
	if ((unsigned) >= 0) {
		// EAX = addr1;
		// EAX += free1;
		asmout("MOV EAX,DWORD PTR DS:[bootmalloc_adr1]");
		asmout("ADD EAX,DWORD PTR DS:[bootmalloc_fre1]");
		return;
	}
	// free1 += ECX; // Œ³‚É–ß‚·
//	// free0 -= ECX;
//	asmout("ADD DWORD PTR DS:[010h],ECX");
//	asmout("SUB DWORD PTR DS:[008h],ECX");
//	if ((unsigned) >= 0) {
//	//	EAX = addr0;
//	//	EAX += free0;
//		asmout("MOV EAX,DWORD PTR DS:[004h]");
//		asmout("ADD EAX,DWORD PTR DS:[008h]");
//		return;
//	}
	INT(0x03);
}
#endif


#if 1
void set_modulesegment()
/* AL, AH = access_right
   ECX = size, EDX = base
   GS:EBX = DT-entry */
/* size‚Í0xfffff000ˆÈ‰º‚Å‚ ‚é */
{
	struct DescriptTbl {
		unsigned short limit1;
		unsigned short base1;
		unsigned char base2;
		unsigned char access_right1;
		unsigned char limit2_access_right2;
		unsigned char base3;
	};

	DescriptTbl *DT == GS:EBX;
	unsigned int size == ECX, base == EDX;

	size--;
	DT->access_right1 = AL;
	TEST(AL, 0x10);
	if (!= 0) { /* S = 1 */
		if (size > 0xfffff) {
			AH |= 0x80; /* page’PˆÊ‚É•â³ */
		//	size &= 0xfffff000;
		}
		AL &= 0x1e;
		TEST(AH, 0x80);
		if (!= 0) {
			size /= 4096; /* ƒy[ƒW’PˆÊ‚É•â³(0`0xffffe) */
			if (AL == 0x16) {
				size ^= 0x000fffff; /* 0¨0xfffff, 1¨0xffffe */
				size--; /* 0¨0xffffe, 1¨0xffffd */
			}
		}
	}

	DT->base1 = DX /* base */;
	base >>= 16;
	DT->limit1 = CX /* size */;
	size >>= 16;
	DT->base2 = DL /* base */;
	CL |= AH;
	DT->limit2_access_right2 = CL /* size */;
	DT->base3 = DH /* base */;
//	ESP -= 8;
//	asmout("SGDT SS:[ESP]");
//	asmout("LGDT SS:[ESP]");
//	ESP += 8;
	return;
}
#endif

#if 0
void near set_modulesegment()
/* AL, AH = access_right
   ECX = size, EDX = base
   GS:EBX = DT-entry */
{
	struct DescriptTbl {
		unsigned short limit1;
		unsigned short base1;
		unsigned char base2;
		unsigned char access_right1;
		unsigned char limit2_access_right2;
		unsigned char base3;
	};

	DescriptTbl *DT == GS:EBX;
	unsigned int size == ECX, base == EDX;

	size--;
	DT->access_right1 = AL;
	TEST(AH, 0x80);
	if (!= 0) {
		AL &= 0x1e;
		size /= 4096; // ƒy[ƒW’PˆÊ‚É•â³
		if (AL == 0x16) {
			size =~ size; /* 0¨0xfffff, 1¨0xfffffe */
			size--;
			size &= 0x000fffff;
		}
	}
	DT->base1 = DX /* base */;
	base >>= 16;
	DT->limit1 = CX /* size */;
	size >>= 16;
	DT->base2 = DL /* base */;
	CL |= AH;
	DT->limit2_access_right2 = CL /* size */;
	DT->base3 = DH /* base */;
//	ESP -= 8;
//	asmout("SGDT SS:[ESP]");
//	asmout("LGDT SS:[ESP]");
//	ESP += 8;
	return;
}
#endif

// •¨—ƒƒ‚ƒŠ‚ğ—v‹
// ƒŠƒjƒAƒAƒhƒŒƒX‹óŠÔ‚ğ—v‹
// GDT‚Éƒ}ƒbƒsƒ“ƒO‚ğ—v‹
// LDT‚Éƒ}ƒbƒsƒ“ƒO‚ğ—v‹
// IDT‚ÍCPUx32,I/Ox16=48ƒGƒ“ƒgƒŠ[‚µ‚©g‚í‚È‚¢B384BytesB
// GDT‚ÆIDT‚Í“‡B
// IDT‚ª‚È‚¢‚ÆŠ„‚İ§Œä‚ª‚Å‚«‚È‚¢B
// Š„‚İ§Œä‚ª‚Å‚«‚È‚¢‚ÆAƒ}ƒEƒX‚Ì“®‚«‚ğæ“¾‚Å‚«‚È‚¢B
// PIC‚ğ§ŒäBƒL[ƒ{[ƒh‚Æƒ}ƒEƒX‚Ì§ŒäB
// ‚Ü‚¸Aˆê”ÊŠ„‚è‚İƒ‹[ƒ`ƒ“‹K’è‚ª•K—vB


#if 0

/* TOWNS—pƒfƒoƒbƒOƒ‹[ƒ`ƒ“ */

void putstr()
/* ES:EDI‚Öo—Í, SS:EBX‚É•¶š—ñ, ECX‚ª•¶š’·, ES:ESI‚ÉƒtƒHƒ“ƒg */
{
	PUSH(EDI);
	PUSH(EBX);
	PUSH(ECX);
	PUSH(EAX);
	AL = 0x0f;
	[ES:0xcff83] = AL; /* all plain write */
	do {
	//	EAX = (unsigned char) [FS:EBX];
		EAX = (unsigned char) [SS:EBX];
		PUSH(ESI);
		EAX *= 16;
		EBX++;
		ESI += EAX;
		EAX = [ES:ESI +  0];
		[ES:EDI + 80 *  0] = AL;
		[ES:EDI + 80 *  1] = AH;
		(unsigned int) EAX >>= 16;
		[ES:EDI + 80 *  2] = AL;
		[ES:EDI + 80 *  3] = AH;
		EAX = [ES:ESI +  4];
		[ES:EDI + 80 *  4] = AL;
		[ES:EDI + 80 *  5] = AH;
		(unsigned int) EAX >>= 16;
		[ES:EDI + 80 *  6] = AL;
		[ES:EDI + 80 *  7] = AH;
		EAX = [ES:ESI +  8];
		[ES:EDI + 80 *  8] = AL;
		[ES:EDI + 80 *  9] = AH;
		(unsigned int) EAX >>= 16;
		[ES:EDI + 80 * 10] = AL;
		[ES:EDI + 80 * 11] = AH;
		EAX = [ES:ESI + 12];
		POP(ESI);
		[ES:EDI + 80 * 12] = AL;
		[ES:EDI + 80 * 13] = AH;
		(unsigned int) EAX >>= 16;
		[ES:EDI + 80 * 14] = AL;
		[ES:EDI + 80 * 15] = AH;
		EDI++;
		ECX--;
	} while (!= 0);
	POP(EAX);
	POP(ECX);
	POP(EBX);
	POP(EDI);
	return;
}

void itoa1()
/* AL -> CL */
{
	CL = AL;
	CL &= 0x0f;
	CL += 0x30; /* '0' */
	if (CL > 0x39)
		CL += 0x41 - 10 - 0x30;
	return;
}

void itoa2()
/* AL -> CX */
{
	itoa1();
	CH = CL;
	ROL(AL, 4);
	itoa1();
	ROL(AL, 4);
	return;
}

void itoa4()
/* AX -> ECX */
{
	itoa2();
	ECX <<= 16;
	XCHG(AL, AH);
	itoa2();
	XCHG(AL, AH);
	return;
}

void itoa8()
/* EAX -> EDX:ECX */
{
	itoa4();
	EDX = ECX;
	ROL(EAX, 16);
	itoa4();
	ROL(EAX, 16);
	return;
}

void dumpreg()
{
	PUSH(8); /* all_sel */
	POP(ES);
	PUSH(24); /* syswork_sel */	
	POP(DS);

	PUSHAD();
	EBP = ESP;
//	PUSH(SS);
	ESI = [DS:0x0e0 + 12];
	EDI = 0xc0000 + 80 * 16 * 10;
	ESI -= 16 * 32;
//	POP(FS);

	EAX = EBX;
	itoa8();
	PUSH(EDX);
	PUSH(ECX);
	asmout("PUSH 'EBX:'");

	PUSH(0x20202020);
	EAX = [SS:EBP + 20];
	itoa8();
	PUSH(EDX);
	PUSH(ECX);
	asmout("PUSH 'EDX:'");

	PUSH(0x20202020);
	EAX = [SS:EBP + 24];
	itoa8();
	PUSH(EDX);
	PUSH(ECX);
	asmout("PUSH 'ECX:'");

	PUSH(0x20202020);
	EAX = [SS:EBP + 28];
	itoa8();
	PUSH(EDX);
	PUSH(ECX);
	asmout("PUSH 'EAX:'");

	EBX = ESP;
	ECX = 60;
	putstr();
	ESP = EBP;
	EDI += 80 * 16;

	EAX = [SS:EBP +  0];
	itoa8();
	PUSH(EDX);
	PUSH(ECX);
	asmout("PUSH 'EDI:'");

	PUSH(0x20202020);
	EAX = [SS:EBP +  4];
	itoa8();
	PUSH(EDX);
	PUSH(ECX);
	asmout("PUSH 'ESI:'");

	PUSH(0x20202020);
	EAX = [SS:EBP +  8];
	itoa8();
	PUSH(EDX);
	PUSH(ECX);
	asmout("PUSH 'EBP:'");

	PUSH(0x20202020);
	EAX = [SS:EBP + 12];
	itoa8();
	PUSH(EDX);
	PUSH(ECX);
	asmout("PUSH 'ESP:'");

	EBX = ESP;
	ECX = 60;
	putstr();
	ESP = EBP;

	for (;;);
}
#endif

/* –{—ˆ‚Í‚±‚¤‚¢‚¤‚Ì‚ÍƒrƒfƒIƒhƒ‰ƒCƒo‘¤‚É‘‚¢‚Ä‚¨‚¢‚ÄAŒÄ‚Ño‚·‚Ì‚ª³‚µ‚¢‚ñ‚¾‚¯‚Ç‚Ë */
#if (defined(TOWNS) && defined(CLGD543X))

/* ƒrƒfƒIƒhƒ‰ƒCƒo‚ÆƒOƒ‰ƒtƒBƒbƒNƒhƒ‰ƒCƒo‚ğ‚Ç‚¤•ª—£‚µ‚æ‚¤‚© */

#define CLGD5430_ID 0x28
#define CLGD5434_ID 0x2a

void clgd543XID()
{
    /* Œ^”Ôƒ`ƒFƒbƒN */
    DX = 0x3d4; AL = 0x27; OUT(DX, AL);	/* 0x3d4, 0x27 for ident reg */
    EDX++; IN(AL, DX);			/* 0x03d5 */
    AL >>= 2;				/* ‰ºˆÊ2ƒrƒbƒg‚ÍƒŠƒrƒWƒ‡ƒ“ */
    CMP(AL, CLGD5430_ID);
    return;
}

void clgd543XDetect()
{
    char *p == CS:ESI;
    asmout("MOV ESI,clgdDetectData");

    /****** detect ******/
    DH = 0x03;
    ECX = 7;
    do {
      DL = p[0];
      AL = p[1];
      (offset) p++;
      OUT(DX, AL);
      (offset) p++;
      ECX--;
    } while(!= 0);

    /* CLGD ‚È‚ç lockReg ‚É‘‚«‚ñ‚¾0x12‚ª“Ç‚İ‚ß‚é */
    EDX++; IN(AL, DX);			/* 0x03c5 */
    if (AL != 0x12) {
      EAX = 0;
      return;				/* not CLGD */
    }

    clgd543XID();
    AH = 0x35;				/* VRAM 1MB */
    if (!=)
      AH = 0x3f;			/* 2MB */

    /* end reset */
    DL = 0xc4; AL = 0; OUT(DX, AL);	/* 0x03c4, 0 */
    EDX++;     AL = 3; OUT(DX, AL);	/* 0x03c5, 3 */

    /* set vram amount */
    EDX--;  AL = 0x0f; OUT(DX, AL);	/* 0x03c4, 0x0f */
    EDX++;  AL = AH;   OUT(DX, AL);	/* 0x03c5, 0x35 or 0x3f */

    /* 5430‚È‚ç1, 5434‚È‚ç2‚ğ•Ô‚· */
    EAX &= 2;
    EAX >>= 1;
    EAX++;
    return;
}

void clgd543XSetup()
{
    char *p == CS:ESI;

    PUSH(ESI);
    if (AL == 2)
      asmout("MOV ESI,clgdSetupData1");	/* 16bpp 800x600 */
    else if (AL == 1)
      asmout("MOV ESI,clgdSetupData0");	/* 8bpp  1024x768 */
    else
      INT(3);

    clgd543XID();
    if (==) {
      PUSH(0x5a);			/* SR16 */
      PUSH(0x30);			/* SRF: 32bit & 64byte FIFO */
    } else {
      PUSH(0x58);			/* SR16 */
      PUSH(0x38);			/* SRF: 64bit & 64byte FIFO */
    }

    DL = 0xda; IN(AL, DX);
    DL = 0xc0; AL = 0; OUT(DX, AL);	/* enable palette access */

    DL = 0xc4;    OUT(DX, AL);		/* 0x03c4, 0 */
    EDX++; EAX++; OUT(DX, AL);		/* 0x03c5, 1 */

    /* MiscOutReg */
    DL = 0xc2; AL = *p; OUT(DX, AL);
    (offset) p++;

    /* Sequencer; */
    ECX = 14;
    do {
      DL = 0xc4; AL = p[0]; OUT(DX,AL);
      (offset) p++;
      if (AL == 0x0f)
	POP(EAX);			/* SRF */
      else if (AL == 0x16)
	POP(EAX);			/* SR16 */
      else
	AL = *p;
      (offset) p++;
      EDX++; OUT(DX, AL);
      ECX--;
    } while (!= 0);

    /* CRTC */
    DL = 0xd4; AL = 0x11; OUT(DX, AL);	/* 0x3d4, 0x11 */
    EDX++; AL = p[17]; AL &= 0x7f;	/* PR bit = 0. 0-7 CRTC regs modifiable */
    OUT(DX, AL);			/* 0x3d5, IN(0x3d5) & 0x7f */
    CL = 0;
    do {
      EDX--; AL = CL; OUT(DX, AL);
      EDX++; AL = *p; OUT(DX, AL);
      (offset) p++;
      CMP(CL, 29); ECX++;
    } while ((unsigned) <);

    /* Graphics */
    DL = 0xce + 1;
    CL = 0;
    do {
      EDX--; AL = CL; OUT(DX, AL);
      EDX++; AL = *p; OUT(DX, AL);
      (offset) p++;
      CMP(CL, 11); ECX++;
    } while ((unsigned) <);

    /* Attribute */
    CL = 0;
    do {
      DL = 0xda; IN(AL, DX);
      DL = 0xc0; AL = CL; OUT(DX, AL);
      AL = *p; (offset) p++; OUT(DX, AL);
      CMP(CL, 20); ECX++;
    } while((unsigned) <);

    /* ƒpƒŒƒbƒgİ’è */
    DL = 0xc6; AL = 0xff; OUT(DX, AL);	/* 0x3c6, 0xff for pixel mask ? */

    /* 0-15 */
    DL = 0xc8; AL = 0; OUT(DX, AL);	/* 0x3c8, 0 access count=0 */
    EAX = 0; EDX++;
    do {
      if (AH != 8) {
	CH = 3;
        do {    /* F”Ô†AH‚É‡ŸR,G,B‚ğ[‚Ä‚Ä‚¢‚­ */
	  CL = 2; AL = AH; CL += CH; AL <<= CL; AL &= 32;
	  if (!=0) {
	    TEST(AH, 8); if (!=0) AL += AL;
	    EAX--;
	  }
	  OUT(DX, AL);
	  CH--;
        } while (!= 0);
      } else {
        AL = 192 / 4;
        OUT(DX, AL); OUT(DX, AL); OUT(DX, AL);
      }
      CMP(AH, 15); AH++;
    } while((unsigned) <);

    /* 192-255 */
    PUSH(ESI);
    DL = 0xc8; AL = 192; OUT(DX,AL);	/* 0x3c8, 0 access count=192 */
    ESI = 0; EDX++;
    do {
      CH = 3;
      do {    /* F”Ô†AL‚É‡ŸR,G,B‚ğ[‚Ä‚Ä‚¢‚­ */
	CL = 3; EAX = ESI; CL -= CH; CL += CL; AL >>= CL; AL &= 0x03;
	AH = AL; AAD(20);
	OUT(DX, AL);
	CH--;
      } while (!= 0);
      CMP(ESI, 63);
      ESI++;
    } while ((unsigned) <);
    POP(ESI);

    DL = 0xc4; AL = 0; OUT(DX, AL);	/* 0x3c4, 0 Sequencer0 */
    EDX++;     AL = 3; OUT(DX, AL);	/* 0x3c5, 3 end reset */

    DL = 0xda; IN(AL, DX);		/* 0x3da */
    DL = 0xc0; AL = 0x20; OUT(DX, AL);	/* 0x3c0, 0x20 disable palette access */

    /* Hidden DAC */
    DL = 0xc6; AL = 0; OUT(DX, AL);	/* 0x3c6, 0 */
    AL = 0xff; OUT(DX, AL);		/* 0x3c6, 0xff */
    IN(AL, DX); IN(AL, DX); IN(AL, DX); IN(AL, DX);
    AL = *p; OUT(DX, AL);		/* 0x3c6, HIDDENDAC */
    POP(ESI);
    DX = 0x055c; AL = 1; OUT(DX, AL);	/* 0x55c, 1 switch RGBout to CLGD */
    return;
}

void clgdDetectData()
{
    DB(0xc3,1);		    /* enable cirrus ports */
    DB(0xc4,0, 0xc5,1);	    /* synchronous reset */
    DB(0xc2,0xed);	    /* disable display memory bit = 0 */
    DB(0xc4,6, 0xc5,0x12);  /* unlock cirrus special */
    DB(0xc4,6);
}
void clgdSetupData0()
{
    /* MiscOutReg: */
    DB(0xef);
    /* Sequencer: */
    DB( 0, 0x00,  1, 0x01,  2, 0x0f,  3, 0x00,  4, 0x0e,  7, 0xe1, 14, 0x6f);
    DB(15, 0x30, 18, 0x00, 19, 0x00, 22, 0x5a, 23, 0x00, 30, 0x2a, 31, 0x1a);
    /* CRTC: */
    DB(0xa2, 0x7f, 0x80, 0x81, 0x81, 0x01, 0x24, 0xfd);
    DB(0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
    DB(0x03, 0x00, 0xff, 0x80, 0x00, 0x03, 0x04, 0xc3);
    DB(0xff, 0x00, 0xe0, 0x82, 0x00, 0x00);
    /* Graphics: */
    DB(0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x05, 0x0f);
    DB(0xff, 0x00, 0x00, 0x20);
    /* Attribute: */
    DB(0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07);
    DB(0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f);
    DB(0x41, 0x00, 0x0f, 0x00, 0x00);
    /* HiddenDAC: */
    DB(0x00);
}
void clgdSetupData1()
{
    /* MiscOutReg: */
    DB(0x2F);
    /* Sequencer: */
    DB( 0, 0x00,  1, 0x01,  2, 0x0f,  3, 0x00,  4, 0x0e,  7, 0xe7, 14, 0x51);
    DB(15, 0x30, 18, 0x00, 19, 0x00, 22, 0x5b, 23, 0x00, 30, 0x3a, 31, 0x1a);
    /* CRTC: */
    DB(0x82, 0x63, 0x64, 0x85, 0x65, 0x85, 0x66, 0xF0);
    DB(0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
    DB(0x59, 0x2D, 0x57, 0xC8, 0x00, 0x59, 0x5A, 0xC3);
    DB(0xFF, 0x00, 0x90, 0x82, 0x00, 0x00);
    /* Graphics: */
    DB(0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x05, 0x0F);
    DB(0xFF, 0x00, 0x00, 0x20);
    /* Attribute: */
    DB(0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07);
    DB(0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F);
    DB(0x41, 0x00, 0x0F, 0x00, 0x00);
    /* HiddenDAC: */
    DB(0xE1);
}
#if 0 /* 70Hz */
void clgdSetupData1()
{
    /* MiscOutReg: */
    DB(0x2F);
    /* Sequencer: */
    DB( 0, 0x00,  1, 0x01,  2, 0x0f,  3, 0x00,  4, 0x0e,  7, 0xe7, 14, 0x55);
    DB(15, 0x30, 18, 0x00, 19, 0x00, 22, 0x5b, 23, 0x00, 30, 0x36, 31, 0x1a);
    /* CRTC: */
    DB(0x87, 0x63, 0x68, 0x89, 0x69, 0x89, 0x6c, 0xF0);
    DB(0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
    DB(0x59, 0x2D, 0x57, 0xC8, 0x00, 0x59, 0x5A, 0xC3);
    DB(0xFF, 0x00, 0x90, 0x82, 0x00, 0x00);
    /* Graphics: */
    DB(0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x05, 0x0F);
    DB(0xFF, 0x00, 0x00, 0x20);
    /* Attribute: */
    DB(0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07);
    DB(0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F);
    DB(0x41, 0x00, 0x0F, 0x00, 0x00);
    /* HiddenDAC: */
    DB(0xE1);
}
#endif
#endif

#if (defined(TOWNS))
void towns15crtc()
{
	DW(0x0060, 0x02C0, 0xffff, 0xffff, 0x031F, 0x0000, 0x0004, 0x0000);
	DW(0x0419, 0x00CA, 0x02CA, 0x00CA, 0x02CA, 0x0046, 0x0406, 0x0046);
	DW(0x0406, 0x0000, 0x00CA, 0x0000, 0x0080, 0x0000, 0x00CA, 0x0000);
	DW(0x0080, 0x0058, 0x0001, 0x0000, 0x800A, 0x0002, 0xC200, 0x0192);
}
#endif
