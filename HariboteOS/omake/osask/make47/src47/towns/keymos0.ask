// "keymos0.ask" for TOWNS ver.0.5 copyright(C) 2004 I.Tak, H.Kawai(å·åˆç§€å®Ÿ)

// ã“ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚‚OTASKç‰ˆã¨åŒã˜ãã€ã‚­ãƒ¼ã‚’æŠ¼ã—ãªãŒã‚‰æŠœãã¨ãƒ•ã‚§ãƒ¼ã‚ºãŒç‹‚ã†

/* FM-R mouse driver added by I.Tak. 2004
 */
#define FMRMOUSE	/* enables rmouse routine */

/* ASKAã®æµ¦å’Œåº§
 * char *send_buf == DS:ESI;
 * AL = send_buf[17];                   // OK
 * send_buf[17] = AL;                   // error
 * [send_buf+17] = AL;                  // OKâ€¦â€¦ãªã‚“ã ã£ã¦ãƒ¼!
 * [send_buf+ECX+17] = AL;              // OKâ€¦â€¦ãªã‚“ã ã£ã¦ãƒ¼!
 * (offset)send_buf = work->mouse_send_buf; // ãƒ¡ãƒ¢ãƒªã‚¢ã‚¯ã‚»ã‚¹â€¦â€¦ãªã‚“ã ã£ã¦ãƒ¼!
 * (offset)send_buf = (offset)work->mouse_send_buf; // ãƒã‚¤ãƒ³ã‚¿ã®ä»£å…¥â€¦â€¦ãªã‚‹ã»ã©
 * work->keyjmp = (offset)KeyIntDrv_Normal; // error
 * work->keyjmp = (int)KeyIntDrv_Normal; // errorã«ãªã‚‰ãªã„ã“ã¨ã‚‚ã‚ã‚‹â€¦â€¦?
 */

#include "osaskinc.ask"

segment CODE(USE32, PARA);
default(code == CODE);

struct keyboarddata {
	int send_buf[64]; // 0x00
	int pushflags[64]; // 0x40
	int queue_buf[128]; // 0x80 (dwæ•°:32...ãƒ–ãƒ­ãƒƒã‚¯ã¯æœ€é«˜ã§ã‚‚8dwç¨‹åº¦ã«)
	int mouse_queue_buf[128]; // 0x100
	int keysignal[6], [2]; // 0x180
	/* void near * */ int keyjmp; // 0x188
	int mousejmp;
	unsigned int queue_free_dw, queue_write_ptr; // 0x190, 0x194
	unsigned int queue_exec_ptr, exec_wait_int;  // 0x198, 0x19c
	unsigned int mouse_queue_free_dw, mouse_queue_write_ptr; // 0x1a0, 0x1a4
	unsigned int mouse_queue_exec_ptr, mouse_exec_wait_int;  // 0x1a8, 0x1ac
	int mousesignal[6], [2]; // 0x1b0
	int keyerr_signal[6], [2]; // 0x1b8
	int mouse_send_buf[64]; // 0x1c0
	int err_send_buf[64]; // 0x200
	char firstbyte;
//	int mouse_x, mouse_y;
//	unsigned char led;
};

struct SS0_struct {
	void [32];
	char ring0_count, [3];
	/* void * */ int [4], ring0call[6], [2];
	char cli_count, [3];
	/* void * */ int [4], cli_call[6], [2];
};

void near keyboardInit();
void near KeyboardQueueExecute();
void near MouseQueueExecute();
void near KeyIntDrv_Normal();

void far keyboard_syscmd()
{
	int *cmd == FS:EBX;

	PUSHAD();
	MOV(EAX, CS);
	PUSH(DS);
	EAX += 8;
	DS = AX;
nextcmd:
	EAX = *cmd;
	if (EAX == 0)
		goto cmd0000;
//	if (EAX == 0x0108)
//		goto cmd0108; // KeySetLed
//	if (EAX == 0x0120)
//		goto cmd0120; // MouseEnable
	if (EAX == 0x0104)
		goto cmd0104; // KeyboardReset
//	if (EAX == 0x011c)
//		goto cmd011c; // MouseReset
	if (EAX == 0x0114)
		goto cmd0114; // SetFinishSignal
	if (EAX == 0x0110)
		goto cmd0110; // connect Decoder
//	if (EAX == 0x0118)
//		goto cmd0118; // KeyEnableA20
	if (EAX == 0x0100)
		goto cmd0100; // åˆæœŸåŒ–
//	if (EAX == 0x010c)
//		goto cmd010c; // KeyResetCPU
	if (EAX == 0x0124)
		goto cmd0124; // KeyboardIntDrvã®ãƒ™ã‚¯ã‚¿æä¾›
//	if (EAX == 0x0128)
//		goto cmd0128; // MouseIntDrvã®ãƒ™ã‚¯ã‚¿æä¾›
	if (EAX == 0x0018)
		goto cmd0018; // ãƒãƒ¼ã‚¸ãƒ§ãƒ³è¦æ±‚

	INT(0x03);

cmd0000:
	POP(DS);
	[SS:ESP + 16] = EBX;
	POPAD();
	return;

cmd0100:
	// åˆæœŸåŒ–
	PUSH((offset) cmd);
	keyboardInit();
	POP((offset) cmd);
	(offset) cmd += 4;
	goto nextcmd;

cmd0104:
	// KeyboardReset
	// æœ¬å½“ã¯ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’è¦‹ã¦ã€ãƒãƒƒãƒ•ã‚¡ãŒã‚ã„ã¦ã„ã‚‹ã‹ã©ã†ã‹ã‚’ç¢ºèªã—ãŸæ–¹ãŒã‚ˆã„
	EDX = 0x0602;
	AL = 0xa1;
	OUT(DX, AL);
	(offset) cmd += 4;
	goto nextcmd;

#if 0
cmd0108:
	// KeySetLed
	EAX = cmd[4];
	PUSH(FS);
	PUSH((offset) cmd);
	CX = SS;
	ESP -= 28;
	FS = CX;
	unsigned int *led_cmds == SS:ESP;
	led_cmds[0] = 5;
	asmout("MOV DWORD PTR SS:[ESP+4],OFFSET KeyQueCmd_WaitBufEnpty");
	/* led_cmds[ 4] = (offset) KeyQueCmd_AckSendData */ asmout("MOV DWORD PTR SS:[ESP+8],OFFSET KeyQueCmd_AckSendData");
	/* (char) led_cmds[ 8] = 0xed */ asmout("MOV BYTE PTR SS:[ESP+12],0EDH");
	/* led_cmds[12] = (offset) KeyQueCmd_AckSendData */ asmout("MOV DWORD PTR SS:[ESP+16],OFFSET KeyQueCmd_AckSendData");
	/* (char) led_cmds[16] */ [led_cmds + 20] = AL;
	led_cmds[24] = 0;
	EBX = ESP;
	KeyboardQueueExecute();
	ESP += 28;
	POP((offset) cmd);
	POP(FS);
	(offset) cmd += 8;
	goto nextcmd;

cmd010c:
	// KeyResetCPU
	PUSH(FS);
	PUSH((offset) cmd);
	AX = CS;
	FS = AX;
	/* EBX = (offset) cmd010c_cmdline; */ asmout("MOV EBX,OFFSET #cmd010c_cmdline");
	KeyboardQueueExecute();
	POP((offset) cmd);
	POP(FS);
	(offset) cmd += 4;
	goto nextcmd;

// æœ¬æ¥ãªã‚‰ã€CFã‚‚ãƒã‚§ãƒƒã‚¯ã—ãªãã¦ã¯ã„ã‘ãªã„ã—ã€
// æ­£å¸¸çµ‚äº†å‰²ã‚Šè¾¼ã¿ã‚‚ç™ºè¡Œã™ã¹ã

	ALIGN(4);

cmd010c_cmdline:

// æœ¬æ¥ã¯ã€æœ€åˆã«ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚’ä»•æ›ã‘ã¦ã€ãƒãƒƒãƒ•ã‚¡ã‚’åã‹ã›ã‚‹ã¹ã

	DD(3);
	asmout("DD OFFSET KeyQueCmd_WaitBufEnpty");
	asmout("DD OFFSET KeyQueCmd_WriteCmdReg,0FEH"); // reset CPU
	DD(0);

// Bit 7  Keyboard data (output)    1
// Bit 6  Keyboard clock (output)   1
// Bit 5  Input buffer empty        0
// Bit 4  Output buffer full        1
// Bit 3  Reserved                  1
// Bit 2  Reserved                  1
// Bit 1  Gate A20                  1
// Bit 0  System Reset              0
#endif

cmd0110:
	// connect Decoder
	EAX = cmd[4];
	ECX = cmd[8];
	(int) [DS:0x0180] = EAX;
	(int) [DS:0x0184] = ECX;
	(offset) cmd += 12;
	goto nextcmd;

cmd0114:
	// SetFinishSignal
	MOV(EAX, SS);
	PUSH(FS);
	PUSH((offset) cmd);
	PUSH((int) 0);
	asmout("PUSH OFFSET KeyQueCmd_MakeFinishSignal");
	PUSH(cmd[16]);
	PUSH(cmd[12]);
	PUSH(cmd[ 8]);
	PUSH(cmd[ 4]);
	asmout("PUSH OFFSET KeyQueCmd_SetErrSignal");
	PUSH((int) 6);
	FS = AX;
	EBX = ESP;
	KeyboardQueueExecute();
	if (CF == 0) {
		ESP += 4 * 8;
		POP((offset) cmd);
		POP(FS);
		(offset) cmd += 20;
		goto nextcmd;
	}
	INT(0x03);

#if 0
cmd0118:
	// KeyEnableA20
	AX = CS;
	PUSH(FS);
	PUSH((offset) cmd);
	FS = AX;
	/* EBX = (offset) cmd0118_cmdline */ asmout("MOV EBX,OFFSET #cmd0118_cmdline");
	KeyboardQueueExecute();
	POP((offset) cmd);
	POP(FS);
	(offset) cmd += 4;
	goto nextcmd;

// æœ¬æ¥ãªã‚‰ã€CFã‚‚ãƒã‚§ãƒƒã‚¯ã—ãªãã¦ã¯ã„ã‘ãªã„ã—ã€
// æ­£å¸¸çµ‚äº†å‰²ã‚Šè¾¼ã¿ã‚‚ç™ºè¡Œã™ã¹ã

	ALIGN(4);

cmd0118_cmdline:

// æœ¬æ¥ã¯ã€æœ€åˆã«ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚’ä»•æ›ã‘ã¦ã€ãƒãƒƒãƒ•ã‚¡ã‚’åã‹ã›ã‚‹ã¹ã

	DD(6);
	asmout("DD OFFSET KeyQueCmd_WaitBufEnpty");
	asmout("DD OFFSET KeyQueCmd_WriteCmdReg,0D1H");
	asmout("DD OFFSET KeyQueCmd_WaitBufEnpty");
	asmout("DD OFFSET KeyQueCmd_SendData,0DFH"); // enable A20 (0xddã ã¨disable)
	DD(0);

// Bit 7  Keyboard data (output)    1
// Bit 6  Keyboard clock (output)   1
// Bit 5  Input buffer empty        0
// Bit 4  Output buffer full        1
// Bit 3  Reserved                  1
// Bit 2  Reserved                  1
// Bit 1  Gate A20                  1
// Bit 0  System Reset              1

cmd011c:
	// MouseReset
	AX = CS;
	PUSH(FS);
	PUSH((offset) cmd);
	FS = AX;
	/* EBX = (offset) cmd011c_cmdline */ asmout("MOV EBX,OFFSET #cmd011c_cmdline");
	MouseQueueExecute();
	POP((offset) cmd);
	POP(FS);
	(offset) cmd += 4;
	goto nextcmd;

// æœ¬æ¥ãªã‚‰ã€CFã‚‚ãƒã‚§ãƒƒã‚¯ã—ãªãã¦ã¯ã„ã‘ãªã„ã—ã€
// æ­£å¸¸çµ‚äº†å‰²ã‚Šè¾¼ã¿ã‚‚ç™ºè¡Œã™ã¹ã

	ALIGN(4);

cmd011c_cmdline:

// æœ¬æ¥ã¯ã€æœ€åˆã«ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚’ä»•æ›ã‘ã¦ã€ãƒãƒƒãƒ•ã‚¡ã‚’åã‹ã›ã‚‹ã¹ã

	DD(9);
	asmout("DD OFFSET KeyQueCmd_WaitBufEnpty");
	asmout("DD OFFSET KeyQueCmd_WriteCmdReg,060H");  // write mode command
	asmout("DD OFFSET KeyQueCmd_WaitBufEnpty");
	asmout("DD OFFSET KeyQueCmd_SendData,047H"); // 01000111b
		// IRQ01 enable, IRQ12 enable, system flag on, keylock enable
		// keyboard interface enable, mouse interface enable, scan code 1(PC format)
	asmout("DD OFFSET KeyQueCmd_WaitBufEnpty");
	asmout("DD OFFSET KeyQueCmd_WriteCmdReg,0A8H");  // mouse interface enable

	DD(2 /* 7 */);
	asmout("DD OFFSET KeyQueCmd_WaitBufEnpty");
//	asmout("DD OFFSET MouQueCmd_AckSendData,0FFH"); // mouse reset
		// â†‘ã“ã®ã‚³ãƒãƒ³ãƒ‰ãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ãŸã‚‰ã€ãƒã‚¦ã‚¹ã¯ã¤ãªãŒã£ã¦ã„ãªã„
//	asmout("DD OFFSET MouQueCmd_RecieveCheck,0AAH"); // power on reset(resetæˆåŠŸ ç¬¬1ãƒã‚¤ãƒˆ)
//	asmout("DD OFFSET MouQueCmd_RecieveCheck,000H"); // power on reset(resetæˆåŠŸ ç¬¬2ãƒã‚¤ãƒˆ)
	asmout("DD OFFSET MouQueCmd_ResetCommand");

	DD(0);

cmd0120:
	// MouseEnable
	AX = CS;
	PUSH(FS);
	PUSH((offset) cmd);
	FS = AX;
	/* EBX = (offset) cmd0120_cmdline */ asmout("MOV EBX,OFFSET #cmd0120_cmdline");
	MouseQueueExecute();
	POP((offset) cmd);
	POP(FS);
	(offset) cmd += 4;
	goto nextcmd;

// æœ¬æ¥ãªã‚‰ã€CFã‚‚ãƒã‚§ãƒƒã‚¯ã—ãªãã¦ã¯ã„ã‘ãªã„ã—ã€
// æ­£å¸¸çµ‚äº†å‰²ã‚Šè¾¼ã¿ã‚‚ç™ºè¡Œã™ã¹ã

	ALIGN(4);

cmd0120_cmdline:

// æœ¬æ¥ã¯ã€æœ€åˆã«ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚’ä»•æ›ã‘ã¦ã€ãƒãƒƒãƒ•ã‚¡ã‚’åã‹ã›ã‚‹ã¹ã

	DD(3);
	asmout("DD OFFSET KeyQueCmd_WaitBufEnpty");
//	asmout("DD OFFSET KeyQueCmd_WriteCmdReg,0D4H"); // to mouse prefix
//	asmout("DD OFFSET KeyQueCmd_WaitBufEnpty");
	asmout("DD OFFSET MouQueCmd_AckSendData,0F4H"); // mouse enable

	DD(0);
#endif

cmd0124:
	// KeyboardIntDrvã®ãƒ™ã‚¯ã‚¿æä¾›
	asmout("MOV DWORD PTR FS:[EBX+4],OFFSET KeyboardIntDrv");
	(short) cmd[8] = CS;
	(offset) cmd += 12;
	goto nextcmd;

#if 0

cmd0128:
	// MouseIntDrvã®ãƒ™ã‚¯ã‚¿æä¾›
	asmout("MOV DWORD PTR FS:[EBX+4],OFFSET MouseIntDrv");
	(short) cmd[8] = CS;
	(offset) cmd += 12;
	goto nextcmd;

#endif

cmd0018:
	// ãƒãƒ¼ã‚¸ãƒ§ãƒ³è¦æ±‚
	// æœ¬æ¥ã¯ã€cmd[4]ãŒ0ã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèªã—ãªã‘ã‚Œã°ã„ã‘ãªã„
	cmd[ 8] = 300; // ver.0.30
	cmd[12] = 0;
	cmd[16] = 0;
	cmd[20] = 0;
	(offset) cmd += 24;
	goto nextcmd;
}

void near keyboardInit()
// æœ¬æ¥ãªã‚‰ã“ã„ã¤ã¯ï¼‘ã¤ã®ã‚¿ã‚¹ã‚¯ã¨ã—ã¦èµ·å‹•ã™ã‚‹ã€‚
// LDTã«ã‚·ã‚¹ãƒ†ãƒ ã‚³ãƒ¼ãƒ«å¿…è¦ãªå…¨ã¦ã®ç’°å¢ƒã‚’æŒã¡ã€
// ã‚»ãƒƒãƒ†ã‚£ãƒ³ã‚°ãŒæ¸ˆã‚“ã ã‚‰ã€ã‚¹ãƒªãƒ¼ãƒ—ã™ã‚‹ã€‚
// æ±ç”¨ãƒ¬ã‚¸ã‚¹ã‚¿ã¯ã€ã™ã¹ã¦ç ´å£Šã•ã‚Œã‚‹
{
	unsigned int Init_sel     ==  2 * 8, TAPI_sel   == 12 * 8;

	// ASKAã®ãƒ•ã‚©ãƒ­ãƒ¼ã®ãŸã‚ã®å®šæ•°å®£è¨€
	asmout("work_send_buf EQU 0000H");
	asmout("work_pushflags EQU 0040H");
	asmout("work_queue_buf EQU 0080H");
	asmout("work_queue_buf_size EQU 0080H");
	asmout("work_mouse_queue_buf EQU 0100H");
	asmout("work_mouse_queue_buf_size EQU 0080H");
	asmout("work_mousejmp EQU 018CH");
	asmout("work_mouse_exec_wait_int EQU 01ACH");
	asmout("work_mousesignal EQU 01B0H");
	asmout("work_keyerr_signal EQU 01B8H");
	asmout("work_mouse_send_buf equ 01C0H");
	asmout("work_err_send_buf EQU 0200H");

	keyboarddata *work == DS:0;
	int zero == EAX, i == ECX;

#if 0
	PUSH(DS); // ã‚ã‚‰ã‹ã˜ã‚ã€mallocã—ã¦GDTã«å‰²ã‚Šå½“ã¦ã¦ãŠã
	PUSH(EAX);
	PUSH(ECX);
	AX = CS; AX += 8; DS = AX; // ç‰¹å®šã®DSã«ä¾å­˜ã—ãªã„ãŸã‚ã®æ‰‹ç¶šã
#endif
	zero = 0;
	i = 64 + 64 / 8; // ã¤ã„ã§ã«pushflagsã‚‚åˆæœŸåŒ–
#if (defined(PERFECTASKA))
	do {
		i--;
		work->send_buf[i * 8 + 0] = zero;
		work->send_buf[i * 8 + 4] = zero;
	} while (!= 0);
	work->keyjmp = KeyIntDrv_Normal;
	work->queue_free_dw = sizeof (work->queue_buf) / 4 - 1; /* quecmd_tonormalã®åˆ† */
	work->queue_write_ptr = (offset) work->queue_buf;
	work->queue_exec_ptr  = (offset) work->queue_buf;
#else
	do {
		i--;
		[work->send_buf+ ECX * 8 + 0] = zero;
		[work->send_buf+ ECX * 8 + 4] = zero;
	} while (!= 0);
	asmout("MOV DWORD PTR DS:[188h], OFFSET KeyIntDrv_Normal");
	work->queue_free_dw = 128 / 4 - 1; /* quecmd_tonormalã®åˆ† */
	work->queue_write_ptr = 0x80;
	work->queue_exec_ptr  = 0x80;
#endif

#if 0
	/* work->keysignal[0] = keytest; */ asmout("MOV DWORD PTR DS:[0180h],OFFSET keytest");
	/* work->keysignal[4] */ [work + 0x184] = CS;
	asmout("MOV DWORD PTR DS:[0000H],000007F1H");
	asmout("MOV DWORD PTR DS:[0004H],5");
	asmout("MOV DWORD PTR DS:[0180H],OFFSET Keydecode_Main");
	asmout("MOV DWORD PTR DS:[0184H],22*8");
#endif

#if (defined(FMRMOUSE))
	PUSH(FS);
	PUSH(SS);
	POP(FS);
	PUSH(zero); // eoc
	PUSH(zero);
	PUSH(zero);
	PUSH(0x011c /* TAPI_SingnalMessageTimerãƒ™ã‚¯ã‚¿è¦æ±‚ */);
	EBX = ESP;
	DB(0x9a); DD(0); DW((short) TAPI_sel);
	POP(EAX);
	POP(work->mousesignal[0]);
	POP(work->mousesignal[4]);
	POP(EAX);
	POP(FS);
#endif

#if (defined(PERFECTASKA))	/* æ–°ã‚¹ã‚¿ã‚¤ãƒ«ã®ææ¡ˆ */
  #if (defined(FMRMOUSE))
	work->mouse_send_buf[0] = 0x00003243;
	work->mouse_send_buf[4] = 0x7f000002;
	work->mouse_send_buf[8] = 0x73756f6d + 1;
	work->mouse_send_buf[16] = zero;
  #endif
	work->keyerr_signal[0] = (offset) dummy_fret;
	work->keyerr_signal[4] = CS;
#else
  #if (defined(FMRMOUSE))
	(int)[work->mouse_send_buf+0] = 0x00003243;
	(int)[work->mouse_send_buf+4] = 0x7f000002;
	(int)[work->mouse_send_buf+8] = 0x73756f6d + 1;
	(int)[work->mouse_send_buf+16] = zero;
  #endif
	[work->keyerr_signal+0] = (offset) dummy_fret;
	[work->keyerr_signal+4] = CS;
#endif

	EDX = 0x0604;
	AL = 1;
	OUT(DX, AL);

#if 0
	POP(ECX);
	POP(EAX);
	POP(DS);
#endif

dummy_fret:
	asmout("dummy_fret:");
	return;
}

/*
	DS:ESIã‹ã‚‰ã®ä»•æ§˜(ã‚¿ã‚¤ãƒãƒ¼å°‚ç”¨ã‚·ã‚°ãƒŠãƒ«å‡¦ç†ãƒ«ãƒ¼ãƒãƒ³ä½¿ç”¨æ™‚)ã€‚
	+00 : bit0-2 : ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸dwæ•°ã€‚æœ€é«˜7(28bytes)ã€‚
	      bit3   : eax, ecx, edxãƒ­ãƒ¼ãƒ‰ & CF = 1ã‚’ã‚„ã‚‹ã‹ã‚„ã‚‰ãªã„ã‹(1ã§ã‚„ã‚‹)ã€‚
	      bit4-  : ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®é€ä¿¡å…ˆã®æŒ‡å®šã«ä½¿ã†ï¼ˆã‚·ã‚°ãƒŠãƒ«ãƒãƒ¼ãƒˆï¼‰ã€‚
	+04 -	     : ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æ›¸ã

	DS:ESIã‹ã‚‰ã®ä»•æ§˜(æ±ç”¨ã‚·ã‚°ãƒŠãƒ«å‡¦ç†ãƒ«ãƒ¼ãƒãƒ³ä½¿ç”¨æ™‚)ã€‚
	+00 : bit0-3 : ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸dwæ•°ã€‚æœ€é«˜15(60bytes)ã€‚
	      bit4-  : ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®é€ä¿¡å…ˆã®æŒ‡å®šã«ä½¿ã†ï¼ˆã‚·ã‚°ãƒŠãƒ«ãƒãƒ¼ãƒˆï¼‰ã€‚
	+04 -	     : ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æ›¸ã

	ä¸€èˆ¬ã«ã¯ã€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æœ¬ä½“ã®æœ€åˆã®4ãƒã‚¤ãƒˆã¯ã€å—ã‘å–ã£ãŸãƒ«ãƒ¼ãƒãƒ³ãŒèª°ã‹ã‚‰ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã§ã‚ã‚‹ã‹ã‚’
	è­˜åˆ¥ã™ã‚‹ã®ã«ä½¿ã‚ã‚Œã‚‹ã€‚ã‚†ãˆã«ã€ã‚­ãƒ¼ã‚³ãƒ¼ãƒ‰å€¤ãªã©ã¯ã€+08ã«æ›¸ãè¾¼ã¾ã‚Œã‚‹ã€‚
*/

void far KeyboardIntDrv()
{
#if 0
	struct SS0_struct {
		void [32];
		int ring0_count;
		/* void * */ int [4], ring0call[6], [2];
		int cli_count;
		/* void * */ int [4], cli_call[6], [2];
	};
#endif

	SS0_struct *ss0 == /* SS:(- sizeof (SS0_struct)) */ SS:0xffffffc0;

	PUSH(DS);
	PUSH(EAX);
	PUSH(EDX);
	MOV(EAX, CS); EAX += 8; DS = AX; // ç‰¹å®šã®DSã«ä¾å­˜ã—ãªã„ãŸã‚ã®æ‰‹ç¶šã
	ss0->ring0_count++; // å‰²ã‚Šè¾¼ã¿ãƒ«ãƒ¼ãƒãƒ³ã®åŸºæœ¬
	ss0->cli_count++;
}

void near KeyboardIntDrv2()
{
	keyboarddata *work == DS:0;

	EDX = 0x0602;
	IN(AL, DX);
	EDX -= 2;
	IN(AL, DX);
	AH = AL;
	AL = 0x61 /* IRQ-01ã‚’çµ‚äº† */;
	OUT(0x00, AL);
	asmout("JMP DWORD PTR DS:[0188H]"); // goto work->keyjmp;
}


/* ç¬¬ä¸€ãƒã‚¤ãƒˆã¯0x80ãŒç«‹ã£ã¦ã„ã‚‹ã€‚ä»–ã¯ç«‹ã£ã¦ã„ãªã„ã€‚
 * ç¬¬äºŒãƒã‚¤ãƒˆãŒ0x7eã ã¨ãã‚Œã¯æ‹¡å¼µã‚³ãƒ¼ãƒ‰ã‚‰ã—ã,
 * ã•ã‚‰ã«å¾Œç¶šã®ãƒã‚¤ãƒˆã‚’èª­ã‚“ã§ã‚³ãƒ¼ãƒ‰ã¨ã™ã‚‹ã€‚
 */
/*
 * buf[0]=0xE0ï½0xE7ã§å§‹ã¾ã‚‹ã®ã¯FMRãƒã‚¦ã‚¹ã€‚
 *  0x04ãŒç«‹ã£ã¦ã„ã‚‹ã¨, ãƒœã‚¿ãƒ³æƒ…å ±ãŒä»˜ãã€‚
 *  0x02ã¯dyã®MSB, 0x01ã¯dxã®MSB (å¾Œç¶šãƒã‚¤ãƒˆã§ã¯MSBã‚’ç«‹ã¦ãªã„æ±ºã¾ã‚Šãªã®ã§)ã€‚
 * buf[1]=dx, buf[2]=dyã€‚
 * buf[3]=R+L*2+C*4	each bit is 1 if pushed.
 */
void near KeyIntDrv_Normal()
{
	keyboarddata *work == DS:0;
	unsigned int keycode == EAX;
	if (AH < 0) {
		// ç¬¬ä¸€ãƒã‚¤ãƒˆ
		work->firstbyte = AH;
#if (defined(FMRMOUSE))
		AH -= 0xe0;
		if ((unsigned)AH < 8)
			work->keyjmp = (int)KeyIntDrv_rmouse;
#endif
		goto fin;
	}
	// ç¬¬äºŒãƒã‚¤ãƒˆ
	/* (false) */ if (AH == 0x7e) {
		/* work->keyjmp = KeyIntDrv_E0byte; */ asmout("MOV DWORD PTR DS:[0188H],OFFSET KeyIntDrv_7Ebyte");
		goto fin;
	}
#if 0
if (AL == 0x01 /* ESC */) { // !!!
	// +00 : EAX
	// +04 : DS
	// +08 : EIP
	// +12 : CS
	// +16 : ELFAGS
	EAX = (int) [SS:ESP +  8];
	ECX = (int) [SS:ESP + 12];
	INT(0x03);
}
#endif

	AL = AH;

send_keycode_AL:
	asmout("KeyIntDrv_send_keycode_AL: EQU $");
	AH = work->firstbyte;
	(unsigned char) AH >>= 4;
	if (AH != 0x0f) {
		// make/break
		keycode <<= 23;
		(signed int) keycode >>= 23;
		keycode &= 0x010000ff; // 00:make, 01:break
	} else {
		keycode &= 0x020000ff;
		keycode |= 0x02000000;
	}
send_keycode:
	/* make/breakã®å ´åˆã¯ã€remakeã‚„overbreakã®ãƒã‚§ãƒƒã‚¯ã‚‚ã™ã‚‹ */
	asmout("KeyIntDrv_send_keycode: EQU $");
	PUSHAD();
#if 0
	if (keycode < 0x02000000) {
		keycode2 = keycode;
		keycode3 = 0;
		keycode2 &= 0x1ff;
		/* (true) */ if (keycode < 0x01000000) {
			// make
			/* BTS(*(work->pushflags), keycode2) */ asmout("BTS DWORD PTR DS:[040H],ECX");
		} else {
			// break
			/* BTR(*(work->pushflags), keycode2) */ asmout("BTR DWORD PTR DS:[040H],ECX");
			CMC() /* CF =~ CF */;
		}
		ADC(keycode3, 0);
		keycode3 <<= 25; // EAX = 0 or 0x02000000
		keycode |= keycode3;
	}
#endif

	/* work->send_buf[8] */ [work + 0x08] = keycode;
	// make/remake/break/overbreakã®ã„ãšã‚Œã§ã‚‚ã€é€ä¿¡ã™ã‚‹
	ESI = /* &work->send_buf */ 0x00;
	/* (work->keysignal)() */ asmout("CALL FAR DWORD DS:[0180H]"); 
	// ESIã‚‚å«ã‚ã€æ±ç”¨ãƒ¬ã‚¸ã‚¹ã‚¿ã¯ã™ã¹ã¦ç ´å£Šã•ã‚Œã‚‹
	POPAD();
fin:
}

void near KeyIntDrv_Ret()
{
//	IN(AL, 0x64);
//	AL &= 0x21;
	// if (AL == 1 /* keyboard data ã‚ã‚Š */) goto KeyboardIntDrv2;
//	CMP(AL, 1);
//	asmout("JE KeyboardIntDrv2");
		// ãŸã„ã¦ã„ã®å ´åˆã€KeyIntDrv_Normalã«æˆ»ã£ã¦ãã‚‹ã ã‚ã†ã€‚
		// ã—ã‹ã—ã€ã‚­ãƒ¼ã‚·ã‚°ãƒŠãƒ«ãŒå¼•ãé‡‘ã«ãªã£ã¦ã€ã‚³ãƒãƒ³ãƒ‰ãƒ¢ãƒ¼ãƒ‰ã«ç§»ã‚‹ã‹ã‚‚ã—ã‚Œãªã„ã€‚
//	AL = 0x61 /* IRQ-01ã‚’çµ‚äº† */;
//	OUT(0x20, AL);
	POP(EDX);
	POP(EAX);

	SS0_struct *ss0 == /* SS:(- sizeof (SS0_struct)) */ SS:0xffffffc0;

	ss0->cli_count--; // å‰²ã‚Šè¾¼ã¿ãƒ«ãƒ¼ãƒãƒ³ã®åŸºæœ¬
	if (== 0) goto call_clicall;
	POP(DS);
	ss0->ring0_count--;
	if (== 0) goto call_ring0call;
	IRETD();

call_clicall:
	PUSHAD();
	/* (ss0->clicall)() */ asmout("CALL FAR DWORD SS:[0FFFFFFC0H+038H]");
	POPAD();
	POP(DS);
	ss0->ring0_count--;
	if (== 0) goto call_ring0call;
	IRETD();

call_ring0call:
	/* (ss0->ring0call)() */ jmp_system_count0();
//	IRETD();
}


#if (defined(FMRMOUSE))
/* FMRãƒã‚¦ã‚¹ãƒ‰ãƒ©ã‚¤ãƒ */
void near KeyIntDrv_rmouse()
{
	keyboarddata *work == DS:0;
	unsigned int keycode == EAX;

	asmout("#fin EQU KeyIntDrv_Ret");
	if (AH < 0)
		goto fin; // ç¬¬ä¸€ãƒã‚¤ãƒˆ
	// ç¬¬äºŒãƒã‚¤ãƒˆä»¥é™
	AL = work->firstbyte;	/* AL=0xe?ãªã‚‰ç¬¬ä¸€ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿, 0x0?ã¯ç¬¬äºŒ, 0x2?ã¯ç¬¬ä¸‰ */
	AL += 0x20;		/* ã‚«ã‚¦ãƒ³ãƒˆã‚¢ãƒƒãƒ—, 0xe?ãªã‚‰CF */
	work->firstbyte = AL;
	if (CF != 0) {
		/* dx */
		AL <<= 7;
		AL |= AH;
		[work->mouse_send_buf+12+1] = AL;
	} else if (AL < 0x40) {
		/* dy */
		AH *= 2;
		AL >>= 2;
		RCR(AH, 1);
		[work->mouse_send_buf+12+2] = AH;
		TEST(AL, 1);
		if (== 0) goto send;	/* 2byteã§çµ‚ã‚ã‚Š */
	} else {		
		/* ãƒœã‚¿ãƒ³ */
		AH &= 0x03;
		AH += 0xfe;
		ADC(AH, AH);		/* exchange bit0, bit1 */
		AH &= 0x03;
		[work->mouse_send_buf+12] = AH;
	send:
		PUSHAD();
		ESI = (offset)work->mouse_send_buf;
	#if (defined(PERFECTASKA))
		work->keyjmp = KeyIntDrv_Normal;
		(work->mousesignal)();
		// ESIã‚‚å«ã‚ã€æ±ç”¨ãƒ¬ã‚¸ã‚¹ã‚¿ã¯ã™ã¹ã¦ç ´å£Šã•ã‚Œã‚‹
	#else
		work->keyjmp = (int)KeyIntDrv_Normal;
		asmout("CALL FAR DWORD[DS:01b0h]");
		// ESIã‚‚å«ã‚ã€æ±ç”¨ãƒ¬ã‚¸ã‚¹ã‚¿ã¯ã™ã¹ã¦ç ´å£Šã•ã‚Œã‚‹
	#endif
		POPAD();
	}
	goto fin;
}
#endif

void near KeyIntDrv_7Ebyte()
{
	asmout("#fin EQU KeyIntDrv_Ret");
	asmout("#sendkeycode_AL EQU KeyIntDrv_send_keycode_AL");
	unsigned int keycode == EAX;
	TEST(AH, AH);
	if ((signed) < 0)
		goto fin; // ç¬¬ä¸€ãƒã‚¤ãƒˆ
	// ç¬¬äºŒãƒã‚¤ãƒˆ
	AL = AH;
	/* work->keyjmp = KeyIntDrv_Normal; */ asmout("MOV DWORD PTR DS:[0188h],OFFSET KeyIntDrv_Normal");
	AL |= 0x80;

#if 0
if (AL == 0x5d /* SYSREQ */) { // !!!
	// +00 : EAX
	// +04 : DS
	// +08 : EIP
	// +12 : CS
	// +16 : ELFAGS
	EAX = (int) [SS:ESP +  8];
	ECX = (int) [SS:ESP + 12];
	INT(0x03);
}
#endif

	goto sendkeycode_AL;
}


void near KeyboardQueueExecute()
/*	ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ãƒã‚¤ã‚¯ãƒ­ã‚³ãƒãƒ³ãƒ‰ã‚­ãƒ¥ãƒ¼ã‚¤ãƒ³ã‚°

	ã‚‚ã£ã¨å¤šæ©Ÿèƒ½ã«ã™ã‚‹ã€‚æŒ‡å®šãƒã‚¤ãƒˆã‚’å¾…ã¤ã€ACK/NACKè»¢é€ã™ã‚‹ã€å˜ç´”è»¢é€ã™ã‚‹ã€ãŒé¸ã¹ã‚‹ã€‚
		4ãƒã‚¤ãƒˆã®ã‚¸ãƒ£ãƒ³ãƒ—ãƒ™ã‚¯ã‚¿ã‚’ã‚³ãƒãƒ³ãƒ‰ã«ã™ã‚‹ã€‚
		ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã‚‚4ãƒã‚¤ãƒˆã‚¢ãƒ©ã‚¤ãƒ³ã€‚
		ã¾ãŸã€ã‚³ãƒãƒ³ãƒ‰ã«ã‚ˆã‚‹ã‚³ãƒãƒ³ãƒ‰ã‚­ãƒ¥ãƒ¼ã®å…ˆé ­ç§»å‹•ã‚‚ã‚„ã‚‹ã€‚

		ãƒãƒ¼ãƒãƒ«ãƒ¢ãƒ¼ãƒ‰ã«ç§»è¡Œ	00    <
		å˜ç´”è»¢é€		01 xx
		æŒ‡å®šãƒã‚¤ãƒˆå—ä¿¡å¾…ã¡	02 xx < å—ä¿¡ã—ãŸã„ãƒã‚¤ãƒˆæ•°ã‚’æ›¸ã
		ç‰¹å®šãƒ‡ãƒ¼ã‚¿ãƒ¼å—ä¿¡å¾…ã¡	03 xx < ...ã‚¨ãƒ©ãƒ¼ã®æ™‚ã¯ã€0x00000001ã‚’è¿”ã™ã€‚
		ACKè»¢é€			04 xx < ...ã‚¨ãƒ©ãƒ¼ã®æ™‚ã¯ã€0x00000002ã‚’è¿”ã™ã€‚
		å—ä¿¡ãƒ‡ãƒ¼ã‚¿ãƒ¼æ¨ã¦ã‚‹	05    < ãƒã‚¤ãƒˆæ•°ä¸æ˜ã®å ´åˆ
		å—ä¿¡ãƒã‚¤ãƒ³ã‚¿åˆæœŸåŒ–	06
		æ­£å¸¸çµ‚äº†ã‚·ã‚°ãƒŠãƒ«ç™ºç”Ÿ	07	... æ­£å¸¸çµ‚äº†ãªã®ã§ã€0ã‚’è¿”ã™ã€‚
		
		ã‚·ã‚°ãƒŠãƒ«ãƒ˜ãƒƒãƒ€è¨­å®š	80 (align 4) dw,wd,wd
		ã‚·ã‚°ãƒŠãƒ«æ‹¡å¼µè¨­å®š	81 (align 4) dw,wd,wd
				(æœ€åˆã®6bytesã¯ãƒã‚¤ãƒ³ã‚¿ã€‚æœ€å¾Œã®wdã¯è»¢é€dwæ•°)
		ã‚·ã‚°ãƒŠãƒ«ãƒ™ã‚¯ã‚¿è¨­å®š	82 (align 4) dw,wd,wd
				(æœ€åˆã®6bytesã¯ãƒã‚¤ãƒ³ã‚¿ã€‚æœ€å¾Œã®wdã¯ãƒ€ãƒŸãƒ¼)
		å—ä¿¡ãƒ‡ãƒ¼ã‚¿ãƒ¼ã‚³ãƒ”ãƒ¼	83 (align 4) dw,wd,wd
				(æœ€åˆã®6bytesã¯ãƒã‚¤ãƒ³ã‚¿ã€‚æœ€å¾Œã®wdã¯è»¢é€å¯èƒ½dwæ•°)
				ãªãŠã€è»¢é€ã•ã‚Œã‚‹æœ€åˆã®dwã¯ã€ãƒãƒƒãƒ•ã‚¡ä½¿ç”¨é‡ã€‚

	æ›¸ãè¾¼ã¿å³å€¤ã¯ã‚„ã‚ã‚‹ã€‚æ›¸ãè¾¼ã¿å…ˆã¯ã€å—ä¿¡ãƒãƒƒãƒ•ã‚¡ã€‚

	ã“ã®è¡¨ã®ä¸­ã®00ï½83ã¯ã€FS:EBXã«æ›¸ãã‚³ãƒãƒ³ãƒ‰ã¨ã¯ç„¡é–¢ä¿‚

	ã“ã®æ©Ÿèƒ½(02)ã®ãŠã‹ã’ã§ã€è¤‡æ•°ãƒã‚¤ãƒˆã®å¾…ã¡ãŒè¨˜è¿°ã§ãã‚‹
	ä¸€èˆ¬çš„ã«ã¯ã€ã‚¨ãƒ©ãƒ¼ã‚·ã‚°ãƒŠãƒ«ã¯ã€ä¸Šä½ã®ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ãƒ‰ãƒ©ã‚¤ãƒãƒ¼ã«æ¥ç¶šã™ã‚‹ã€‚
	ä¸€èˆ¬ã®ã‚¢ãƒ—ãƒªã«è¨­å®šã™ã¹ãã§ã¯ãªã„ã€‚

	ã©ã†ã‚„ã£ã¦ã€æˆ»ã‚‹ã‹ã€‚jmpã«ã—ãŸã„ã‘ã©ã€ãã†ã‚‚è¡Œã‹ãªã„ã€‚
	nretã¨ã„ã†ã®ã‚‚ã„ã¾ã„ã¡ã ã€‚ãƒ»ãƒ»ãƒ»nretã«ã—ã‚ˆã†ã€‚
	ã‚­ãƒ¥ãƒ¼ã®é€”ä¸­ã§ã¯ã®KeyWorkJmpã¯ã€å¤‰åŒ–ã—ãªã„ã€‚ãƒ»ãƒ»ãƒ»ã ã‹ã‚‰ã€ãƒ©ãƒ³ãƒ‹ãƒ³ã‚°ãƒ•ãƒ©ã‚°ã¨ã—ã¦ä½¿ãˆã‚‹ã€‚

	fs:ebxã«è»¢é€ã—ãŸã„ãƒ‡ãƒ¼ã‚¿ãƒ¼ã‚’ç©ã‚“ã§ç½®ã„ã¦ã€ã‚³ãƒ¼ãƒ«ã™ã‚‹ã ã‘ã€‚ã‚ã¨ã¯è²¬ä»»æŒã£ã¦ã‚­ãƒ¥ãƒ¼ã«é€ã£ã¦ãã‚Œã‚‹ã€‚
		ï¼ˆå½¢å¼ã¯ã€dwæ•°ã€ãƒ‡ãƒ¼ã‚¿ãƒ¼ã€ãƒ»ãƒ»ãƒ»ï¼‰
	ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆç”¨ã®ã‚¿ã‚¤ãƒãƒ¼ãŒã‚ã‚‹ã¨ã„ã„ã€‚ãƒãƒ¼ãƒ‰ã¯ä¸€ã¤ã§ååˆ†ã€‚

	æ±ç”¨ãƒ¬ã‚¸ã‚¹ã‚¿ã¯ã™ã¹ã¦ç ´å£Šã•ã‚Œã‚‹
*/
{
	keyboarddata *work == DS:0;
	SS0_struct *ss0 == /* SS:(- sizeof (SS0_struct)) */ SS:0xffffffc0;
	asmout("#KeyIntDrv_Ret EQU KeyIntDrv_Ret");

	PUSHFD();
	CLI();
	unsigned int *wp == DS:ESI, free == EDX, *commands == FS:EBX;
	(offset) wp = work->queue_write_ptr;
	free = work->queue_free_dw;
	unsigned int cmds_length == ECX;
	cmds_length = *commands;
	(offset) commands += 4;
	do {
		free -= cmds_length;
		/* (false) */ if ((unsigned) < 0) { // çµ‚äº†ã‚³ãƒãƒ³ãƒ‰ã®åˆ†ã¯ã€ã‚ã‚‰ã‹ã˜ã‚å¼•ã„ã¦ã‚ã‚‹ã®ã§ã€ç­‰ã—ãã¦ã‚‚ã„ã„
			// å…¨ã¦ã‚’å¾¡ç ´ç®—ã«ã™ã‚‹
buf_full_err:
			(offset) wp = work->queue_write_ptr;
			/* *wp = quecmd_tonormal */ asmout("MOV DWORD PTR DS:[ESI],OFFSET #quecmd_tonormal");
				// ã“ã®ã‚³ãƒãƒ³ãƒ‰ã‚’å—ç†ã—ãŸã‚‰ã€queue_write_ptrã‚’åˆæœŸåŒ–ã™ã‚‹
			POPFD();
			STC();
			return;
		}
		/* EAX = (offset) wp + cmds_length * 4 */ asmout("LEA EAX,[ESI+ECX*4]");
		/* (false) */ if ((unsigned) EAX >= /* (offset) work->queue_buf + sizeof (work->queue_buf) */ 0x100) {
			// ç­‰ã—ãã¦ã‚‚ãƒ€ãƒ¡ãªã®ã¯ã€ãƒ˜ãƒƒãƒ‰ã¸æˆ»ã™ã‚³ãƒãƒ³ãƒ‰ãŒä½¿ãˆãªã„ã‹ã‚‰
			// free -= (work->queue_buf + sizeof (work->queue_buf) - (offset) wp) / 4;
			// free += (- work->queue_buf - sizeof (work->queue_buf) + (offset) wp) / 4;
			/* EAX = (offset) wp - ((offset) work->queue_buf + sizeof (work->queue)); */
			asmout("LEA EAX,[ESI-0100H]");
			/* *wp = (offset) quecmd_restore */ asmout("MOV DWORD PTR DS:[ESI],OFFSET #quecmd_restore");
			EAX /= 4;
			free += EAX; // ã‚‚ã—ã€ã“ã‚Œã§freeãŒ0ã‚‚ã—ãã¯è² ã«ãªã£ãŸã‚‰ã€ã‚„ã¯ã‚Šè¶³ã‚Šãªã„ã“ã¨ã«ãªã‚‹
			if ((signed) < 0)
				goto buf_full_err;
			(offset) wp = /* work->queue_buf */ 0x080;
		}
		do {
			EAX = *commands;
			(offset) commands += 4;
			*wp = EAX;
			(offset) wp += 4;
			cmds_length--;
		} while (!= 0);
		cmds_length = *commands;
		(offset) commands += 4;
	} while (cmds_length > 0);
	/* EAX = (offset) KeyQueIntDrv */ asmout("MOV EAX,OFFSET #KeyQueIntDrv");
	/* *wp = quecmd_tonormal */ asmout("MOV DWORD PTR DS:[ESI],OFFSET #quecmd_tonormal");
	work->queue_write_ptr = (offset) wp;
	work->queue_free_dw = free;
	/* (false) */ if (EAX == work->keyjmp) {
		POPFD();
		CLC();
		return;
	}
	work->keyjmp = EAX;
	ss0->cli_count++;
	EBX = /* work->queue_exec_ptr */ /* (offset) work->queue_buf */ 0x80;
	EBP = free;
	/* [(void near *) DS:EBX](); */ asmout("CALL DWORD PTR DS:[080H]");
	work->queue_exec_ptr = EBX;
	work->queue_free_dw = EBP;
	ss0->cli_count--;
	if (!= 0) {
		POPFD();
		CLC();
		return;
	}
	PUSH(DS);
	/* (ss0->cli_call)() */ asmout("CALL FAR DWORD SS:[0FFFFFFC0H+038H]");
	POP(DS);
	POPFD();
	CLC();
	return;

//	ALIGN(16);
KeyQueIntDrv:
	PUSHAD();
	EBX = work->queue_exec_ptr;
	EBP = work->queue_free_dw;
	/* ((void near *) work->exec_wait_int)(); */ asmout("CALL DWORD PTR DS:[019CH]");
	work->queue_exec_ptr = EBX;
	work->queue_free_dw = EBP;
	POPAD();
	goto KeyIntDrv_Ret;

/*
	å…¥åŠ›ãƒ‡ãƒ¼ã‚¿ãƒ¼å¾…ã¡ãªã‚‰ã€exec_wait_intã‚’ã‚»ãƒƒãƒˆã™ã‚‹ã“ã¨
	ã‚¿ã‚¤ãƒãƒ¼ãªã©ã‚’å¾…ã¤å ´åˆã¯ã€ã“ã®é™ã‚Šã§ã¯ãªã„ã€‚
	ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆç”¨ã‚¿ã‚¤ãƒãƒ¼ã‚’ä½¿ã†ãªã‚‰ã€ä½¿ç”¨å¾Œã¯ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚ŒãŸçŠ¶æ…‹ã«ã—ã¦ãŠãã“ã¨ã€‚
	ãƒ»ãƒ»ãƒ»ã£ã¦ã“ã¨ã¯ã€ã‚­ãƒ£ãƒ³ã‚»ãƒ«ãƒã‚¤ã‚¯ãƒ­ã‚³ãƒ¼ãƒ‰ã‚’ä½¿ã†ã¨ã„ã†ã“ã¨ã€‚
	ï¼ˆã‚¿ã‚¤ãƒãƒ¼ä½¿ç”¨ã‚³ãƒãƒ³ãƒ‰ã¯ã€ç¾åœ¨ã‹ã‚‰ã®æ™‚é–“ã‚’æ›¸ã‘ã°ã„ã„ï¼‰

*/

quecmd_tonormal:
	/* work->keyjmp = KeyIntDrv_Normal; */ asmout("MOV DWORD PTR DS:[0188h],OFFSET KeyIntDrv_Normal");
	work->queue_write_ptr = /* (offset) work->queue_buf */ 0x80;
	EBP = /* sizeof (work->queue_buf) */ 128 / 4 - 1 /* qurcmd_tonormalã®åˆ† */;
	EBX = /* (offset) work->queue_buf */ 0x80;
	/* (near) */ return;

quecmd_restore:
	// EBP += (work->queue_buf + sizeof (work->queue) - EBX) / 4
	//     -= (EBX - (work->queue_buf + sizeof (work->queue)) / 4
	asmout("LEA EAX,[EBX-0100H]");
	/* EBX = work->queue_buf */ asmout("MOV EBX,work_queue_buf");
	/* (signed int) */ EAX /= 4;
	EBP -= EAX;
	/* goto [(void near *) work->queue_buf] */ asmout("JMP DWORD PTR DS:[0080H]");
}

void near KeyQueCmd_SendData()
// å˜ç´”é€ä¿¡
{
	AL = [DS:EBX+4];
	EBX += 8;
	EBP += 2;
	OUT(0x60, AL);
	/* goto [(void near *) DS:EBX] */ asmout("JMP DWORD PTR DS:[EBX]");
}

void near KeyQueCmd_AckSendData()
// ACKåˆ¶å¾¡ä»˜ãé€ä¿¡
{
	/* work->exec_wait_int = intack; */ asmout("MOV DWORD PTR DS:[019CH],OFFSET #intack");
retry:
	AL = [DS:EBX + 4];
	OUT(0x60, AL);
	return; // EBXã¨EBPã¯ãã®ã¾ã¾ã«ã—ã¦ãŠãï¼ˆå®Ÿè¡Œä¸­ã®å‘½ä»¤ãŒã‚ã‹ã‚‰ãªããªã‚‹ã‹ã‚‰ï¼‰

intack:
	if (AL == 0xfa /* ACK */) {
		EBX += 8;
		EBP += 2;
		/* goto [(void near *) DS:EBX] */ asmout("JMP DWORD PTR DS:[EBX]");
	}
	if (AL == 0xfe /* NACK */)
		goto retry;

	// ä»¥ä¸‹ã¯SOLO2150å¯¾ç­–
	EBX += 8;
	EBP += 2;
	asmout("CMP DWORD PTR DS:[EBX],OFFSET KeyQueCmd_RecieveCheck");
	if (==) {
		if (AL == [DS:EBX+4]) {
			EBX += 8;
			EBP += 2;
			/* goto [(void near *) DS:EBX] */ asmout("JMP DWORD PTR DS:[EBX]");
		}
	}

	EBX -= 8;
	EBP -= 2;
	INT(0x03); // ã‚¨ãƒ©ãƒ¼ã‚·ã‚°ãƒŠãƒ«ã‚’ç™ºç”Ÿã•ã›ã‚‹
}

/*

KeyQueCmd_RecieveBytes	proc	near	; nãƒã‚¤ãƒˆå—ä¿¡

			mov	dword ptr ds:[KeyWorkQueIP],offset #intres
			mov	dword ptr ds:[KeyWorkQuePtr],ebx
			mov	dword ptr ds:[KeyWorkQueFreDw],ebp
			ret
#intres:
			mov	esi,dword ptr ds:[KeyWorkBufPtr]
			mov	 byte ptr ds:[esi], al
			inc	esi
			mov	dword ptr ds:[KeyWorkBufPtr],esi
			dec	dword ptr ds:[ebx][4]
			jz	short #fin
			ret
#fin:
			add	ebx,8
			add	ebp,2
			jmp	dword ptr ds:[ebx]

KeyQueCmd_RecieveBytes	endp

*/

void near KeyQueCmd_RecieveCheck()
// 1ãƒã‚¤ãƒˆå—ä¿¡ï¼†ãƒã‚§ãƒƒã‚¯
{
	/* work->exec_wait_int = intres; */ asmout("MOV DWORD PTR DS:[019CH],OFFSET #intres");
	return; // EBXã¨EBPã¯ãã®ã¾ã¾ã«ã—ã¦ãŠãï¼ˆå®Ÿè¡Œä¸­ã®å‘½ä»¤ãŒã‚ã‹ã‚‰ãªããªã‚‹ã‹ã‚‰ï¼‰

intres:
	if (AL == [DS:EBX+4]) {
		EBX += 8;
		EBP += 2;
		/* goto [(void near *) DS:EBX] */ asmout("JMP DWORD PTR DS:[EBX]");
	}
	INT(0x03); // æœ¬æ¥ãªã‚‰ã“ã“ã§ã‚¨ãƒ©ãƒ¼ã‚·ã‚°ãƒŠãƒ«
}

void near KeyQueCmd_WriteCmdReg()
// ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ã‚¤ã‚¹ã¸é€ä¿¡
{
	AL = [DS:EBX + 4];
	EBX += 8;
	EBP += 2;
	OUT(0x64, AL);
	/* goto [(void near *) DS:EBX] */ asmout("JMP DWORD PTR DS:[EBX]");
}

/*

KeyQueCmd_SetBufPtr	proc	near

			mov	eax,dword ptr ds:[ebx][4]
			add	ebx,8
			add	ebp,2
			mov	dword ptr ds:[KeyWorkBufPtr],eax
			jmp	dword ptr ds:[ebx]

KeyQueCmd_SetBufPtr	endp

KeyQueCmd_SetTimer	proc	near

#exec			equ	TimerConstNodeExec
#time			equ	TimerConstNodeTime

			push	 es
			push	 fs
			pushad
			mov	 ax, ds
			mov	 fs, ax
			mov	eax,TimerWorkSel
			mov	 es, ax
			mov	ebx,KeyWorkTimerCmd2	; æ™‚åˆ»å–å¾—
			fcall	TimerSel,TimerSysCmd	; ã‚·ã‚¹ãƒ†ãƒ ã‚³ãƒ¼ãƒ«

;	æœ¬æ¥ã¯ã€ã“ã“ã§ã‚¨ãƒ©ãƒ¼ãƒã‚§ãƒƒã‚¯ã™ã¹ã—

			mov	ebx,dword ptr ss:[esp][16]	; ebxå¾©å¸°
			mov	edi,dword ptr ds:[KeyWorkTimerCmd1][04]	; node
			mov	eax,dword ptr ds:[KeyWorkTimerCmd2][04]
			mov	edx,dword ptr ds:[KeyWorkTimerCmd2][08]
			add	eax,dword ptr ds:[ebx][04]
			mov	ecx,dword ptr ds:[KeyWorkTimerCmd2][12]
			adc	edx,dword ptr ds:[ebx][08]
			mov	dword ptr es:[edi][#time][0],eax
			adc	ecx,dword ptr ds:[ebx][12]
			mov	eax,dword ptr ds:[ebx][16]
			add	ebx,20
			mov	dword ptr es:[edi][#time][4],edx
			mov	dword ptr es:[edi][#time][8],ecx
			mov	dword ptr es:[edi][#exec][0],eax
			mov	 word ptr es:[edi][#exec][4], cs
			mov	dword ptr ss:[esp][16],ebx
			mov	ebx,KeyWorkTimerCmd1
			mov	dword ptr ds:[KeyWorkTimerCmd1],04*4	; set timer
			fcall	TimerSel,TimerSysCmd	; ã‚·ã‚¹ãƒ†ãƒ ã‚³ãƒ¼ãƒ«

;	æœ¬æ¥ã¯ã€ã“ã“ã§ã‚¨ãƒ©ãƒ¼ãƒã‚§ãƒƒã‚¯ã™ã¹ã—

			popad
			pop	 fs
			pop	 es
			add	ebp,5
			jmp	dword ptr ds:[ebx]

KeyQueCmd_SetTimer	endp

KeyQueCmd_CancelTimer	proc	near

			push	 fs
			pushad
			mov	 ax, cs
			add	 ax,8
			mov	 fs, ax
			mov	ebx,KeyWorkTimerCmd1	; å‰²ã‚Šè¾¼ã¿å–ã‚Šæ¶ˆã—
			mov	dword ptr ds:[KeyWorkTimerCmd1],05*4	; cancel timer
			fcall	TimerSel,TimerSysCmd	; ã‚·ã‚¹ãƒ†ãƒ ã‚³ãƒ¼ãƒ«

;	æœ¬æ¥ã¯ã€ã“ã“ã§ã‚¨ãƒ©ãƒ¼ãƒã‚§ãƒƒã‚¯ã™ã¹ã—

			popad
			add	ebx,4
			inc	ebp
			pop	 fs
			jmp	dword ptr ds:[ebx]

KeyQueCmd_CancelTimer	endp

*/

void near KeyQueCmd_WaitBufEnpty()
// å‡ºåŠ›ãƒãƒƒãƒ•ã‚¡ãŒç©ºãã®ã‚’å¾…ã¤
{
	EBX += 4;
	EBP++;
	do {
		IN(AL, 0x64);
		TEST(AL, 0x02);
	} while (!= 0);
	/* goto [(void near *) DS:EBX] */ asmout("JMP DWORD PTR DS:[EBX]");
}

void near KeyQueCmd_CancelErrSignal()
{
	EBX += 4;
	EBP++;
	/* work->keyerr_signal[0] = (offset) dummy_fret */ asmout("MOV DWORD PTR DS:[work_keyerr_signal+0],OFFSET dummy_fret");
	/* work->keyerr_signal[4] = CS */ asmout("MOV WORD PTR DS:[work_keyerr_signal+4],CS");
	/* goto [(void near *) DS:EBX] */ asmout("JMP DWORD PTR DS:[EBX]");
}

void near KeyQueCmd_SetErrSignal()
{
	EAX = [DS:EBX +  4];
	ECX = [DS:EBX +  8];
	/* work->keyerr_signal[0] = EAX */ asmout("MOV DWORD PTR DS:[work_keyerr_signal+0],EAX");
	/* work->keyerr_signal[4] = ECX */ asmout("MOV DWORD PTR DS:[work_keyerr_signal+4],ECX");
	EAX = [DS:EBX + 12];
	ECX = [DS:EBX + 16];
	EBX += 20;
	EBP += 5;
	/* work->err_send_buf[0] = EAX */ asmout("MOV DWORD PTR DS:[work_err_send_buf+0],EAX");
	/* work->err_send_buf[4] = ECX */ asmout("MOV DWORD PTR DS:[work_err_send_buf+4],ECX");
	/* goto [(void near *) DS:EBX] */ asmout("JMP DWORD PTR DS:[EBX]");
}

void near KeyQueCmd_MakeFinishSignal()
{
	PUSH(EBX);
	PUSH(EBP);
	/* work->err_send_buf[8] = 0 */ asmout("MOV DWORD PTR DS:[work_err_send_buf+8],0");
	/* ESI = work->err_send_buf */ asmout("MOV ESI,work_err_send_buf");
	asmout("CALL FAR DWORD DS:[work_keyerr_signal]");
	POP(EBP);
	POP(EBX);
	EBX += 4;
	EBP++;
	/* goto [(void near *) DS:EBX] */ asmout("JMP DWORD PTR DS:[EBX]");
}

#if 0

void far MouseIntDrv()
// ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã¨ã‚ˆãä¼¼ãŸæ§‹æˆ
{
	SS0_struct *ss0 == /* SS:(- sizeof (SS0_struct)) */ SS:0xffffffc0;

	PUSH(DS);
	PUSH(EAX);
	MOV(EAX, CS); EAX += 8; DS = AX; // ç‰¹å®šã®DSã«ä¾å­˜ã—ãªã„ãŸã‚ã®æ‰‹ç¶šã
	ss0->ring0_count++; // å‰²ã‚Šè¾¼ã¿ãƒ«ãƒ¼ãƒãƒ³ã®åŸºæœ¬
	ss0->cli_count++;
}

void near MouseIntDrv2()
{
	// å…ˆã«å‰²ã‚Šè¾¼ã¿ã‚’çµ‚äº†ã•ã›ã¦ã—ã¾ã†(2001/02/18 ãƒ‡ãƒ¼ã‚¿ãƒ¼ã‚’å–ã‚Šã“ã¼ã™ã‚¨ãƒ©ãƒ¼ãŒã‚ã£ãŸãŸã‚)ã€‚
	// ä¿¡å·ã®ç«‹ã¡ä¸ŠãŒã‚ŠãŒå‰²ã‚Šè¾¼ã¿ã‚’èµ·ã“ã™ã‹ã‚‰ã€å®³ã¯ãªã„ã ã‚ã†ã€‚
	AL = 0x64 /* IRQ-12ã‚’çµ‚äº† */;
	OUT(0xa0, AL);
	// ã“ã“ã§ISRã‚’èª­ã‚“ã§IRQ-02ã‚’çµ‚äº†ã™ã¹ãã‹åˆ¤æ–­ã—ãªã‘ã‚Œã°ã„ã‘ãªã„ã€ã‹ã‚‚ã—ã‚Œãªã„
	// ç¾ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã§ã¯ã€ã‚¹ãƒ¬ãƒ¼ãƒ–ã®å‰²ã‚Šè¾¼ã¿ã¯ï¼‘ã¤ã—ã‹å—ã‘ä»˜ã‘ãªã„
	AL = 0x62 /* IRQ-02ã‚’çµ‚äº† */;
	OUT(0x20, AL);

	keyboarddata *work == DS:0;
	IN(AL, 0x60);
	asmout("JMP DWORD PTR DS:[work_mousejmp]"); // goto work->mousejmp;
}

// 1ãƒã‚¤ãƒˆãšã¤å—ä¿¡ã—ã€3ãƒã‚¤ãƒˆé›†ã¾ã£ãŸã‚‰ã€ã‚·ã‚°ãƒŠãƒ«ã‚’å‡ºã™

void near MouseIntDrv_Phase0()
{
	keyboarddata *work == DS:0;
	AH = AL;
	/* work->mouse_send_buf[12] */ [work + 0x1cc] = AL;
	AL &= 0xc8;
	/* (false) */ if (AL != 0x08) { // ç¬¬1ãƒã‚¤ãƒˆã¨ã—ã¦ãµã•ã‚ã—ããªã„
		if (AH == 0xaa) { // hot-plug?
			// ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆãƒã‚§ãƒƒã‚¯ã®ãŸã‚ã«ã‚¿ã‚¤ãƒãƒ¼ã‚’ä»•æ›ã‘ã‚‹
			/* work->mousejmp = (offset) MouseIntDrv_Phase3 */ asmout("MOV DWORD PTR DS:[work_mousejmp], OFFSET MouseIntDrv_Phase3");
			/* goto MouseIntDrv_Ret */ asmout("JMP MouseIntDrv_);
	/* goto [(void near *) DS:EBX] */ asmout("JMP DWORD PTR DS:[EBX]");
}

void near KeyQueCmd_SetErrSignal()
{
	EAX = [DS:EBX +  4];
	ECX = [DS:EBX +  8];
	/* work->keyerr_signal[0] = EAX */ asmout("MOV DWORD PTR DS:[work_keyerr_signal+0],EAX");
	/* work->keyerr_signal[4] = ECX */ asmout("MOV DWORD PTR DS:[work_keyerr_signal+4],ECX");
	EAX = [DS:EBX + 12];
	ECX = [DS:EBX + 16];
	EBX += 20;
	EBP += 5;
	/* work->err_send_buf[0] = EAX */ asmout("MOV DWORD PTR DS:[work_err_send_buf+0],EAX");
	/* work->err_send_buf[4] = ECX */ asmout("MOV DWORD PTR DS:[work_err_send_buf+4],ECX");
	/* goto [(void near *) DS:EBX] */ asmout("JMP DWORD PTR DS:[EBX]");
}

void near KeyQueCmd_MakeFinishSignal()
{
	PUSH(EBX);
	PUSH(EBP);
	/* work->err_send_buf[8] = 0 */ asmout("MOV DWORD PTR DS:[work_err_send_buf+8],0");
	/* ESI = work->err_send_buf */ asmout("MOV ESI,work_err_send_buf");
	asmout("CALL FAR DWORD DS:[work_keyerr_signal]");
	POP(EBP);
	POP(EBX);
	EBX += 4;
	EBP++;
	/* goto [(void near *) DS:EBX] */ asmout("JMP DWORD PTR DS:[EBX]");
}

#if 0

void far MouseIntDrv()
// ç¹§ï½­ç¹ï½¼ç¹æ‡Š* (false) */ if ((unsigned) EAX >= /* (offset) work->mouse_queue_buf + sizeof (work->mouse_queue_buf) */ 0x180) {
			// “™‚µ‚­‚Ä‚àƒ_ƒ‚È‚Ì‚ÍAƒwƒbƒh‚Ö–ß‚·ƒRƒ}ƒ“ƒh‚ªg‚¦‚È‚¢‚©‚ç
			// free -= (work->mouse_queue_buf + sizeof (work->mouse_queue_buf) - (offset) wp) / 4;
			// free += (- work->mouse_queue_buf - sizeof (work->mouse_queue_buf) + (offset) wp) / 4;
			/* EAX = (offset) wp - ((offset) work->mouse_queue_buf + sizeof (work->mouse_queue_buf)); */
			asmout("LEA EAX,[ESI-0180H]");
			/* *wp = (offset) mouse_quecmd_restore */ asmout("MOV DWORD PTR DS:[ESI],OFFSET #mouse_quecmd_restore");
			EAX /= 4;
			free += EAX; // ‚à‚µA‚±‚ê‚Åfree‚ª0‚à‚µ‚­‚Í•‰‚É‚È‚Á‚½‚çA‚â‚Í‚è‘«‚è‚È‚¢‚±‚Æ‚É‚È‚é
			if ((signed) < 0)
				goto buf_full_err;
			(offset) wp = /* work->mouse_queue_buf */ 0x100;
		}
		do {
			EAX = *commands;
			(offset) commands += 4;
			*wp = EAX;
			(offset) wp += 4;
			cmds_length--;
		} while (!= 0);
		cmds_length = *commands;
		(offset) commands += 4;
	} while (cmds_length > 0);
	/* EAX = (offset) MouseQueIntDrv */ asmout("MOV EAX,OFFSET #MouseQueIntDrv");
	/* *wp = mouse_quecmd_tonormal */ asmout("MOV DWORD PTR DS:[ESI],OFFSET #mouse_quecmd_tonormal");
	work->mouse_queue_write_ptr = (offset) wp;
	work->mouse_queue_free_dw = free;
	/* (false) */ if (EAX == work->mousejmp) {
		POPFD();
		CLC();
		return;
	}
	work->mousejmp = EAX;
	ss0->cli_count++;
	EBX = /* work->mouse_queue_exec_ptr */ /* (offset) work->mouse_queue_buf */ 0x100;
	EBP = free;
	/* [(void near *) DS:EBX](); */ asmout("CALL DWORD PTR DS:[100H]");
	work->mouse_queue_exec_ptr = EBX;
	work->mouse_queue_free_dw = EBP;
	ss0->cli_count--;
	if (!= 0) {
		POPFD();
		CLC();
		return;
	}
	PUSH(DS);
	/* (ss0->cli_call)() */ asmout("CALL FAR DWORD SS:[0FFFFFFC0H+038H]");
	POP(DS);
	POPFD();
	CLC();
	return;

//	ALIGN(16);
MouseQueIntDrv:
	PUSHAD();
	EBX = work->mouse_queue_exec_ptr;
	EBP = work->mouse_queue_free_dw;
	/* ((void near *) work->mouse_exec_wait_int)(); */ asmout("CALL DWORD PTR DS:[work_mouse_exec_wait_int]");
	work->mouse_queue_exec_ptr = EBX;
	work->mouse_queue_free_dw = EBP;
	POPAD();
	goto MouseIntDrv_Ret;


mouse_quecmd_tonormal:
	/* work->mousejmp = MouseIntDrv_Phase0; */ asmout("MOV DWORD PTR DS:[018CH],OFFSET MouseIntDrv_Phase0");
	work->mouse_queue_write_ptr = /* (offset) work->mouse_queue_buf */ 0x100;
	EBP = /* sizeof (work->mouse_queue_buf) */ 128 / 4 - 1 /* mouse_quecmd_tonormal‚Ì•ª */;
	EBX = /* (offset) work->mouse_queue_buf */ 0x100;
	/* (near) */ return;

mouse_quecmd_restore:
	// EBP += (work->mouse_queue_buf + sizeof (work->mouse_queue) - EBX) / 4
	//     -= (EBX - (work->mouse_queue_buf + sizeof (work->mouse_queue)) / 4
	asmout("LEA EAX,[EBX-0180H]");
	/* EBX = work->mouse_queue_buf */ asmout("MOV EBX,work_mouse_queue_buf");
	/* (signed int) */ EAX /= 4;
	EBP -= EAX;
	/* goto [(void near *) work->mouse_queue_buf] */ asmout("JMP DWORD PTR DS:[0100H]");
}

void near MouQueCmd_RecieveCheck()
// 1ƒoƒCƒgóM•ƒ`ƒFƒbƒN
{
	/* work->mouse_exec_wait_int = intres; */ asmout("MOV DWORD PTR DS:[work_mouse_exec_wait_int],OFFSET #intres");
	return; // EBX‚ÆEBP‚Í‚»‚Ì‚Ü‚Ü‚É‚µ‚Ä‚¨‚­iÀs’†‚Ì–½—ß‚ª‚í‚©‚ç‚È‚­‚È‚é‚©‚çj

intres:
	if (AL == [DS:EBX+4]) {
		EBX += 8;
		EBP += 2;
		/* goto [(void near *) DS:EBX] */ asmout("JMP DWORD PTR DS:[EBX]");
	}
	INT(0x03); // –{—ˆ‚È‚ç‚±‚±‚ÅƒGƒ‰[ƒVƒOƒiƒ‹
}

void near MouQueCmd_AckSendData()
// ACK§Œä•t‚«‘—M
{
	/* work->mouse_exec_wait_int = intack; */ asmout("MOV DWORD PTR DS:[work_mouse_exec_wait_int],OFFSET #intack");
retry:
	AL = 0xd4; // to mouse prefix
	OUT(0x64, AL);
	do {
		IN(AL, 0x64);
		TEST(AL, 0x02);
	} while (!= 0);
	AL = [DS:EBX + 4];
	OUT(0x60, AL);
	return; // EBX‚ÆEBP‚Í‚»‚Ì‚Ü‚Ü‚É‚µ‚Ä‚¨‚­iÀs’†‚Ì–½—ß‚ª‚í‚©‚ç‚È‚­‚È‚é‚©‚çj

intack:
	if (AL == 0xfa /* ACK */) {
		EBX += 8;
		EBP += 2;
		/* goto [(void near *) DS:EBX] */ asmout("JMP DWORD PTR DS:[EBX]");
	}
	if (AL == 0xfe /* NACK */)
		goto retry;

	return; // ‚Ç‚¿‚ç‚Å‚à‚È‚¢ƒLƒƒƒ‰ƒNƒ^[‚ª—ˆ‚½‚çA–³‹‚µ‚ÄACK‚©NACK‚ğ‘Ò‚¿‘±‚¯‚é
}

void near MouQueCmd_ResetCommand()
// ƒ}ƒEƒXƒŠƒZƒbƒg
{
	/* work->mouse_exec_wait_int = intack; */ asmout("MOV DWORD PTR DS:[work_mouse_exec_wait_int],OFFSET #intack");
retry:
	AL = 0xd4; // to mouse prefix
	OUT(0x64, AL);
	do {
		IN(AL, 0x64);
		TEST(AL, 0x02);
	} while (!= 0);
	AL = 0xff;
	OUT(0x60, AL);
	return; // EBX‚ÆEBP‚Í‚»‚Ì‚Ü‚Ü‚É‚µ‚Ä‚¨‚­iÀs’†‚Ì–½—ß‚ª‚í‚©‚ç‚È‚­‚È‚é‚©‚çj

intack:
	if (AL == 0x00 /* ACK */) {
		EBX += 4;
		EBP++;
		/* goto [(void near *) DS:EBX] */ asmout("JMP DWORD PTR DS:[EBX]");
	}
	if (AL == 0xfe /* NACK */)
		goto retry;

	return; // ‚Ç‚¿‚ç‚Å‚à‚È‚¢ƒLƒƒƒ‰ƒNƒ^[‚ª—ˆ‚½‚çA–³‹‚µ‚Ä0x00(Š®—¹)‚©NACK‚ğ‘Ò‚¿‘±‚¯‚é
}

#endif

/*


KeyGetKeyType		proc	far	; ax:ebx > ecx

			push	 ds
			push	 fs
			pushad
			mov	 ax, cs
			mov	 fs, ax
			add	 ax,8
			mov	ebx,offset #cmdline1
			mov	 ds, ax
			mov	 byte ptr ds:[KeyGetKeyTypeWaitFlag],0
			call	near ptr KeyboardQueueExecute
			clr	eax
#loop:
			cmp	 al, byte ptr ds:[KeyGetKeyTypeWaitFlag]
			jz	short #loop
			mov	ebx,offset #cmdline2
			call	near ptr KeyboardQueueExecute
			mov	 fs, word ptr ss:[esp][28]
			mov	ebx,dword ptr ss:[esp][16]
			mov	esi,KeyWorkBuf
			mov	ecx,64/4
#copy:
			mov	eax,dword ptr ds:[esi]
			add	esi,4
			mov	dword ptr fs:[ebx],eax
			add	ebx,4
			dec	ecx
			jnz	short #copy
			mov	eax,dword ptr ds:[KeyWorkBufPtr]
			sub	eax,KeyWorkBuf
			mov	dword ptr ss:[esp][24],eax
			popad
			pop	 fs
			pop	 ds
			ret
#buf_full:
			add	ebx,4
			mov	 byte ptr ds:[KeyGetKeyTypeWaitFlag],1
			dec	ebp
			jmp	dword ptr ds:[ebx]
#timeout:
			push	 ds
			mov	 ax, cs
			add	 ax,8
			mov	 ds, ax
			mov	 byte ptr ds:[KeyGetKeyTypeWaitFlag],2
			mov	dword ptr ds:[KeyWorkQuePtr],KeyWorkQueue
			mov	dword ptr ds:[KeyWorkJmp],offset KeyIntDrv_Normal
			mov	dword ptr ds:[KeyWorkQueFreDw],KeyWorkQueSiz/4
			pop	 ds
			clc
			fret

			align	4

#cmdline1		dd	1,offset KeyQueCmd_WaitBufEnpty
			dd	2,offset KeyQueCmd_AckSendData,0f5h	; disable scanning
			dd	5,offset KeyQueCmd_SetTimer,200,0,0,offset #timeout
			dd	2,offset KeyQueCmd_SetBufPtr,KeyWorkBuf
			dd	2,offset KeyQueCmd_WriteCmdReg,0a0h
			dd	2,offset KeyQueCmd_RecieveBytes,64
			dd	1,offset KeyQueCmd_CancelTimer
			dd	1,offset #buf_full
			dd	0

#cmdline2		dd	2,offset KeyQueCmd_AckSendData,0f4h	; enable scanning
			dd	0

KeyGetKeyType		endp

KeyboardSetTypematic	proc	far	; al

			push	 ds
			push	 fs
			pushad
			sub	esp,9*4
			mov	 dx, cs
			mov	 cx, ss
			add	 dx,8
			mov	 fs, cx
			mov	 ds, dx
			mov	dword ptr ss:[esp][00],1
			mov	dword ptr ss:[esp][04],offset KeyQueCmd_WaitBufEnpty
			mov	dword ptr ss:[esp][08],2
			mov	dword ptr ss:[esp][12],offset KeyQueCmd_AckSendData
			mov	 byte ptr ss:[esp][16],0f3h
			mov	dword ptr ss:[esp][20],2
			mov	dword ptr ss:[esp][24],offset KeyQueCmd_AckSendData
			mov	 byte ptr ss:[esp][28], al
			mov	dword ptr ss:[esp][32],0
			mov	ebx,esp
			call	near ptr KeyboardQueueExecute
			add	esp,9*4
			popad
			pop	 fs
			pop	 ds
			ret

;	–{—ˆ‚È‚çAƒGƒ‰[ˆ—‚È‚Ç‚à‚·‚×‚«

KeyboardSetTypematic	endp

			align	16



KeyGetA20Mode		proc	far	; > al

			push	 ds
			push	 fs
			pushad
			mov	 ax, cs
			mov	 fs, ax
			add	 ax,8
			mov	ebx,offset #cmdline1
			mov	 ds, ax
			mov	 byte ptr ds:[KeyGetKeyTypeWaitFlag],0	; –Ê“|‚È‚Ì‚ÅA‚±‚Ì•Ï”‚ğ‹¤—L‚µ‚Ä‚¢‚é
			call	near ptr KeyboardQueueExecute
			clr	eax
#loop:
			cmp	 al, byte ptr ds:[KeyGetKeyTypeWaitFlag]
			jz	short #loop
			mov	ebx,offset #cmdline2
			call	near ptr KeyboardQueueExecute
			mov	 al, byte ptr ds:[KeyWorkBuf]
			
		;	mov	eax,dword ptr ds:[KeyWorkBufPtr]
		;	sub	eax,KeyWorkBuf

			mov	 byte ptr ss:[esp][28], al
			popad
			pop	 fs
			pop	 ds
			ret
#buf_full:
			add	ebx,4
			mov	 byte ptr ds:[KeyGetKeyTypeWaitFlag],1
			dec	ebp
			jmp	dword ptr ds:[ebx]
#timeout:
			push	 ds
			mov	 ax, cs
			add	 ax,8
			mov	 ds, ax
			mov	 byte ptr ds:[KeyGetKeyTypeWaitFlag],2
			mov	dword ptr ds:[KeyWorkQuePtr],KeyWorkQueue
			mov	dword ptr ds:[KeyWorkJmp],offset KeyIntDrv_Normal
			mov	dword ptr ds:[KeyWorkQueFreDw],KeyWorkQueSiz/4
			pop	 ds
			clc
			fret

			align	4

#cmdline1		dd	1,offset KeyQueCmd_WaitBufEnpty
			dd	2,offset KeyQueCmd_AckSendData,0f5h	; disable scanning
			dd	5,offset KeyQueCmd_SetTimer,200,0,0,offset #timeout
			dd	2,offset KeyQueCmd_SetBufPtr,KeyWorkBuf
			dd	2,offset KeyQueCmd_WriteCmdReg,0d0h
			dd	2,offset KeyQueCmd_RecieveBytes,64
			dd	1,offset KeyQueCmd_CancelTimer
			dd	1,offset #buf_full
			dd	0

#cmdline2		dd	2,offset KeyQueCmd_AckSendData,0f4h	; enable scanning
			dd	0

KeyGetA20Mode		endp

*/


