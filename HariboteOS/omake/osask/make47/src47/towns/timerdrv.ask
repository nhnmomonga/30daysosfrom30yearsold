/*	"timerdrv.ask"
	OSASK/TOWNSç”¨ã®ã‚¿ã‚¤ãƒãƒ¼ãƒ«ãƒ¼ãƒãƒ³(type-A ver.1.2)
	Copyright(C) 2003 å·åˆç§€å®Ÿ(å·åˆå ‚)		*/

/*	å¤ã„ãƒãƒƒãƒ—ã‚»ãƒƒãƒˆã«ã¯å¯¾å¿œã—ã¦ã„ãªã„ã€‚ãªãœãªã‚‰ã€é€£ç¶šã‚¢ã‚¯ã‚»ã‚¹ã®éš›ã«ã‚¦ã‚§ã‚¤ãƒˆãŒå…¥ã£ã¦ã„ãªã„ã‹ã‚‰ã€‚ */

/* mouseã®ã‚»ãƒ³ã‚¹ã«å¯¾å¿œ(PIT1) */

#include "osaskinc.ask"

segment CODE(USE32, PARA);
default(code == CODE);

#define	DEBUG		1

struct SS0_struct {
	void [32];
	char ring0_count, [3];
	/* void * */ int [4], ring0call[6], [2];
	char cli_count, [3];
	/* void * */ int [4], cli_call[6], [2];
};

struct TimerNode {
	int signalbuf[32]; /* ã‚¿ã‚¤ãƒãƒ¼ã‚·ã‚°ãƒŠãƒ«ã¯ã€æ™®é€šã‚ˆã‚Šã‚‚å°ã•ã„ */
	int call_vector[8];
	int time[12], interval;
	// int near *back, near *next;
	int back, next;
	/* ã“ã‚Œã§ã¡ã‚‡ã†ã©64bytes. */
};

struct TimerWork {
	int jmpvec; /* ä½¿ã£ã¦ã„ãªã„ï¼ˆtimer type-Bã®ãªã”ã‚Šï¼‰ */
	int longcounter; /* æ®‹ã‚Šå¾…ã¡æ™‚é–“ï¼ˆä½•å›ã®å‰²ã‚Šè¾¼ã¿ã‚’å¾…ã¤ã®ã‹ï¼‰ */
	int predict_PIT1_count /* ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ãŸã¨ãã®å€¤ */; /* ä½¿ã£ã¦ã„ãªã„ */
	char status, [3];

	// origin(0x0010)

	/* ä»¥ä¸‹å…¨ã¦ä½¿ã£ã¦ã„ãªã„ */
	unsigned int PIT1_count0 /* è¨­å®šå€¤ */;
	unsigned int PIT1_delta_100000000, PIT1_delta_10000, PIT1_delta_fffeffff /* ãã‚Œãã‚Œã€ã©ã‚Œã ã‘æ¸›ã‚‹ã‹ã‚’è¡¨ã—ãŸã‚‚ã® */;
	signed int PIT1_delta_max, PIT1_delta_min /* PIT1_count0 / 2, - PIT1_count0 / 2 */;
	int limit /* å…ˆè¡Œå®Ÿè¡Œé™ç•Œå€¤ */;

	void [20];
	void [64];

	// origin(0x0080);

	int mousevector[8], mousecount; int mousestrobe[4];
	int mousemask0, mousedefault0, mousemask1, mousedefault1;
	int mousesignalbuf[16];
	int mousebuf0[4], mousebuf1[4], mousetimernode, mousewait1[2], mousewait0[2];
	/* mouseflagãŒ0ã ã¨mousedefaultã‚’æ›´æ–°ã™ã‚‹ */
	int mousebutton0, mousebutton1, [8];
	void [48];

	// origin(0x0100)

	TimerNode head, last, timeout, freenode[3200 /* 50 * sizeof (TimerNode) */];
};

void calc_count1ms();

void far TimerSysCmd()
/* FS:EBXã‹ã‚‰ã‚³ãƒãƒ³ãƒ‰ */
{
	PUSH(DS);
	ESP -= 24;
	[SS:ESP +  0] = EAX;
	MOV(EAX, CS);
	[SS:ESP +  4] = ECX;
	EAX += 8;
	[SS:ESP +  8] = EDX;
	DS = EAX;
	EAX = [FS:EBX]; /* 4ã®å€æ•° */
	[SS:ESP + 12] = EBP;
	[SS:ESP + 16] = ESI;
	[SS:ESP + 20] = EDI;
	if (EAX != 4)
		asmout("JMP DWORD PTR DS:[TimerSC_JmpTbl+EAX]");
	asmout("JMP TimerSC_Special");
}

void far TimerInt()
{
	TimerWork *work == DS:0x0000;
	unsigned short PIC_mastar_OCW2 == 0x0000;

	PUSH(DS);
	PUSH(EAX);
	MOV(EAX, CS);
	EAX += 8;
	DS = AX;

	IN(AL, 0x0060);
	/* PIT1ã®ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‹ï¼Ÿ */
	AH = AL;
	AH &= 0x0a;
	if (AH == 0x0a) {
		PUSH(EDX);
		PUSH(ECX);
		PUSH(EAX);
		AL = 0x70; /* PIT1 #1, L/H, mode0, bin */
		OUT(0x0046, AL);
		EAX = work->mousewait1[0]; /* 13ã§42.32ãƒã‚¤ã‚¯ãƒ­ç§’ */
		OUT(0x0042, AL);
		EDX = 0x04d0;
		AL = AH;
		OUT(0x0042, AL);
		ECX = work->mousecount;
		IN(AL, DX);
		EDX += 0x02;
	//	(char) work->mousebuf0[ECX - 1] = AL;
		asmout("MOV BYTE PTR DS:[00B0H+ECX-1],AL");
		IN(AL, DX);
		EDX += 0x04;
	//	(char) work->mousebuf1[ECX - 1] = AL;
		asmout("MOV BYTE PTR DS:[00B4H+ECX-1],AL");
	//	AL = work->mousestrobe[ECX - 1];
		asmout("MOV AL,BYTE PTR DS:[008CH+ECX-1]");
		ECX--;
		OUT(DX, AL);
		work->mousecount = ECX;
		POP(EAX);
		asmout("JZ TimerMouseSignal");
		asmout("TimerInt_MouseSignal2: EQU $");
		POP(ECX);
		POP(EDX);
	//	TEST(AL, 0x01);
	//	asmout("JZ TimerInt_IRETD");
		asmout("JMP TimerInt_IRETD");
	}

	/* PIT0ã®ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚’å—ç† */
	AL >>= 2;
	AL &= 0x07;
	AL |= 0x80;
	OUT(0x0060, AL);

	/* ç¾åœ¨æ™‚åˆ»ã®ç®—å‡ºæ–¹æ³• : head.time - æ®‹ã‚Šã‚«ã‚¦ãƒ³ãƒˆ */

	/* ã•ã‚‰ã«é«˜é€ŸåŒ–ã§ãã‚‹ã€‚ãƒ»ãƒ»ãƒ»short_waitã§ã‚‚ã€ã‚ã–ã¨longcounterã‚’1ã«ã—ã¦ãŠãã€‚ */
	/* å‰²ã‚Šè¾¼ã¿ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã™ã‚‹ãƒ«ãƒ¼ãƒãƒ³ã¯ã€statusã‚’è¦‹ã‚‹ã€‚0ãªã‚‰long,1ãªã‚‰shortã€‚ */
	/* 2ãªã‚‰å‰²ã‚Šè¾¼ã¿å‡¦ç†ä¸­ã€‚ */
}

/*	åŸºæœ¬ã¯32bitãƒãƒ¼ã‚¸ãƒ§ãƒ³ã€‚ã¾ã•ã«2^32ã‚«ã‚¦ãƒ³ãƒˆã«ä¸€åº¦ã€æ™‚åˆ»è£œæ­£å‰²ã‚Šè¾¼ã¿ãŒèµ·ãã‚‹ã‹ã‚‰
	å•é¡Œã¯ãªã„ã€‚ã¡ãªã¿ã«ã€ã“ã®å‰²ã‚Šè¾¼ã¿ã¯ï¼‘æ™‚é–“ã«ï¼‘åº¦ã§ã‚ã‚‹ã€‚ã‚‚ã£ã¨ã„ã†ã£ã¨ã€
	æ™‚åˆ»è£œæ­£å‰²ã‚Šè¾¼ã¿ã¨ã¯ã€ä½•ã‚‚ã—ãªã„å‰²ã‚Šè¾¼ã¿ã®ã“ã¨ã§ã‚ã‚‹ã€‚ãƒ»ãƒ»ãƒ»ã„ã‚„ã€é•ã†ã€
	æ™‚åˆ»è£œæ­£å‰²ã‚Šè¾¼ã¿ã¯2^(32+16)ã‚«ã‚¦ãƒ³ãƒˆã«ä¸€åº¦ã§ã‚ã‚‹ã€‚ã“ã‚Œã¯ã€ï¼—å¹´ã«ä¸€åº¦ã€‚

	ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã™ã‚‹ã¨ã€ã™ãã«ç¾åœ¨æ™‚åˆ»ãŒæ›´æ–°ã•ã‚Œã€ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«ã‚‚èª¿ç¯€ã•ã‚Œã‚‹ã€‚
	ã“ã®çŠ¶æ…‹ã«ãªã‚‹ã¨ã€å…±é€šãƒ«ãƒ¼ãƒãƒ³ã«å…¥ã‚‹ï¼ˆå‰²ã‚Šè¾¼ã¿ã€éå‰²ã‚Šè¾¼ã¿ï¼‰ã€‚
*/

/*	ã“ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã§ã¯ã€å‰²ã‚Šè¾¼ã¿ã‚’ç¦æ­¢ã—ãŸã¾ã¾æ¬¡ã€…ã¨å‡¦ç†ã—ã¦ã„ããŒã€
	ãã†ã§ãªã„ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’ä½œã‚‹ã“ã¨ã‚‚å¯èƒ½ã ã‚ã†ã€‚ã—ã‹ã—ã€ã©ã¡ã‚‰ãŒå¥½ã¾ã—ã„ã‹ã¯åˆ†ã‹ã‚‰ãªã„ã€‚
*/

void near TimerRegister();

void near TimerLongcount()
{
	unsigned short PIC_mastar_OCW2 == 0x0000;
	SS0_struct *ss0 == /* SS:(- sizeof (SS0_struct)) */ SS:0xffffffc0;
	TimerWork *work == DS:0x0000;

	work->longcounter--;
	/* (true) */ if (!= 0) {
		asmout("TimerInt_IRETD: EQU $");
		AL = 0x60 /* IRQ-00ã‚’çµ‚äº† */;
		OUT(PIC_mastar_OCW2, AL);
		POP(EAX);
		POP(DS);
	//	CMP(ss0->ring0_count, 0);
	//	asmout("CMP BYTE PTR SS:[0FFFFFFE0H],0");
	//	asmout("JZ TimerRing0Call");
		IRETD();
	}
	AL = 0x60 /* IRQ-00ã‚’çµ‚äº† */;
	OUT(PIC_mastar_OCW2, AL);

	// goto TimerCountout;
}

void near TimerCountout()
/*	ã“ã“ã«æ¥ãŸã‚‰ã€CLIæœŸé–“ãŒã‹ãªã‚Šé•·ããªã‚‹ã®ã§ã€IRQ-00ã‚’maskã—ã¦
	å‰²ã‚Šè¾¼ã¿çµ‚äº†ã‚’ã‚„ã£ã¦ã—ã¾ã†æ–¹ãŒã„ã„ã‹ã‚‚ã—ã‚Œãªã„ã€‚
	ã—ã‹ã—ã€ãƒãƒ¼ãƒ‰ã‚’ç¹‹ãå¤‰ãˆã¦ã„ã‚‹ã¨ãã«ä»–ã®å‰²ã‚Šè¾¼ã¿ãŒç™ºç”Ÿã—ã€
	ãã„ã¤ãŒã‚¿ã‚¤ãƒãƒ¼ã‚’è¨­å®šã—ã‚ˆã†ã¨ã•ã‚Œã‚‹ã¨å›°ã‚‹ã€‚

	ãã®ãŸã‚ã«ã€æ¥ç¶šå¾…æ©Ÿç¾¤ã‚’ãƒã‚§ãƒ¼ãƒ³ã§ç¹‹ã„ã§ãŠãã‹ï¼Ÿ
	ãƒã‚§ãƒ¼ãƒ³ã˜ã‚ƒãªãã¦32ã‚¨ãƒ³ãƒˆãƒªãã‚‰ã„ã®ã‚¹ã‚¿ãƒƒã‚¯ãŒã‚ã‚Œã°ã„ã„ã ã‚ã†ã€‚
	ã“ã®æ¡ˆã¯çµæ§‹ã„ã„ã‹ã‚‚ã€‚

	ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚‚ã‚·ã‚°ãƒŠãƒ«ã‚’å‡ºã™ã¯ã‚ã«ãªã‚‹ã¨ã‚ã‹ã£ãŸã‚‰ã€ãã†ã—ãŸæ–¹ãŒã„ã„ã ã‚ã†ã€‚

	ã„ã‚„ã€ã‚„ã£ã±ã‚Šã‚„ã‚‰ãªãã¦ã‚‚å¹³æ°—ã‹ãªï¼Ÿãƒ»ãƒ»ãƒ»ã†ãƒ¼ã‚“ã€æ‚©ã¾ã—ã„ã€‚

	æœ€çµ‚æ¡ˆï¼šmaskã¯ã—ãªã„ã€‚ã—ãªãã¦ã„ã„ã‚ˆã†ã«ã€æœ€å¾Œã®ä¸€ç™ºã¯mode0ã§ã‚„ã‚‹ã‚ˆã†ã«ãªã£ã¦ã„ã‚‹ã€‚
	TimerNodeã‚’ä»˜ã‘æ›¿ãˆã‚‹ã¨ãã¯IF = 0ã«ãªã£ã¦ã„ã‚‹ãŒã€ãã‚ŒãŒæ¸ˆã‚ã°IF = 1ã«ãªã‚‹ã€‚

	å‰²ã‚Šè¾¼ã¿ã®ã‚­ãƒ£ãƒ³ã‚»ãƒ«ãŒã§ããªã„ãŸã‚ã€é€†ã«å¾…ã¡æ™‚é–“1ã§ã™ãã«ç¢ºå®Ÿã«å‰²ã‚Šè¾¼ã¾ã›ã‚‹ã€‚
	ã“ã®ãŸã‚ã«ã€ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆãƒã‚§ãƒƒã‚¯ãƒ«ãƒ¼ãƒãƒ³ã¯ã€ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ã§çµ„ã¿è¾¼ã‚€ */
{
	TimerWork *work == DS:0x0000;
	SS0_struct *ss0 == /* SS:(- sizeof (SS0_struct)) */ SS:0xffffffc0;

	asmout("#work_head EQU 256");
	asmout("#work_timeout EQU 384");

	asmout("#TN_call_vector EQU 32");
	asmout("#TN_back EQU 56");
	asmout("#TN_next EQU 60");

	PUSHAD();


/*	ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆç¾¤ã®å­˜åœ¨ã‚’ãƒã‚§ãƒƒã‚¯ã€‚
	work->head.intervalãŒæ­£ãªã‚‰ã€EBXã‚’åŠ ãˆã‚‹
	ãã®ã‚ã¨ã§ã€ãã®ãƒãƒ¼ãƒ‰ã‚’åˆ‡ã‚Šé›¢ã—ã€ãƒ•ãƒ©ã‚¤ãƒ³ã‚°ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆãƒ«ãƒ¼ãƒãƒ³ã¸
	work->head.intervalã¾ã§ã‚‚ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¦ã—ã¾ã£ãŸã‚‰ã€ã“ã‚Œã‚‚ãƒ•ãƒ©ã‚¤ãƒ³ã‚°ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã®æœ«å°¾ã«åŠ ãˆã‚‹ */

/*	2002.03.04 work->head.interval == 0ã§ã“ã“ã«å…¥ã£ã¦ãã‚‹ã¨æŠœã‘ã‚‰ã‚Œãªããªã‚‹ */

	TimerNode *tnode == DS:ESI, *tnext == DS:EDI, *tback == DS:EBX;

check_timeout:
	EAX = work->head.interval;
	EBX = 0; /* 0ã¾ãŸã¯è² ã®å€¤ */
	for (;;) {
		/* (false) */ if ((signed) EAX < 0) {
			/* å‰²ã‚Šè¾¼ã¿äºˆå®šæ™‚åˆ» - ç¾åœ¨æ™‚åˆ» = æ®‹ã‚Šæ™‚é–“ */
			(offset) tnode = work->head.next;
			EAX = tnode->time[0];
			ECX = tnode->time[4];
			EAX -= work->head.time[0];
			EDX = tnode->time[8];
			/* ECX -= work->head.time[4] + CF */ SBB(ECX, work->head.time[4]);
			/* EDX -= work->head.time[8] + CF */ SBB(EDX, work->head.time[8]);
		//	work->head.interval = EAX;
			ECX |= EDX;
			if (!= 0)
				goto to_invalid;
			if ((signed) EAX > 0)
				break;
	to_invalid:
		//	work->head.interval = 0x90000000;
			EAX = 0x90000000;
			break;
		}
		EAX += EBX;
		asmout("JO #to_invalid");
	//	work->head.interval = EAX;
		if ((signed) EAX > 0)
			break;
		/* ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ */
		(offset) tnode = work->head.next;
		(offset) tback = work->timeout.back;
		(offset) tnext = tnode->next;
		work->timeout.back = (offset) tnode;
		work->head.next = (offset) tnext;
		/* tnode->next = (offset) &(work->timeout) */ asmout("MOV DWORD PTR DS:[ESI+#TN_next],#work_timeout");
		tnode->back = (offset) tback;
		/* tnext->back = (offset) &(work->head) */ asmout("MOV DWORD PTR DS:[EDI+#TN_back],#work_head");
		tback->next = (offset) tnode;
		EBX = EAX;
		EAX = tnode->interval;
	/*	åˆ‡ã‚Šé›¢ã—ã¦ã€ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆãƒã‚§ãƒ¼ãƒ³ã«æ¥ç¶š
		ãã—ã¦ã€è² ã«ãªã£ãŸEAXã‚’å…ƒã«ã€EBX = - EAX;ã¨ã—ã€
		EAXã«æ–°ã—ã„work->head.intervalã‚’ãƒ­ãƒ¼ãƒ‰ã—ã¦ã€ãƒ«ãƒ¼ãƒ—ã«çªå…¥ã™ã‚‹ã€‚ */
	}

	(offset) tnode = work->timeout.next;
	work->head.interval = EAX;
	asmout("CMP ESI,#work_timeout");
	if (!=)
		goto exec3;

	if ((signed) EAX < 0)
		goto invalid_inverval;
		/*	ã“ã®æ™‚ã€0x80000000ä»¥ä¸Šã®å¾…ã¡æ™‚é–“ãŒã‚ã‚‹ã“ã¨ã‚’ä»®å®šã—ã¦ã„ã„ãƒ»ãƒ»ãƒ»long32ã‹max_wait
			max_waitã‹ã‚‰ç›´æ¥ã«32bit-intervalãƒ¢ãƒ¼ãƒ‰ã«ç§»è¡Œã™ã‚‹ã“ã¨ã¯ãªã„ã€‚ã‹ãªã‚‰ãšã€long32ã‚’çµŒç”±ã™ã‚‹
			ã“ã†ã™ã‚‹ã“ã¨ã§ã€ã‚³ãƒ¼ãƒ‰ã‚’ã‚³ãƒ³ãƒ‘ã‚¯ãƒˆã«ã§ãã‚‹ */
short_wait:

/*	EAXã ã‘å¾…ã¤ã€‚ */

	work->longcounter = EAX;
	ECX = 0;
//	TimerNode *tnode == DS:ESI;
	(offset) tnode = work->head.next;
	work->head.interval = ECX; // ECX == 0
	CMP(CL /* == 0 */, work->status);
	EDX = tnode->time[8];
	EAX = tnode->time[0];
	ECX = tnode->time[4];
	work->head.time[8] = EDX;
	work->head.time[0] = EAX;
	work->head.time[4] = ECX;
	if (!= 0)
		goto check_nesting;
	POPAD();
	POP(EAX);
	POP(DS);
//	CMP(ss0->ring0_count, 0);
//	asmout("CMP BYTE PTR SS:[0FFFFFFE0H],0");
//	asmout("JZ TimerRing0Call");
	IRETD();

check_nesting:
	work->status = 0 /* é€šå¸¸å‰²ã‚Šè¾¼ã¿å¾…æ©Ÿä¸­(ç¾åœ¨æ™‚åˆ»ã¯ç„¡åŠ¹) */;

	ss0->cli_count--; /* å‰²ã‚Šè¾¼ã¿ãƒ«ãƒ¼ãƒãƒ³ã®åŸºæœ¬ */
	if (== 0) goto call_clicall;
	POPAD();
	POP(EAX);
	POP(DS);
	ss0->ring0_count--;
	if (== 0) goto call_ring0call;
	IRETD();

call_clicall:
//	PUSHAD();
	/* (ss0->clicall)() */ asmout("CALL FAR DWORD PTR SS:[0FFFFFFC0H+038H]");
//	POPAD();
	POPAD();
	POP(EAX);
	POP(DS);
	ss0->ring0_count--;
	if (== 0) goto call_ring0call;
	IRETD();

call_ring0call:
	asmout("TimerRing0Call: EQU $");
	/* (ss0->ring0call)() */ jmp_system_count0();
//	IRETD();

exec3: /* ãƒ•ãƒ©ã‚¤ãƒ³ã‚°ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆç”¨åˆæµåœ°ç‚¹ */

	if (work->status == 0) {
		work->status = 1 /* ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆå‡¦ç†ä¸­(ç¾åœ¨æ™‚åˆ»ã¯æœ‰åŠ¹) */;

		ss0->ring0_count++; /* å‰²ã‚Šè¾¼ã¿ãƒ«ãƒ¼ãƒãƒ³ã®åŸºæœ¬ */
		ss0->cli_count++; /* (ã“ã‚Œã‚’ã‚„ã£ãŸã‹ã©ã†ã‹ã¯ã€work->status != 0ã‹ã©ã†ã‹ã§ã‚ã‹ã‚‹) */
	}
	/*	å‰²ã‚Šè¾¼ã¿å¯èƒ½æœŸé–“ä¸­ã¯ã€ã‚¿ã‚¤ãƒãƒ¼ãƒã‚§ãƒ¼ãƒ³ã‚’ç¹‹ãå¤‰ãˆã¦ã‚ˆã„ã€‚
		å‰²ã‚Šè¾¼ã¿ã‚·ã‚°ãƒŠãƒ«ã¯ã€ãƒã‚§ãƒ¼ãƒ³ã‚’åˆ‡ã£ã¦ã‹ã‚‰ã€å‰²ã‚Šè¾¼ã¿ã‚’è¨±å¯ã—ã¦ã€
		ãã®å¾Œã«ã‚³ãƒ¼ãƒ«ã•ã‚Œã‚‹ã€‚ */

	/* ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆãƒã‚§ãƒ¼ãƒ³ã‹ã‚‰ä¸€ã¤å–ã‚Šå‡ºã™ã€‚ */
//	(offset) tnode = work->timeout.next;
	(offset) tnext = tnode->next;
	/* (char) tnode->back = 1 */ asmout("MOV BYTE PTR DS:[ESI+#TN_back],1"); /* ã“ã®ãƒãƒ¼ãƒ‰ã¯æ™‚åˆ»ãŒã‚»ãƒƒãƒˆã•ã‚Œã¦ãŠã‚Šã€ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ãŸ(åˆ‡ã‚Šé›¢ã•ã‚ŒãŸ) */
	work->timeout.next = (offset) tnext;
	/* tnext->back = (offset) &(work->timeout) */ asmout("MOV DWORD PTR DS:[EDI+#TN_back],#work_timeout");
//	STI(); /* 2000/05/24 å‰²ã‚Šè¾¼ã¿å‡¦ç†ä¸­ã¯ä¸€è²«ã—ã¦CLIã—ã¦ãŠãã“ã¨ã«ãªã£ãŸã€‚ */
	asmout("CALL FAR DWORD DS:[ESI+#TN_call_vector]");
//	CLI();
	if (CF == 1 /* é€£ç¶šå‰²è¾¼ã¿è¦æ±‚ */) {
		/* CFã‚’1ã«ã™ã‚‹ãªã‚‰ã€ESIã‚’å£Šã—ã¦ã¯ã„ã‘ãªã„ */

		/*	ãƒãƒ¼ãƒ‰ã‚’æ›´æ–°ã—ã¦ã€ç™»éŒ²ãƒ»ãƒ»ãƒ»ç™»éŒ²ãƒ«ãƒ¼ãƒãƒ³ã¯ã€
			headã®æ¬¡ã®ãƒãƒ¼ãƒ‰ã«ç¹‹ãã“ã¨ãŒã‚ã£ãŸã‹ã©ã†ã‹ã¯ãƒã‚§ãƒƒã‚¯ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ãŒ
			å‹æ‰‹ã«TimerExecuteã‚’å‘¼ã‚“ã ã‚Šã¯ã—ãªã„ */
		EAX += tnode->time[0];
		ADC(ECX, tnode->time[4]);
		tnode->time[0] = EAX;
		ADC(EDX, tnode->time[8]);
		tnode->time[4] = ECX;
		tnode->time[8] = EDX;
		TimerRegister(); /* ESI, EDX:ECX:EAX ã«æ™‚åˆ»ã€‚ã“ã‚ŒãŒå‘¼ã°ã‚Œã‚‹ã¨ãã€ç¾åœ¨æ™‚åˆ»ã¯æœ‰åŠ¹ã€‚ */
	}

/*	ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆç¾¤ã®å­˜åœ¨ã‚’ãƒã‚§ãƒƒã‚¯ã€‚
	work->head.intervalãŒæ­£ãªã‚‰ã€ESIã‚’åŠ ãˆã‚‹
	ãã®ã‚ã¨ã§ã€ãã®ãƒãƒ¼ãƒ‰ã‚’åˆ‡ã‚Šé›¢ã—ã€ãƒ•ãƒ©ã‚¤ãƒ³ã‚°ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆãƒ«ãƒ¼ãƒãƒ³ã¸
	work->head.intervalã¾ã§ã‚‚ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¦ã—ã¾ã£ãŸã‚‰ã€ã“ã‚Œã‚‚ãƒ•ãƒ©ã‚¤ãƒ³ã‚°ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã®æœ«å°¾ã«åŠ ãˆã‚‹ */

	goto check_timeout;

invalid_inverval:
	/* ã“ã®æ™‚ã€0x80000000ä»¥ä¸Šã®å¾…ã¡æ™‚é–“ãŒã‚ã‚‹ã“ã¨ã‚’ä»®å®šã—ã¦ã„ã„ãƒ»ãƒ»ãƒ»long32ã‹max_wait */
	(offset) tnode = work->head.next;
	EAX = tnode->time[0];
	ECX = tnode->time[4];
	EAX -= work->head.time[0];
	EDX = tnode->time[8];
	SBB(ECX, work->head.time[4]);
	SBB(EDX, work->head.time[8]);
	if (!= 0)
		goto long32_wait;
	if (ECX == 0)
		goto short_wait;

long32_wait:
	EAX -= 0xffffffff;
	SBB(ECX, 0);
	SBB(EDX, 0);
	EBX = 0x90000000;
	work->longcounter = 0xffffffff;
	if (== 0) {
		if (ECX == 0) {
			if ((signed) EAX > 0)
				EBX = EAX;
		}
	}
	EAX = 0;
	work->head.interval = EBX;
	work->head.time[0] += 0xffffffff;
	ADC(work->head.time[4], EAX);
	ADC(work->head.time[8], EAX);
	if (work->status != 0)
		goto check_nesting;
	POPAD();
	POP(EAX);
	POP(DS);
//	CMP(ss0->ring0_count, 0);
//	asmout("CMP BYTE PTR SS:[0FFFFFFE0H],0");
//	asmout("JZ TimerRing0Call");
	IRETD();
}

void near TimerMouseSignal()
{
	unsigned short PIC_mastar_OCW2 == 0x0000;
	SS0_struct *ss0 == /* SS:(- sizeof (SS0_struct)) */ SS:0xffffffc0;
	TimerWork *work == DS:0x0000;

	EAX &= 0xfffffff7 /* TM1MSK = 0 */;
	ECX = EAX;
	AL >>= 2;
	AL &= 0x07;
	OUT(0x0060, AL);
	EAX = ECX;
	ECX = work->mousebuf0[0];
	EDX = work->mousebuf1[0];
	ECX &= work->mousemask0;
	EDX &= work->mousemask1;
	ECX ^= work->mousedefault0;
	EDX ^= work->mousedefault1;
	PUSH(ECX);
	ECX |= EDX;
	POP(ECX);
	asmout("JZ TimerInt_MouseSignal2");
	ECX &= work->mousebutton0;
	EDX &= work->mousebutton1;
	work->mousedefault0 ^= ECX;
	work->mousedefault1 ^= EDX;
	PUSHAD();
	AL = 0x60 /* IRQ-00ã‚’çµ‚äº† */;
	OUT(PIC_mastar_OCW2, AL);
	ss0->ring0_count++; /* å‰²ã‚Šè¾¼ã¿ãƒ«ãƒ¼ãƒãƒ³ã®åŸºæœ¬ */
	ss0->cli_count++;
	LEA(ESI, work->mousesignalbuf[0]);
	asmout("CALL FAR DWORD DS:[0080H]"); /* mousevector */
	ss0->cli_count--;
	/* (false) */ if (== 0) {
	//	PUSH(DS);
		/* (ss0->clicall)() */ asmout("CALL FAR DWORD SS:[0FFFFFFC0H+038H]");
	//	POP(DS);
	}
	POPAD();
	ss0->ring0_count--;
	POP(ECX);
	POP(EDX);
	POP(EAX);
	POP(DS);
	asmout("JZ TimerRing0Call");
	IRETD();
}

void near GetTimeAndFixZero();
void near GetNowTime();

void near TimerRegister0()
/* EDX:ECX:EAXã®ãƒ­ãƒ¼ãƒ‰ã‚’ã‚„ã‚‹ */
{
	TimerNode *tnode == DS:ESI;
	EAX = tnode->time[0];
	ECX = tnode->time[4];
	EDX = tnode->time[8];
}

void near TimerRegister()
/*	ESI, EDX:ECX:EAX ã«æ™‚åˆ»ã€‚ã“ã‚ŒãŒå‘¼ã°ã‚Œã‚‹ã¨ãã€ç¾åœ¨æ™‚åˆ»ã¯æœ‰åŠ¹ã€‚
	å‰²ã‚Šè¾¼ã¿ã‚’ç¦æ­¢ã—ã¦ãŠãã“ã¨ã€‚ */
{
	asmout("#work_timeout EQU 384");
	asmout("#TN_next EQU 60");

	TimerWork *work == DS:0x0000;
	TimerNode *tnode == DS:ESI, *tnext == DS:EDI, *tback == DS:EBX;

	EAX -= work->head.time[0];
	SBB(ECX, work->head.time[4]);
	SBB(EDX, work->head.time[8]);
	/* (false) */ if ((unsigned) < 0 /* æ—¢ã«ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ? */) {
		/* æ­£ç¢ºã«ã¯ã€0ã§ã‚‚ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆãªã®ã ãŒã€EDXã ã‘ã§ã¯åˆ†ã‹ã‚‰ãªã„ã®ã§ã€æ”¾ã£ã¦ãŠãã€‚ */
		/* (false) */ if (work->status == 0) {
			EBX = ESI;
			GetTimeAndFixZero();
			ESI = EBX;
			TimerNode *tnode2 == DS:EBX;
			EAX = tnode2->time[0];
			ECX = tnode2->time[4];
			EAX -= work->head.time[0];
			EDX = tnode2->time[8];
			/* ECX -= work->head.time[4] + CF */ SBB(ECX, work->head.time[4]);
		//	work->status = 0;
			/* EDX -= work->head.time[8] + CF */ SBB(EDX, work->head.time[8]);
			if ((unsigned) >= 0 /* ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¦ãªã„ */)
				goto entry2;
		}
		/* ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã«ç›´æ¥ç™»éŒ² */
		(offset) tback = work->timeout.back;
		work->timeout.back = (offset) tnode;
		/* tnode->next = (offset) &(work->timeout) */ asmout("MOV DWORD PTR DS:[ESI+#TN_next],#work_timeout");
		tnode->back = (offset) tback;
		tback->next = (offset) tnode;
		return;
	}
entry2:
	/* ã“ã“ã«æ¥ã‚‹ã¨ãã€EDXã®çŠ¶æ…‹ã«ã‚ˆã£ã¦ZFãŒã‚»ãƒƒãƒˆã•ã‚Œã¦ã„ã‚‹ã€‚ã—ã‹ã‚‚ã€EDXã¯è² ã§ã¯ãªã„ã€‚ */
	ECX |= EDX;
	if (!= 0)
		goto comp_time;
	if ((signed) EAX < 0)
		goto comp_time;

	// æ®‹ã‚Šæ™‚é–“ã¯31bitä»¥ä¸‹ã€‚

	// CF == 0ã§ã‚ã‚‹é™ã‚Šã€ã©ã‚“ã©ã‚“å¼•ãã€‚
	// CF == 1ã«ãªã£ãŸã‚‰ã€invalid_intervalã®ã›ã„ã‹ã€å˜ã«æ™‚é–“ãŒè¶³ã‚Šãªããªã£ãŸã‹ã®ã©ã¡ã‚‰ã‹ã§ã‚ã‚‹ã€‚
	// ã©ã£ã¡ã«ã—ã¦ã‚‚ã€ãã®å‰ã«æŒ¿å…¥ã™ã¹ããªã®ã¯ç¢ºå®Ÿã€‚

	ECX = work->head.interval; /* ã“ã‚Œã¯è² ã«ãªã‚Šã†ã‚‹ã®ã§ã€ç‰¹åˆ¥å‡¦ç†ã€‚ */
	/* (offset) tback = &work->head */ LEA((offset) tback, (int) work->head);
	EAX -= ECX;
	(offset) tnext = work->head.next;
	/* if (OF == 1) goto comp_time; */ asmout("JO #comp_time");
	if ((signed) < 0) /* unsignedã§æ¯”è¼ƒã™ã‚Œã°ä¸‹ã®ifã¯çœç•¥ã§ãã‚‹ãŒã€ECXãŒæœ‰åŠ¹ãªè² ã®å€¤ã§ã‚ã‚‹å ´åˆã‚’å–ã‚Šæ‰±ãˆãªã„ */
		goto insert;
	if ((signed) ECX < 0xa0000000)
		goto insert;

	do {
		(offset) tback = (offset) tnext; // ã“ã®æ–‡ã¯å®Ÿè¡Œé€Ÿåº¦ã‚’æ¸›å°‘ã—ãªã„(AGI)ã€‚
		EAX -= tnext->interval;
		(offset) tnext = tnext->next;
	} while ((unsigned) >= 0);

	// time      00     02     07     11     99
	// inter     02     05     04     --     ??

insert:
	tnode->back = (offset) tback;
	tnode->next = (offset) tnext;
	ECX = tback->interval;
	tback->next = (offset) tnode;
	tnext->back = (offset) tnode;
	EAX += ECX;
	TEST(ECX, ECX);
	tback->interval = EAX;
	EAX = tnext->time[0];
	if ((signed) < 0)
		goto invalid_interval;

	/* ã“ã“ã«ãã‚‹ã“ã¨ã„ã†ã“ã¨ã¯ã€æŒ¿å…¥å‰ã®tbackã®intervalãŒ31bitã§åã¾ã£ã¦ã„ãŸã“ã¨ã‚’æ„å‘³ã™ã‚‹ã€‚
	   ã ã‹ã‚‰ã€æŒ¿å…¥å¾Œã®tnodeã®intervalã‚‚31bitã§åã¾ã‚‹ã€‚ */
	EAX -= tnode->time[0];
	tnode->interval = EAX;
	return;

invalid_interval:
//	EAX = tnext->time[0];
	EAX -= tnode->time[0];
	ECX = tnext->time[4];
	if ((signed) < 0)
		goto skip1;
	EDX = tnext->time[8];
	/* ECX -= tnode->time[4] + CF */ SBB(ECX, tnode->time[4]);
	/* EDX -= tnode->time[8] + CF */ SBB(EDX, tnode->time[8]);
	ECX |= EDX;
	if (== 0)
		goto skip2;
skip1:
	EAX = 0x90000000;
skip2:
	tnode->interval = EAX;
	return;

comp_time:
	/* å¾…ã¡æ™‚é–“ã¯ã€ç¾åœ¨æ™‚åˆ»ã‹ã‚‰è¦‹ã¦ã€32bitä»¥ä¸Šã€‚
	   åˆ¥ã«32bitä»¥ä¸‹ã§ã‚‚ã„ã„ãŒã€é…ã„ã€‚ */
	/* (offset) tnext = &work->head */ LEA((offset) tnext, (int) work->head);
	EAX = tnode->time[0];
	do {
		ECX = tnode->time[4];
		CMP(EAX, tnext->time[0]);
		EDX = tnode->time[8];
		/* ECX -= tnext->time[4] + CF */ SBB(ECX, tnext->time[4]);
		(offset) tback = (offset) tnext; // å¤šåˆ†ã€ã“ã®æ–‡ã¯å®Ÿè¡Œé€Ÿåº¦ã«å½±éŸ¿ã—ãªã„(ãƒ•ãƒ©ã‚°ã‚¹ãƒˆãƒ¼ãƒ«)ã€‚
		/* EDX -= tnext->time[8] + CF */ SBB(EDX, tnext->time[8]);
		(offset) tnext = tnext->next;
	} while ((unsigned) >= 0);
	/* â†‘ã“ã‚Œã¯EDXã—ã‹è¦‹ã¦ã„ãªã„ã“ã¨ã«ãªã‚‹ãŒã€è² ã«ãªã£ãŸã‹ã©ã†ã‹ãŒçŸ¥ã‚ŠãŸã„ã®ã§ã€ã“ã‚Œã§ã‚ˆã„ã€‚ */

/*	tnode < tback < tnext ã ã£ãŸï¼(2000/05/25)
	ã ã‹ã‚‰ã€ä¸€ã¤æˆ»ã‚‹ã¹ã */
	(offset) tnext = (offset) tback;
	(offset) tback = tback->back;

	EBP = 0x90000000;
//	EAX = tnode->time[0];
	tback->interval = EBP;
	EAX -= tback->time[0];
	ECX = tnode->time[4];
	if ((signed) >= 0) { 
		EDX = tnode->time[8];
		/* ECX -= tback->time[4] + CF */ SBB(ECX, tback->time[4]);
		/* EDX -= tback->time[8] + CF */ SBB(EDX, tback->time[8]);
		ECX |= EDX;
		if (== 0)
			tback->interval = EAX;
	}
	tnode->back = (offset) tback;
	tnode->next = (offset) tnext;
	tback->next = (offset) tnode;
	tnext->back = (offset) tnode;
	EAX = tnext->time[0];
	tnode->interval = EBP;
	EAX -= tnode->time[0];
	ECX = tnext->time[4];
	if ((signed) >= 0) { 
		EDX = tnext->time[8];
		/* ECX -= tnode->time[4] + CF */ SBB(ECX, tnode->time[4]);
		/* EDX -= tnode->time[8] + CF */ SBB(EDX, tnode->time[8]);
		ECX |= EDX;
		if (== 0)
			tnode->interval = EAX;
	}
	return;
}

void near GetNowTime()
/*	work->status == 0ã®ã¨ãä»¥å¤–ã¯å‘¼ã¶ãª
	CLIã—ã¦ãŠãã“ã¨
	ç¾åœ¨æ™‚åˆ»ã‚’å–å¾—ã—ãŸã‹ã‚‰ã¨ã„ã£ã¦ã€å‰²ã‚Šè¾¼ã¿ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ãªã‘ã‚Œã°ã„ã‘ãªã„ãªã‚“ã¦ã“ã¨ã¯ãªã„ã€‚
	EDX:ECX:EAXã«ç¾åœ¨æ™‚åˆ»ã‚’è¿”ã™
	EDI:ESIã«æ®‹ã‚Šã‚«ã‚¦ãƒ³ãƒˆ(å¿…ãšæ­£) */
{
	/* æ®‹ã‚Šã‚«ã‚¦ãƒ³ãƒˆã®ç®—å‡ºæ–¹æ³• : (longcounter - 1) * 0x10000 + PIT0ã®ã‚«ã‚¦ãƒ³ãƒˆ
	   (å¤§ããªæ•°ã‚„0ã®ã¨ãã¯ã€IRQ0ãŒæ¥ã¦ã„ã‚‹ã‹ã©ã†ã‹ã«ã‚ˆã£ã¦ã€longcounterã‚’å°ã•ãè¦‹ã¦ã‚„ã‚‹å¿…è¦ãŒã‚ã‚‹ã‹ã‚‚ã—ã‚Œãªã„)
	   0ã§IRQãŒæ¥ã¦ã„ãªã‹ã£ãŸã‚‰ãƒ»ãƒ»ãƒ»ãã‚“ãªã“ã¨ã¯ã‚ã‚Šãˆãªã„ã€‚çµ¶å¯¾ã«æ¥ã¦ã„ã‚‹ã€‚ãŒã€longcountã¯æ¸›ã‚‰ã—ã¦ã¯ã„ã‘ãªã„ã€‚ */

	TimerWork *work == DS:0x0000;

	ESI = work->longcounter;
	EDI = 0;
	EAX = work->head.time[0];
	ECX = work->head.time[4];
	EAX -= ESI;
	EDX = work->head.time[8];
	/* ECX -= EDI + CF */ SBB(ECX, EDI);
	/* EDX -= CF */ SBB(EDX, EDI); 
	return;
}

void near GetTimeAndFixZero()
/* work->status == 0ã®ã¨ãä»¥å¤–ã¯å‘¼ã¶ãª
   EDI:ESIã«æ®‹ã‚Šã‚«ã‚¦ãƒ³ãƒˆ
   CLIã—ã¦ãŠãã“ã¨
   ã‚ªãƒ¼ãƒãƒ¼ãƒ©ãƒ³ã«å¯¾å¿œã§ãã‚‹ã‚ˆã†ã«ã™ã¹ã
   work->longcounterãŒ1ã§ã€ã—ã‹ã‚‚ã‚«ã‚¦ãƒ³ãƒˆã‚¢ã‚¦ãƒˆã—ã¦ã„ãŸã‚‰ã€æ™®é€šã®æ–¹æ³•ã§ç¾åœ¨æ™‚åˆ»ã‚’å‡ºã™ */
{
	// æ®‹ã‚Šã‚«ã‚¦ãƒ³ãƒˆã¯head.intervalã«åæ˜ ã•ã‚Œã‚‹ã€‚
	// ã“ã‚Œã‚’ã‚„ã‚‹ã¨ã€statusã¯2ã«ãªã‚‹ã€‚

	TimerWork *work == DS:0x0000;

	ESI = work->longcounter;
	EDI = 0;
	ESI--;
	EAX = work->head.time[0];
	ECX = work->head.time[4];
	EAX -= ESI;
	EDX = work->head.time[8];
	/* ECX -= EDI + CF */ SBB(ECX, EDI);
	/* EDX -= CF */ SBB(EDX, EDI); 

	work->head.time[0] = EAX;
	work->head.time[4] = ECX;
	work->head.time[8] = EDX;
	work->status = 2;
	work->longcounter = 1;
	if ((signed) ESI < 0)
		goto interval_over;
	work->head.interval += ESI;
	if ((signed) < 0)
		goto interval_over;
//	asmout("JO #interval_over");
	return;

interval_over:
	work->head.interval = 0x90000000;
	return;
}

void near CancelTimer()
// DS:ESIã®ã‚¿ã‚¤ãƒãƒ¼ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«
// CLIã—ã¦ãŠãã“ã¨
{
	TimerNode *tnode == DS:ESI, *tnext == DS:EDI, *tback == DS:EBX;
	/* headã«ç¹‹ãŒã£ã¦ã„ã¦ã€ã‹ã¤ã€status == 0ãªã‚‰ã€GetNowTime() + FixZero()ã—ã¦ã‹ã‚‰åˆ‡ã‚Šé›¢ã™ */
	(offset) tback = tnode->back;
//	TEST((char) (offset) tback, 0x0f);
	TEST(BL, 0x0f);
	if (== 0) {
	//	if ((offset) tnode == work->head.next) { // ã“ã‚“ãªã®ã‚„ã£ã¦ã‚‚ã€æ®‹ã‚Šæ™‚é–“ãŒå¢—ãˆã‚‹ã ã‘ã ã‹ã‚‰ã€ã„ã¡ã„ã¡å‰²ã‚Šè¾¼ã¾ãªã„ã€‚
	//		if (work->status == 0) {
	//			GetTimeAndFixZero();
	//		}
	//	}
	//	(offset) tback = tnode->back;
		(offset) tnext = tnode->next;
		int interval == EAX, interval2 == ECX;
		interval = tnode->interval;
		tback->next = (offset) tnext;
		tnext->back = (offset) tback;
		(char) tnode->back = 0x02; /* ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚ŒãŸ */
		interval2 = tback->interval;
		if ((signed) interval < 0)
			goto interval_over;
		if ((signed) interval2 < 0)
			goto interval_over;
		interval += interval2;
		if ((signed) < 0)
			goto interval_over;
		tback->interval = interval;
	}
	return;

interval_over:
	tback->interval = 0x90000000;
	return;
}

void far TimerSC_EOC()
// çµ‚äº†ã‚³ãƒãƒ³ãƒ‰
{
	EAX = [SS:ESP +  0];
	ECX = [SS:ESP +  4];
	EDX = [SS:ESP +  8];
	EBP = [SS:ESP + 12];
	ESI = [SS:ESP + 16];
	EDI = [SS:ESP + 20];
	ESP += 24; // CF = 0;
	POP(DS);
	return;
}

void near TimerSC_GetNode()
{
	asmout("#work_head EQU 256");
	asmout("#work_last EQU 320");
	asmout("#TN_back EQU 56");

	TimerWork *work == DS:0x0000;
	TimerNode *tnode == DS:ECX, *tnext == DS:EDX;
	PUSHFD();
	CLI();
	(offset) tnode = work->last.next;
	EAX = [FS:EBX + 8];
//	CMP((offset) tnode, (offset) &work->head);
	asmout("CMP ECX,#work_head");
	(offset) tnext = tnode->next;
	/* (false) */ if (==) {
		POPFD();
	//	STI();
		INT(0x03);
	}
	work->last.next = (offset) tnext;
//	tnext->back = (offset) &work->last;
	asmout("MOV DWORD PTR DS:[EDX+#TN_back],#work_last");
	POPFD();
//	STI();
	[FS:EBX + 4] = ECX; /* æ›¸ãè¾¼ã¿å³å€¤ */
	(char) tnode->back = 0x03; /* æ™‚åˆ»ã™ã‚‰ã‚»ãƒƒãƒˆã•ã‚Œã¦ã„ãªã„ */
	EBX += 8;
	asmout("JMP DWORD PTR DS:[TimerSC_JmpTbl+EAX]");
}

void near TimerSC_FreeNode()
{
	asmout("#work_last EQU 320");
	asmout("#TN_back EQU 56");

	TimerWork *work == DS:0x0000;
	TimerNode *tnode == DS:ECX, *tnext == DS:EDX;
	(offset) tnode = [FS:EBX + 4];
	EAX = [FS:EBX + 8];
	EBX += 8;
	PUSHFD();
	CLI();
	(offset) tnext = work->last.next;
	work->last.next = (offset) tnode;
//	tnode->back = (offset) &work->last;
	asmout("MOV DWORD PTR DS:[ECX+#TN_back],#work_last");
	tnode->next = (offset) tnext;
	tnext->back = (offset) tnode;
	POPFD();
//	STI();
	asmout("JMP DWORD PTR DS:[TimerSC_JmpTbl+EAX]");
}

void near TimerSC_SetNowTime()
/*	ç¾åœ¨æ™‚åˆ»ã‚’çŸ¥ã‚‹
	å‰²ã‚Šè¾¼ã¿ä¸­ã«å®Ÿè¡Œã—ãŸã‚‰é¦¬é¹¿ã€‚ãƒ»ãƒ»ãƒ»ã§ã‚‚å¤šåˆ†ã€å‰²ã‚Šè¾¼ã¿ä¸­ã§ã‚‚å¹³æ°— */
{
	TimerWork *work == DS:0x0000;

//	PUSH(EBX);
	PUSHFD();
	CLI();
	if (work->status == 0) {
		GetNowTime();
	} else {
		EAX = work->head.time[0];
		ECX = work->head.time[4];
		EDX = work->head.time[8];
	}
	POPFD();
//	STI();
//	POP(EBX);
	ESI = [FS:EBX + 16];
	[FS:EBX +  4] = EAX;
	[FS:EBX +  8] = ECX;
	[FS:EBX + 12] = EDX;
	EBX += 16;
	asmout("JMP DWORD PTR DS:[TimerSC_JmpTbl+ESI]");
}

void near TimerSC_SetTimer()
{
	SS0_struct *ss0 == /* SS:(- sizeof (SS0_struct)) */ SS:0xffffffc0;
	TimerWork *work == DS:0x0000;
	TimerNode *tnode == DS:ESI;
	(offset) tnode = [FS:EBX + 4];
	PUSH(EBX);
	PUSHFD();
	CLI();
	ss0->cli_count++;
	TimerRegister0();
	work->status = 0;
	
	ss0->cli_count--;
	/* (false) */ if (== 0) {
		PUSH(DS);
	//	PUSHAD();
		/* (ss0->clicall)() */ asmout("CALL FAR DWORD SS:[0FFFFFFC0H+038H]");
	//	POPAD();
		POP(DS);
	}
	POPFD();
//	STI();
	POP(EBX);
	EAX = [FS:EBX + 8];
	EBX += 8;
	asmout("JMP DWORD PTR DS:[TimerSC_JmpTbl+EAX]");
}

void near TimerSC_CancelTimer()
{
	TimerNode *tnode == DS:ESI;
	(offset) tnode = [FS:EBX + 4];
	EBP = EBX;
	PUSHFD();
	CLI();
	CancelTimer();
	POPFD();
//	STI();
	EAX = [FS:EBP + 8];
	/* EBX = EBP + 8 */ asmout("LEA EBX,[EBP+8]");
	asmout("JMP DWORD PTR DS:[TimerSC_JmpTbl+EAX]");
}

void near TimerSC_SetNowTimeNode()
/*	ç¾åœ¨æ™‚åˆ»ã‚’çŸ¥ã‚‹
	å‰²ã‚Šè¾¼ã¿ä¸­ã«å®Ÿè¡Œã—ãŸã‚‰é¦¬é¹¿ã€‚ãƒ»ãƒ»ãƒ»ã§ã‚‚å¤šåˆ†ã€å‰²ã‚Šè¾¼ã¿ä¸­ã§ã‚‚å¹³æ°— */
{
	TimerWork *work == DS:0x0000;
	TimerNode *tnode == DS:ESI;

//	PUSH(EBX);
	PUSHFD();
	CLI();
	if (work->status == 0) {
		GetNowTime();
	} else {
		EAX = work->head.time[0];
		ECX = work->head.time[4];
		EDX = work->head.time[8];
	}
	POPFD();
//	STI();
//	POP(EBX);
	(offset) tnode = [FS:EBX + 4];
	EDI = [FS:EBX + 8];
	EBX += 8;
	tnode->time[0] = EAX;
	tnode->time[4] = ECX;
	tnode->time[8] = EDX;
	asmout("JMP DWORD PTR DS:[TimerSC_JmpTbl+EDI]");
}

void near TimerSC_AddTimeNode()
{
	TimerWork *work == DS:0x0000;
	TimerNode *tnode == DS:ESI;

	(offset) tnode = [FS:EBX +  4];
	EAX = [FS:EBX +  8];
	ECX = [FS:EBX + 12];
	EDX = [FS:EBX + 16];
	EDI = [FS:EBX + 20];
	EBX += 20;
	tnode->time[0] += EAX;
	ADC(tnode->time[4], ECX);
	ADC(tnode->time[8], EDX);
	asmout("JMP DWORD PTR DS:[TimerSC_JmpTbl+EDI]");
}

void near TimerSC_SubTimeNode()
{
	TimerWork *work == DS:0x0000;
	TimerNode *tnode0 == DS:ESI, *tnode1 == DS:EDI;

	(offset) tnode1 = [FS:EBX +  8];
	(offset) tnode0 = [FS:EBX +  4];
	// tnode1 - tnode0
	EAX = tnode1->time[0];
	ECX = tnode1->time[4]; EAX -= tnode0->time[0];
	EDX = tnode1->time[8]; SBB(ECX, tnode0->time[4]);
	EDI = [FS:EBX + 24];   SBB(EDX, tnode0->time[8]);
	[FS:EBX + 12] = EAX;
	[FS:EBX + 16] = ECX;
	[FS:EBX + 20] = EDX;
	EBX += 24;
	asmout("JMP DWORD PTR DS:[TimerSC_JmpTbl+EDI]");
}

void near TimerSC_SetCallVectorNode()
{
	TimerWork *work == DS:0x0000;
	TimerNode *tnode == DS:ESI;

	(offset) tnode = [FS:EBX +  4];
	EAX = [FS:EBX +  8];
	ECX = [FS:EBX + 12];
	EDI = [FS:EBX + 16];
	EBX += 16;
	tnode->call_vector[0] = EAX;
	tnode->call_vector[4] = ECX;
	asmout("JMP DWORD PTR DS:[TimerSC_JmpTbl+EDI]");
}

void near TimerSC_SetMsgDataNode()
{
	TimerWork *work == DS:0x0000;
	TimerNode *tnode == DS:ESI;

	ESI = [FS:EBX +  4];
	ECX = [FS:EBX +  8];
	EBX += 12;

	#if (defined(DEBUG))
		TEST((char) tnode->back, 0x0f);
		if (== 0)
			INT(0x03);
	#endif

	do {
		EAX = [FS:EBX];
		EBX += 4;
		[DS:ESI] = EAX;
		ESI += 4;
		ECX--;
	} while (!= 0);
	EAX = [FS:EBX];
	asmout("JMP DWORD PTR DS:[TimerSC_JmpTbl+EAX]");
}

void near TimerSC_AddTimeNode2()
{
	TimerWork *work == DS:0x0000;
	TimerNode *tnode == DS:EDI;
	TimerNode *tnode2 == DS:ESI;

	(offset) tnode  = [FS:EBX +  4];
	(offset) tnode2 = [FS:EBX +  8];
	EAX = [FS:EBX + 12];
	ECX = [FS:EBX + 16];
	EAX += tnode->time[0];
	EDX = [FS:EBX + 20];
	ADC(ECX, tnode->time[4]);
	tnode2->time[0] = EAX;
	ADC(EDX, tnode->time[8]);
	EDI = [FS:EBX + 24];
	tnode2->time[4] = ECX;
	tnode2->time[8] = EDX;
	EBX += 24;
	asmout("JMP DWORD PTR DS:[TimerSC_JmpTbl+EDI]");
}

void TimerInit();

void TimerSC_Special()
{
	EAX = (int) [FS:EBX + 4]; /* sub-cmd(4ã®å€æ•°) */
	if (EAX == 0) {
		/* åˆæœŸåŒ– */
		EBX += 16;
		PUSH(EBX);
		TimerInit();
		POP(EBX);
	} else if (EAX == 4) {
		// ãƒãƒ¼ãƒ‰æ§‹æˆã¨æ™‚é–“å˜ä½ã®æä¾›
		// +08 : ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚¨ãƒªã‚¢é•·
		// +0c : far vectorã‚¨ãƒªã‚¢ã‚ªãƒ•ã‚»ãƒƒãƒˆ(6ãƒã‚¤ãƒˆ)
		// +10 : ã‚¿ã‚¤ãƒ ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰(12ãƒã‚¤ãƒˆ)
		// +14 : reserve
		// +18 : å‰²ã‚Šè¾¼ã¿å‘¨æœŸ[sec]ã®2^64å€(8ãƒã‚¤ãƒˆ)
		// +20 : å‰²ã‚Šè¾¼ã¿å‘¨æ³¢æ•°[Hz]ã®2^32å€(8ãƒã‚¤ãƒˆ)
		(int) [FS:EBX + 0x08] = 32;
		(int) [FS:EBX + 0x0c] = 32;
		(int) [FS:EBX + 0x10] = 40;
		(int) [FS:EBX + 0x14] = 0;
		(int) [FS:EBX + 0x18] = 0x17e4b17e;
		(int) [FS:EBX + 0x1c] = 0x00417e4b;
		(int) [FS:EBX + 0x20] = 0xa6c67668;
		(int) [FS:EBX + 0x24] = 1000;
		EBX += 40;
	} else if (EAX == 8) {
		// Intãƒãƒ³ãƒ‰ãƒ©æƒ…å ±
		// +08 : ã‚¨ãƒ³ãƒˆãƒª
		// +0c : reserve
		// +10 : reserve
		// +14 : reserve
		// +18 : reserve
		// +1c : reserve
		ECX = 0;
		asmout("MOV DWORD [FS:EBX+0x08],TimerInt");
		(int) [FS:EBX + 0x0c] = ECX;
		asmout("MOV DWORD [FS:EBX+0x10],int8vect");
		(int) [FS:EBX + 0x14] = ECX;
		(int) [FS:EBX + 0x18] = ECX;
		(int) [FS:EBX + 0x1c] = ECX;
		EBX += 32;
	} else if (EAX == 12) {
		calc_count1ms();
		(int) [FS:EBX + 0x08] = EAX;
		(int) [FS:EBX + 0x0c] = 0;
		EBX += 16;
	} else {
		INT(0x03);
	}
	EAX = [FS:EBX];
	TEST(EAX, EAX);
	asmout("JZ TimerSC_EOC");
//	if (EAX == 0)
//		goto TimerSC_EOC;
	asmout("JMP DWORD PTR DS:[TimerSC_JmpTbl+EAX]");
}

void near TimerSC_SetMouseParam()
/*
	+00 : ã‚³ãƒãƒ³ãƒ‰ã‚³ãƒ¼ãƒ‰(0x0030)
    +04 : ã‚ªãƒ—ã‚·ãƒ§ãƒ³
		bit0 : ãƒãƒ¼ãƒ‰ç¢ºä¿(type0)
		bit1 : ãƒãƒ¼ãƒ‰é–‹æ”¾
		bit2 : ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼è»¢é€(type1)
		bit3 : ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼è»¢é€(type2)
		bit8 : mouseflag0(bit3==1ã®ã¨ãã®ã¿æœ‰åŠ¹)
		bit9 : mouseflag1(bit3==1ã®ã¨ãã®ã¿æœ‰åŠ¹)
	<type0>
	+00 : ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ãƒ¬ãƒ¼ãƒˆ
	<type1>
	+00 : mousevector[8]
    +08 : mousesignalbuf[16]
    +18 : mousewait0
    +1a : mousewait1
	+1c : mousestrobe[4]
	<type2>
	+00 : mousemask0, mousedefault0, mousemask1, mousedefault1
*/
{
	SS0_struct *ss0 == /* SS:(- sizeof (SS0_struct)) */ SS:0xffffffc0;
	TimerWork *work == DS:0x0000;
	int *cmd == FS:EBX;
	TimerNode *tnode == DS:ESI, *tnext == DS:EDX;

	asmout("#work_head EQU 256");
	asmout("#work_last EQU 320");
	asmout("#TN_back EQU 56");

	EAX = cmd[4];
	(offset) cmd += 8;
	TEST(AL, 0x01);
	if (!= 0) {
		/* timernodeç¢ºä¿ */
		PUSHFD();
		CLI();
		(offset) tnode = work->last.next;
	//	CMP((offset) tnode, (offset) &work->head);
		asmout("CMP ESI,#work_head");
		(offset) tnext = tnode->next;
		/* (false) */ if (==) {
			POPFD();
			INT(0x03);
		}
		work->last.next = (offset) tnext;
	//	tnext->back = (offset) &work->last;
		asmout("MOV DWORD PTR DS:[EDX+#TN_back],#work_last");
		POPFD();
		work->mousetimernode = (offset) tnode;
		asmout("MOV BYTE PTR DS:[ESI+#TN_back],03H"); /* æ™‚åˆ»ã™ã‚‰ã‚»ãƒƒãƒˆã•ã‚Œã¦ã„ãªã„ */
		ECX = cmd[0];
		(offset) cmd += 4;
		tnode->signalbuf[0] = ECX;
	}
	TEST(AL, 0x02);
	if (!= 0) {
		/* timernodeé–‹æ”¾ */
		PUSH(EBX);
		PUSH(EAX);
		(offset) tnode = work->mousetimernode;
		PUSHFD();
		CLI();
		CancelTimer();
		(offset) tnode = work->mousetimernode;
		(offset) tnext = work->last.next;
		work->last.next = (offset) tnode;
	//	tnode->back = (offset) &work->last;
		asmout("MOV DWORD PTR DS:[ESI+#TN_back],#work_last");
		tnode->next = (offset) tnext;
		tnext->back = (offset) tnode;
		work->mousetimernode = 0;
		POPFD();
		POP(EAX);
		POP(EBX);
	}
	TEST(AL, 0x04);
	if (!= 0) {
		/* type1ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼è»¢é€ */
		ECX = cmd[ 0];
		EDX = cmd[ 4];
		work->mousevector[0] = ECX;
		work->mousevector[4] = EDX;
		ECX = cmd[ 8];
		EDX = cmd[12];
		work->mousesignalbuf[ 0] = ECX;
		work->mousesignalbuf[ 4] = EDX;
		ECX = cmd[16];
		EDX = cmd[20];
		work->mousesignalbuf[ 8] = ECX;
		work->mousesignalbuf[12] = EDX;
		ECX = cmd[24];
		EDX = cmd[28];
		(ofBX + 0x14] = ECX;
		(int) [FS:EBX + 0x18] = ECX;
		(int) [FS:EBX + 0x1c] = ECX;
		EBX += 32;
	} else if (EAX == 12) {
		calc_count1ms();
		(int) [FS:EBX + 0x08] = EAX;
		(int) [FS:EBX + 0x0c] = 0;
		EBX += 16;
	} else {
		INT(0x03);
	}
	EAX = [FS:EBX];
	TEST(EAX, EAX);
	asmout("JZ TimerSC_EOC");
//	if (EAX == 0)
//		goto TimerSC_EOC;
	asmout("JMP DWORD PTR DS:[TimerSC_JmpTbl+EAX]");
}

void near TimerSC_SetMouseParam()
/*
	+00 : ç¹§ï½³ç¹æ§­Î¦ç¹å³¨ã•ç¹ï½¼ç¹work->timeout.next = EAX;

// ECX‚ğ•Û‘¶‚µ‚ë

	TimerNode *tnode == DS:ESI, *tback == DS:EBX, *tnext == DS:EDI;

	EAX = 50 + 64;
//	(offset) tback = (offset) &work->freenode - sizeof (TimerNode);
//	(offset) tnode = (offset) &work->freenode;
//	(offset) tnext = (offset) &work->freenode + sizeof (TimerNode);
	asmout("MOV EBX,#work_freenode-64");
	asmout("MOV ESI,#work_freenode");
	asmout("MOV EDI,#work_freenode+64");

	work->last.next = (offset) tnode;

	do {
		tnode->back = (offset) tback;
		tnode->next = (offset) tnext;
		(offset) tback = (offset) tnode;
		(offset) tnode = (offset) tnext;
		(offset) tnext += sizeof (TimerNode);
		EAX--;
	} while (!= 0);

	work->head.back = (offset) tback;
//	work->freenode[0].back = (offset) &work->last;
	asmout("MOV DWORD PTR DS:[#work_freenode+#TN_back],#work_last");
	/* tback->next = (offset) &work->head */ asmout("MOV DWORD PTR DS:[EBX+#TN_back],#work_head");

	work->mousetimernode = /* 0 */ EAX; /* –¢g—p */

	asmout("MOV EAX,TimerSC_JmpTbl");
	asmout("MOV DWORD DS:[EAX+ 0],TimerSC_EOC");
	asmout("MOV DWORD DS:[EAX+ 4],TimerSC_Special");
	asmout("MOV DWORD DS:[EAX+ 8],TimerSC_GetNode");
	asmout("MOV DWORD DS:[EAX+12],TimerSC_FreeNode");
	asmout("MOV DWORD DS:[EAX+16],TimerSC_SetTimer");
	asmout("MOV DWORD DS:[EAX+20],TimerSC_CancelTimer");
	asmout("MOV DWORD DS:[EAX+24],TimerSC_SetNowTime");
	asmout("MOV DWORD DS:[EAX+28],TimerSC_SetNowTimeNode");
	asmout("MOV DWORD DS:[EAX+32],TimerSC_AddTimeNode");
	asmout("MOV DWORD DS:[EAX+36],TimerSC_SubTimeNode");
	asmout("MOV DWORD DS:[EAX+40],TimerSC_SetCallVectorNode");
	asmout("MOV DWORD DS:[EAX+44],TimerSC_SetMsgDataNode");

	asmout("MOV DWORD DS:[EAX+48],TimerSC_SetMouseParam");
	asmout("MOV DWORD DS:[EAX+52],TimerSC_AddTimeNode2");

	IN(AL, 0x0060);
	AL >>= 2;
	AL &= 0x04;
	AL |= 0x81;
	OUT(0x0060, AL);
	AL = 0x80;
	OUT(0x0068, AL); // timer2‚ğdisable‚É‚·‚é(10FˆÈ~)
	NOP();
	IN(AL, 0x0068);
	NOP();

	// IRQ-00‚Ìƒ}ƒXƒN‚ğ‰ğœ‚µ‚ÄAŠ„‚è‚İ‚ğ‹N‚±‚³‚¹‚éB
	IN(AL, PIC_master_IMR);
	AL &= 0xfe; // IRQ-00‹–‰Â
	OUT(PIC_master_OCW1, AL);

	AL = 0x36 /* PIT0, Low/High, mode3, binary */;
	OUT(PIT_CMD, AL);
	AL = 0x33; // İ’è’l(307)
	OUT(PIT0_COUNT, AL);
	AL = 0x01;
	OUT(PIT0_COUNT, AL);

	POPFD();

	return;
}

/* mscountŒvZ—p */

void calc_count1ms_sub()
{
	PUSH(EAX);
	AL = 0x36;
	OUT(0x46, AL);
	POP(EAX);
	OUT(0x40, AL);
	AL = AH;
	OUT(0x40, AL);
	EAX = 0;
	do {
		EAX--;
	} while (!= 0);
	NEG(ECX);
	return;
}

void far int8vect()
{
	ECX = EAX;
	IN(AL, 0x0060);
	/* PIT0‚Ìƒ^ƒCƒ€ƒAƒEƒg‚ğó— */
	AL >>= 2;
	AL &= 0x87;
	AL |= 0x80;
	OUT(0x0060, AL);
	AL = 0x60;
	OUT(0x00, AL);
	EAX = 1;
	IRET();
}

void calc_count1ms()
/* do { EAX--; } while (!= 0);‚Å1.0ms‚É—v‚·‚éŠÔ‚ğ‚Å‚«‚é‚¾‚¯³Šm‚É‘ª’è */
/* 4GHz‚Å1clock/loop‚Ìê‡A0x003d0900‚ª‹A‚Á‚Ä‚­‚é */
{
	PUSH(EBX);
	PUSH(EDX);
	PUSH(ECX);

	/* ˆÀ‘S‚Ì‚½‚ß‚Ìƒ_ƒ~[İ’è */
	AL = 0x36;
	OUT(0x46, AL);
	EAX = 0;
	OUT(0x40, AL);
	NOP();
	OUT(0x40, AL);
	NOP();

	/* PIT0‚¾‚¯‚É‚·‚é */
	IN(AL, 0x0060);
	AL >>= 2;
	AL &= 0x05;
	AL |= 0x81;
	OUT(0x0060, AL);
	AL = 0x80;
	OUT(0x0068, AL); // timer2‚ğdisable‚É‚·‚é(10FˆÈ~)
	NOP();
	IN(AL, 0x0068);
	NOP();

	/* ƒfƒtƒHƒ‹ƒg‚Í65536‚ç‚µ‚¢ „ PIT0 */

	IN(AL, 0x02);
	BL = AL;
	AL = 0xfe;
	OUT(0x02, AL);	/* ‘ª’èŒë·‚ğ‚È‚­‚·‚½‚ß‚ÉAPIC‚ğƒ^ƒCƒ}[‚Ì‚İ‚É‚·‚é */

	EAX = 31; /* ƒLƒƒƒbƒVƒ…‚É‚Í‚ß‚é‚½‚ß(0.1ms) */
	calc_count1ms_sub();
	EAX = 307 * 2;
	calc_count1ms_sub();
	EDX = ECX;
	EAX = 307;
	calc_count1ms_sub(); /* ‡Œv(3.1ms) */
	EDX -= ECX;

	AL = 0x36;
	OUT(0x46, AL);
	EAX = 0;
	OUT(0x40, AL);
	NOP();
	OUT(0x40, AL);

	AL = BL;
	OUT(0x02, AL);

	EAX = EDX;
	POP(ECX);
	POP(EDX);
	POP(EBX);
	return;
}
